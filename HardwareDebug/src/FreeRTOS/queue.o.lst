   1              		.cpu cortex-a9
   2              		.eabi_attribute 28, 1
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"queue.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.text.prvGetDisinheritPriorityAfterTimeout,"ax",%progbits
  17              		.align	2
  18              		.arch armv7-a
  19              		.arch_extension mp
  20              		.arch_extension sec
  21              		.syntax unified
  22              		.arm
  23              		.fpu neon
  25              	prvGetDisinheritPriorityAfterTimeout:
  26              	.LVL0:
  27              	.LFB25:
  28              		.file 1 "../src/FreeRTOS/queue.c"
   1:../src/FreeRTOS/queue.c **** /*
   2:../src/FreeRTOS/queue.c ****  * FreeRTOS Kernel V10.4.3 LTS Patch 1
   3:../src/FreeRTOS/queue.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../src/FreeRTOS/queue.c ****  *
   5:../src/FreeRTOS/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../src/FreeRTOS/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../src/FreeRTOS/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:../src/FreeRTOS/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../src/FreeRTOS/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../src/FreeRTOS/queue.c ****  * subject to the following conditions:
  11:../src/FreeRTOS/queue.c ****  *
  12:../src/FreeRTOS/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../src/FreeRTOS/queue.c ****  * copies or substantial portions of the Software.
  14:../src/FreeRTOS/queue.c ****  *
  15:../src/FreeRTOS/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../src/FreeRTOS/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../src/FreeRTOS/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../src/FreeRTOS/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../src/FreeRTOS/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../src/FreeRTOS/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../src/FreeRTOS/queue.c ****  *
  22:../src/FreeRTOS/queue.c ****  * https://www.FreeRTOS.org
  23:../src/FreeRTOS/queue.c ****  * https://github.com/FreeRTOS
  24:../src/FreeRTOS/queue.c ****  *
  25:../src/FreeRTOS/queue.c ****  */
  26:../src/FreeRTOS/queue.c **** 
  27:../src/FreeRTOS/queue.c **** #include <stdlib.h>
  28:../src/FreeRTOS/queue.c **** #include <string.h>
  29:../src/FreeRTOS/queue.c **** 
  30:../src/FreeRTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  31:../src/FreeRTOS/queue.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  32:../src/FreeRTOS/queue.c ****  * task.h is included from an application file. */
  33:../src/FreeRTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  34:../src/FreeRTOS/queue.c **** 
  35:../src/FreeRTOS/queue.c **** #include "FreeRTOS.h"
  36:../src/FreeRTOS/queue.c **** #include "task.h"
  37:../src/FreeRTOS/queue.c **** #include "queue.h"
  38:../src/FreeRTOS/queue.c **** 
  39:../src/FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  40:../src/FreeRTOS/queue.c ****     #include "croutine.h"
  41:../src/FreeRTOS/queue.c **** #endif
  42:../src/FreeRTOS/queue.c **** 
  43:../src/FreeRTOS/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:../src/FreeRTOS/queue.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:../src/FreeRTOS/queue.c ****  * for the header files above, but not in this file, in order to generate the
  46:../src/FreeRTOS/queue.c ****  * correct privileged Vs unprivileged linkage and placement. */
  47:../src/FreeRTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:../src/FreeRTOS/queue.c **** 
  49:../src/FreeRTOS/queue.c **** 
  50:../src/FreeRTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  51:../src/FreeRTOS/queue.c **** #define queueUNLOCKED             ( ( int8_t ) -1 )
  52:../src/FreeRTOS/queue.c **** #define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )
  53:../src/FreeRTOS/queue.c **** #define queueINT8_MAX             ( ( int8_t ) 127 )
  54:../src/FreeRTOS/queue.c **** 
  55:../src/FreeRTOS/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:../src/FreeRTOS/queue.c ****  * pcTail members are used as pointers into the queue storage area.  When the
  57:../src/FreeRTOS/queue.c ****  * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:../src/FreeRTOS/queue.c ****  * not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:../src/FreeRTOS/queue.c ****  * structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:../src/FreeRTOS/queue.c ****  * names to the pcHead and structure member to ensure the readability of the code
  61:../src/FreeRTOS/queue.c ****  * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:../src/FreeRTOS/queue.c ****  * a union as their usage is mutually exclusive dependent on what the queue is
  63:../src/FreeRTOS/queue.c ****  * being used for. */
  64:../src/FreeRTOS/queue.c **** #define uxQueueType               pcHead
  65:../src/FreeRTOS/queue.c **** #define queueQUEUE_IS_MUTEX       NULL
  66:../src/FreeRTOS/queue.c **** 
  67:../src/FreeRTOS/queue.c **** typedef struct QueuePointers
  68:../src/FreeRTOS/queue.c **** {
  69:../src/FreeRTOS/queue.c ****     int8_t * pcTail;     /*< Points to the byte at the end of the queue storage area.  Once more by
  70:../src/FreeRTOS/queue.c ****     int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the str
  71:../src/FreeRTOS/queue.c **** } QueuePointers_t;
  72:../src/FreeRTOS/queue.c **** 
  73:../src/FreeRTOS/queue.c **** typedef struct SemaphoreData
  74:../src/FreeRTOS/queue.c **** {
  75:../src/FreeRTOS/queue.c ****     TaskHandle_t xMutexHolder;        /*< The handle of the task that holds the mutex. */
  76:../src/FreeRTOS/queue.c ****     UBaseType_t uxRecursiveCallCount; /*< Maintains a count of the number of times a recursive mute
  77:../src/FreeRTOS/queue.c **** } SemaphoreData_t;
  78:../src/FreeRTOS/queue.c **** 
  79:../src/FreeRTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:../src/FreeRTOS/queue.c ****  * zero. */
  81:../src/FreeRTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )
  82:../src/FreeRTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )
  83:../src/FreeRTOS/queue.c **** 
  84:../src/FreeRTOS/queue.c **** #if ( configUSE_PREEMPTION == 0 )
  85:../src/FreeRTOS/queue.c **** 
  86:../src/FreeRTOS/queue.c **** /* If the cooperative scheduler is being used then a yield should not be
  87:../src/FreeRTOS/queue.c ****  * performed just because a higher priority task has been woken. */
  88:../src/FreeRTOS/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()
  89:../src/FreeRTOS/queue.c **** #else
  90:../src/FreeRTOS/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
  91:../src/FreeRTOS/queue.c **** #endif
  92:../src/FreeRTOS/queue.c **** 
  93:../src/FreeRTOS/queue.c **** /*
  94:../src/FreeRTOS/queue.c ****  * Definition of the queue used by the scheduler.
  95:../src/FreeRTOS/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  96:../src/FreeRTOS/queue.c ****  * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
  97:../src/FreeRTOS/queue.c ****  */
  98:../src/FreeRTOS/queue.c **** typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel awar
  99:../src/FreeRTOS/queue.c **** {
 100:../src/FreeRTOS/queue.c ****     int8_t * pcHead;           /*< Points to the beginning of the queue storage area. */
 101:../src/FreeRTOS/queue.c ****     int8_t * pcWriteTo;        /*< Points to the free next place in the storage area. */
 102:../src/FreeRTOS/queue.c **** 
 103:../src/FreeRTOS/queue.c ****     union
 104:../src/FreeRTOS/queue.c ****     {
 105:../src/FreeRTOS/queue.c ****         QueuePointers_t xQueue;     /*< Data required exclusively when this structure is used as a 
 106:../src/FreeRTOS/queue.c ****         SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a 
 107:../src/FreeRTOS/queue.c ****     } u;
 108:../src/FreeRTOS/queue.c **** 
 109:../src/FreeRTOS/queue.c ****     List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post onto
 110:../src/FreeRTOS/queue.c ****     List_t xTasksWaitingToReceive;          /*< List of tasks that are blocked waiting to read from
 111:../src/FreeRTOS/queue.c **** 
 112:../src/FreeRTOS/queue.c ****     volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. */
 113:../src/FreeRTOS/queue.c ****     UBaseType_t uxLength;                   /*< The length of the queue defined as the number of it
 114:../src/FreeRTOS/queue.c ****     UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold. */
 115:../src/FreeRTOS/queue.c **** 
 116:../src/FreeRTOS/queue.c ****     volatile int8_t cRxLock;                /*< Stores the number of items received from the queue 
 117:../src/FreeRTOS/queue.c ****     volatile int8_t cTxLock;                /*< Stores the number of items transmitted to the queue
 118:../src/FreeRTOS/queue.c **** 
 119:../src/FreeRTOS/queue.c ****     #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 120:../src/FreeRTOS/queue.c ****         uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was static
 121:../src/FreeRTOS/queue.c ****     #endif
 122:../src/FreeRTOS/queue.c **** 
 123:../src/FreeRTOS/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 124:../src/FreeRTOS/queue.c ****         struct QueueDefinition * pxQueueSetContainer;
 125:../src/FreeRTOS/queue.c ****     #endif
 126:../src/FreeRTOS/queue.c **** 
 127:../src/FreeRTOS/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 128:../src/FreeRTOS/queue.c ****         UBaseType_t uxQueueNumber;
 129:../src/FreeRTOS/queue.c ****         uint8_t ucQueueType;
 130:../src/FreeRTOS/queue.c ****     #endif
 131:../src/FreeRTOS/queue.c **** } xQUEUE;
 132:../src/FreeRTOS/queue.c **** 
 133:../src/FreeRTOS/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:../src/FreeRTOS/queue.c ****  * name below to enable the use of older kernel aware debuggers. */
 135:../src/FreeRTOS/queue.c **** typedef xQUEUE Queue_t;
 136:../src/FreeRTOS/queue.c **** 
 137:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 138:../src/FreeRTOS/queue.c **** 
 139:../src/FreeRTOS/queue.c **** /*
 140:../src/FreeRTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:../src/FreeRTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:../src/FreeRTOS/queue.c ****  */
 143:../src/FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:../src/FreeRTOS/queue.c **** 
 145:../src/FreeRTOS/queue.c **** /* The type stored within the queue registry array.  This allows a name
 146:../src/FreeRTOS/queue.c ****  * to be assigned to each queue making kernel aware debugging a little
 147:../src/FreeRTOS/queue.c ****  * more user friendly. */
 148:../src/FreeRTOS/queue.c ****     typedef struct QUEUE_REGISTRY_ITEM
 149:../src/FreeRTOS/queue.c ****     {
 150:../src/FreeRTOS/queue.c ****         const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and s
 151:../src/FreeRTOS/queue.c ****         QueueHandle_t xHandle;
 152:../src/FreeRTOS/queue.c ****     } xQueueRegistryItem;
 153:../src/FreeRTOS/queue.c **** 
 154:../src/FreeRTOS/queue.c **** /* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:../src/FreeRTOS/queue.c ****  * new xQueueRegistryItem name below to enable the use of older kernel aware
 156:../src/FreeRTOS/queue.c ****  * debuggers. */
 157:../src/FreeRTOS/queue.c ****     typedef xQueueRegistryItem QueueRegistryItem_t;
 158:../src/FreeRTOS/queue.c **** 
 159:../src/FreeRTOS/queue.c **** /* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:../src/FreeRTOS/queue.c ****  * The pcQueueName member of a structure being NULL is indicative of the
 161:../src/FreeRTOS/queue.c ****  * array position being vacant. */
 162:../src/FreeRTOS/queue.c ****     PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:../src/FreeRTOS/queue.c **** 
 164:../src/FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:../src/FreeRTOS/queue.c **** 
 166:../src/FreeRTOS/queue.c **** /*
 167:../src/FreeRTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:../src/FreeRTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:../src/FreeRTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:../src/FreeRTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:../src/FreeRTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:../src/FreeRTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:../src/FreeRTOS/queue.c ****  */
 174:../src/FreeRTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:../src/FreeRTOS/queue.c **** 
 176:../src/FreeRTOS/queue.c **** /*
 177:../src/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:../src/FreeRTOS/queue.c ****  *
 179:../src/FreeRTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:../src/FreeRTOS/queue.c ****  */
 181:../src/FreeRTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 182:../src/FreeRTOS/queue.c **** 
 183:../src/FreeRTOS/queue.c **** /*
 184:../src/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:../src/FreeRTOS/queue.c ****  *
 186:../src/FreeRTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:../src/FreeRTOS/queue.c ****  */
 188:../src/FreeRTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 189:../src/FreeRTOS/queue.c **** 
 190:../src/FreeRTOS/queue.c **** /*
 191:../src/FreeRTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:../src/FreeRTOS/queue.c ****  * back of the queue.
 193:../src/FreeRTOS/queue.c ****  */
 194:../src/FreeRTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
 195:../src/FreeRTOS/queue.c ****                                       const void * pvItemToQueue,
 196:../src/FreeRTOS/queue.c ****                                       const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
 197:../src/FreeRTOS/queue.c **** 
 198:../src/FreeRTOS/queue.c **** /*
 199:../src/FreeRTOS/queue.c ****  * Copies an item out of a queue.
 200:../src/FreeRTOS/queue.c ****  */
 201:../src/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
 202:../src/FreeRTOS/queue.c ****                                   void * const pvBuffer ) PRIVILEGED_FUNCTION;
 203:../src/FreeRTOS/queue.c **** 
 204:../src/FreeRTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 205:../src/FreeRTOS/queue.c **** 
 206:../src/FreeRTOS/queue.c **** /*
 207:../src/FreeRTOS/queue.c ****  * Checks to see if a queue is a member of a queue set, and if so, notifies
 208:../src/FreeRTOS/queue.c ****  * the queue set that the queue contains data.
 209:../src/FreeRTOS/queue.c ****  */
 210:../src/FreeRTOS/queue.c ****     static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTI
 211:../src/FreeRTOS/queue.c **** #endif
 212:../src/FreeRTOS/queue.c **** 
 213:../src/FreeRTOS/queue.c **** /*
 214:../src/FreeRTOS/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 215:../src/FreeRTOS/queue.c ****  * dynamically to fill in the structure's members.
 216:../src/FreeRTOS/queue.c ****  */
 217:../src/FreeRTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 218:../src/FreeRTOS/queue.c ****                                    const UBaseType_t uxItemSize,
 219:../src/FreeRTOS/queue.c ****                                    uint8_t * pucQueueStorage,
 220:../src/FreeRTOS/queue.c ****                                    const uint8_t ucQueueType,
 221:../src/FreeRTOS/queue.c ****                                    Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 222:../src/FreeRTOS/queue.c **** 
 223:../src/FreeRTOS/queue.c **** /*
 224:../src/FreeRTOS/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 225:../src/FreeRTOS/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 226:../src/FreeRTOS/queue.c ****  * as a mutex.
 227:../src/FreeRTOS/queue.c ****  */
 228:../src/FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 229:../src/FreeRTOS/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 230:../src/FreeRTOS/queue.c **** #endif
 231:../src/FreeRTOS/queue.c **** 
 232:../src/FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 233:../src/FreeRTOS/queue.c **** 
 234:../src/FreeRTOS/queue.c **** /*
 235:../src/FreeRTOS/queue.c ****  * If a task waiting for a mutex causes the mutex holder to inherit a
 236:../src/FreeRTOS/queue.c ****  * priority, but the waiting task times out, then the holder should
 237:../src/FreeRTOS/queue.c ****  * disinherit the priority - but only down to the highest priority of any
 238:../src/FreeRTOS/queue.c ****  * other tasks that are waiting for the same mutex.  This function returns
 239:../src/FreeRTOS/queue.c ****  * that priority.
 240:../src/FreeRTOS/queue.c ****  */
 241:../src/FreeRTOS/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVIL
 242:../src/FreeRTOS/queue.c **** #endif
 243:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 244:../src/FreeRTOS/queue.c **** 
 245:../src/FreeRTOS/queue.c **** /*
 246:../src/FreeRTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 247:../src/FreeRTOS/queue.c ****  * accessing the queue event lists.
 248:../src/FreeRTOS/queue.c ****  */
 249:../src/FreeRTOS/queue.c **** #define prvLockQueue( pxQueue )                            \
 250:../src/FreeRTOS/queue.c ****     taskENTER_CRITICAL();                                  \
 251:../src/FreeRTOS/queue.c ****     {                                                      \
 252:../src/FreeRTOS/queue.c ****         if( ( pxQueue )->cRxLock == queueUNLOCKED )        \
 253:../src/FreeRTOS/queue.c ****         {                                                  \
 254:../src/FreeRTOS/queue.c ****             ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \
 255:../src/FreeRTOS/queue.c ****         }                                                  \
 256:../src/FreeRTOS/queue.c ****         if( ( pxQueue )->cTxLock == queueUNLOCKED )        \
 257:../src/FreeRTOS/queue.c ****         {                                                  \
 258:../src/FreeRTOS/queue.c ****             ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \
 259:../src/FreeRTOS/queue.c ****         }                                                  \
 260:../src/FreeRTOS/queue.c ****     }                                                      \
 261:../src/FreeRTOS/queue.c ****     taskEXIT_CRITICAL()
 262:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 263:../src/FreeRTOS/queue.c **** 
 264:../src/FreeRTOS/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
 265:../src/FreeRTOS/queue.c ****                                BaseType_t xNewQueue )
 266:../src/FreeRTOS/queue.c **** {
 267:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 268:../src/FreeRTOS/queue.c **** 
 269:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
 270:../src/FreeRTOS/queue.c **** 
 271:../src/FreeRTOS/queue.c ****     taskENTER_CRITICAL();
 272:../src/FreeRTOS/queue.c ****     {
 273:../src/FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /
 274:../src/FreeRTOS/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 275:../src/FreeRTOS/queue.c ****         pxQueue->pcWriteTo = pxQueue->pcHead;
 276:../src/FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->ux
 277:../src/FreeRTOS/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
 278:../src/FreeRTOS/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
 279:../src/FreeRTOS/queue.c **** 
 280:../src/FreeRTOS/queue.c ****         if( xNewQueue == pdFALSE )
 281:../src/FreeRTOS/queue.c ****         {
 282:../src/FreeRTOS/queue.c ****             /* If there are tasks blocked waiting to read from the queue, then
 283:../src/FreeRTOS/queue.c ****              * the tasks will remain blocked as after this function exits the queue
 284:../src/FreeRTOS/queue.c ****              * will still be empty.  If there are tasks blocked waiting to write to
 285:../src/FreeRTOS/queue.c ****              * the queue, then one should be unblocked as after this function exits
 286:../src/FreeRTOS/queue.c ****              * it will be possible to write to it. */
 287:../src/FreeRTOS/queue.c ****             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 288:../src/FreeRTOS/queue.c ****             {
 289:../src/FreeRTOS/queue.c ****                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 290:../src/FreeRTOS/queue.c ****                 {
 291:../src/FreeRTOS/queue.c ****                     queueYIELD_IF_USING_PREEMPTION();
 292:../src/FreeRTOS/queue.c ****                 }
 293:../src/FreeRTOS/queue.c ****                 else
 294:../src/FreeRTOS/queue.c ****                 {
 295:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 296:../src/FreeRTOS/queue.c ****                 }
 297:../src/FreeRTOS/queue.c ****             }
 298:../src/FreeRTOS/queue.c ****             else
 299:../src/FreeRTOS/queue.c ****             {
 300:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 301:../src/FreeRTOS/queue.c ****             }
 302:../src/FreeRTOS/queue.c ****         }
 303:../src/FreeRTOS/queue.c ****         else
 304:../src/FreeRTOS/queue.c ****         {
 305:../src/FreeRTOS/queue.c ****             /* Ensure the event queues start in the correct state. */
 306:../src/FreeRTOS/queue.c ****             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 307:../src/FreeRTOS/queue.c ****             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 308:../src/FreeRTOS/queue.c ****         }
 309:../src/FreeRTOS/queue.c ****     }
 310:../src/FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
 311:../src/FreeRTOS/queue.c **** 
 312:../src/FreeRTOS/queue.c ****     /* A value is returned for calling semantic consistency with previous
 313:../src/FreeRTOS/queue.c ****      * versions. */
 314:../src/FreeRTOS/queue.c ****     return pdPASS;
 315:../src/FreeRTOS/queue.c **** }
 316:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 317:../src/FreeRTOS/queue.c **** 
 318:../src/FreeRTOS/queue.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 319:../src/FreeRTOS/queue.c **** 
 320:../src/FreeRTOS/queue.c ****     QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
 321:../src/FreeRTOS/queue.c ****                                              const UBaseType_t uxItemSize,
 322:../src/FreeRTOS/queue.c ****                                              uint8_t * pucQueueStorage,
 323:../src/FreeRTOS/queue.c ****                                              StaticQueue_t * pxStaticQueue,
 324:../src/FreeRTOS/queue.c ****                                              const uint8_t ucQueueType )
 325:../src/FreeRTOS/queue.c ****     {
 326:../src/FreeRTOS/queue.c ****         Queue_t * pxNewQueue;
 327:../src/FreeRTOS/queue.c **** 
 328:../src/FreeRTOS/queue.c ****         configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 329:../src/FreeRTOS/queue.c **** 
 330:../src/FreeRTOS/queue.c ****         /* The StaticQueue_t structure and the queue storage area must be
 331:../src/FreeRTOS/queue.c ****          * supplied. */
 332:../src/FreeRTOS/queue.c ****         configASSERT( pxStaticQueue != NULL );
 333:../src/FreeRTOS/queue.c **** 
 334:../src/FreeRTOS/queue.c ****         /* A queue storage area should be provided if the item size is not 0, and
 335:../src/FreeRTOS/queue.c ****          * should not be provided if the item size is 0. */
 336:../src/FreeRTOS/queue.c ****         configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 337:../src/FreeRTOS/queue.c ****         configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 338:../src/FreeRTOS/queue.c **** 
 339:../src/FreeRTOS/queue.c ****         #if ( configASSERT_DEFINED == 1 )
 340:../src/FreeRTOS/queue.c ****             {
 341:../src/FreeRTOS/queue.c ****                 /* Sanity check that the size of the structure used to declare a
 342:../src/FreeRTOS/queue.c ****                  * variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 343:../src/FreeRTOS/queue.c ****                  * the real queue and semaphore structures. */
 344:../src/FreeRTOS/queue.c ****                 volatile size_t xSize = sizeof( StaticQueue_t );
 345:../src/FreeRTOS/queue.c ****                 configASSERT( xSize == sizeof( Queue_t ) );
 346:../src/FreeRTOS/queue.c ****                 ( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 347:../src/FreeRTOS/queue.c ****             }
 348:../src/FreeRTOS/queue.c ****         #endif /* configASSERT_DEFINED */
 349:../src/FreeRTOS/queue.c **** 
 350:../src/FreeRTOS/queue.c ****         /* The address of a statically allocated queue was passed in, use it.
 351:../src/FreeRTOS/queue.c ****          * The address of a statically allocated storage area was also passed in
 352:../src/FreeRTOS/queue.c ****          * but is already set. */
 353:../src/FreeRTOS/queue.c ****         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the str
 354:../src/FreeRTOS/queue.c **** 
 355:../src/FreeRTOS/queue.c ****         if( pxNewQueue != NULL )
 356:../src/FreeRTOS/queue.c ****         {
 357:../src/FreeRTOS/queue.c ****             #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 358:../src/FreeRTOS/queue.c ****                 {
 359:../src/FreeRTOS/queue.c ****                     /* Queues can be allocated wither statically or dynamically, so
 360:../src/FreeRTOS/queue.c ****                      * note this queue was allocated statically in case the queue is
 361:../src/FreeRTOS/queue.c ****                      * later deleted. */
 362:../src/FreeRTOS/queue.c ****                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
 363:../src/FreeRTOS/queue.c ****                 }
 364:../src/FreeRTOS/queue.c ****             #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 365:../src/FreeRTOS/queue.c **** 
 366:../src/FreeRTOS/queue.c ****             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQu
 367:../src/FreeRTOS/queue.c ****         }
 368:../src/FreeRTOS/queue.c ****         else
 369:../src/FreeRTOS/queue.c ****         {
 370:../src/FreeRTOS/queue.c ****             traceQUEUE_CREATE_FAILED( ucQueueType );
 371:../src/FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 372:../src/FreeRTOS/queue.c ****         }
 373:../src/FreeRTOS/queue.c **** 
 374:../src/FreeRTOS/queue.c ****         return pxNewQueue;
 375:../src/FreeRTOS/queue.c ****     }
 376:../src/FreeRTOS/queue.c **** 
 377:../src/FreeRTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 378:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 379:../src/FreeRTOS/queue.c **** 
 380:../src/FreeRTOS/queue.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 381:../src/FreeRTOS/queue.c **** 
 382:../src/FreeRTOS/queue.c ****     QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
 383:../src/FreeRTOS/queue.c ****                                        const UBaseType_t uxItemSize,
 384:../src/FreeRTOS/queue.c ****                                        const uint8_t ucQueueType )
 385:../src/FreeRTOS/queue.c ****     {
 386:../src/FreeRTOS/queue.c ****         Queue_t * pxNewQueue;
 387:../src/FreeRTOS/queue.c ****         size_t xQueueSizeInBytes;
 388:../src/FreeRTOS/queue.c ****         uint8_t * pucQueueStorage;
 389:../src/FreeRTOS/queue.c **** 
 390:../src/FreeRTOS/queue.c ****         configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 391:../src/FreeRTOS/queue.c **** 
 392:../src/FreeRTOS/queue.c ****         /* Allocate enough space to hold the maximum number of items that
 393:../src/FreeRTOS/queue.c ****          * can be in the queue at any time.  It is valid for uxItemSize to be
 394:../src/FreeRTOS/queue.c ****          * zero in the case the queue is used as a semaphore. */
 395:../src/FreeRTOS/queue.c ****         xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception
 396:../src/FreeRTOS/queue.c **** 
 397:../src/FreeRTOS/queue.c ****         /* Check for multiplication overflow. */
 398:../src/FreeRTOS/queue.c ****         configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) 
 399:../src/FreeRTOS/queue.c **** 
 400:../src/FreeRTOS/queue.c ****         /* Check for addition overflow. */
 401:../src/FreeRTOS/queue.c ****         configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
 402:../src/FreeRTOS/queue.c **** 
 403:../src/FreeRTOS/queue.c ****         /* Allocate the queue and storage area.  Justification for MISRA
 404:../src/FreeRTOS/queue.c ****          * deviation as follows:  pvPortMalloc() always ensures returned memory
 405:../src/FreeRTOS/queue.c ****          * blocks are aligned per the requirements of the MCU stack.  In this case
 406:../src/FreeRTOS/queue.c ****          * pvPortMalloc() must return a pointer that is guaranteed to meet the
 407:../src/FreeRTOS/queue.c ****          * alignment requirements of the Queue_t structure - which in this case
 408:../src/FreeRTOS/queue.c ****          * is an int8_t *.  Therefore, whenever the stack alignment requirements
 409:../src/FreeRTOS/queue.c ****          * are greater than or equal to the pointer to char requirements the cast
 410:../src/FreeRTOS/queue.c ****          * is safe.  In other cases alignment requirements are not strict (one or
 411:../src/FreeRTOS/queue.c ****          * two bytes). */
 412:../src/FreeRTOS/queue.c ****         pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e
 413:../src/FreeRTOS/queue.c **** 
 414:../src/FreeRTOS/queue.c ****         if( pxNewQueue != NULL )
 415:../src/FreeRTOS/queue.c ****         {
 416:../src/FreeRTOS/queue.c ****             /* Jump past the queue structure to find the location of the queue
 417:../src/FreeRTOS/queue.c ****              * storage area. */
 418:../src/FreeRTOS/queue.c ****             pucQueueStorage = ( uint8_t * ) pxNewQueue;
 419:../src/FreeRTOS/queue.c ****             pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char 
 420:../src/FreeRTOS/queue.c **** 
 421:../src/FreeRTOS/queue.c ****             #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 422:../src/FreeRTOS/queue.c ****                 {
 423:../src/FreeRTOS/queue.c ****                     /* Queues can be created either statically or dynamically, so
 424:../src/FreeRTOS/queue.c ****                      * note this task was created dynamically in case it is later
 425:../src/FreeRTOS/queue.c ****                      * deleted. */
 426:../src/FreeRTOS/queue.c ****                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
 427:../src/FreeRTOS/queue.c ****                 }
 428:../src/FreeRTOS/queue.c ****             #endif /* configSUPPORT_STATIC_ALLOCATION */
 429:../src/FreeRTOS/queue.c **** 
 430:../src/FreeRTOS/queue.c ****             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQu
 431:../src/FreeRTOS/queue.c ****         }
 432:../src/FreeRTOS/queue.c ****         else
 433:../src/FreeRTOS/queue.c ****         {
 434:../src/FreeRTOS/queue.c ****             traceQUEUE_CREATE_FAILED( ucQueueType );
 435:../src/FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 436:../src/FreeRTOS/queue.c ****         }
 437:../src/FreeRTOS/queue.c **** 
 438:../src/FreeRTOS/queue.c ****         return pxNewQueue;
 439:../src/FreeRTOS/queue.c ****     }
 440:../src/FreeRTOS/queue.c **** 
 441:../src/FreeRTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 442:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 443:../src/FreeRTOS/queue.c **** 
 444:../src/FreeRTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 445:../src/FreeRTOS/queue.c ****                                    const UBaseType_t uxItemSize,
 446:../src/FreeRTOS/queue.c ****                                    uint8_t * pucQueueStorage,
 447:../src/FreeRTOS/queue.c ****                                    const uint8_t ucQueueType,
 448:../src/FreeRTOS/queue.c ****                                    Queue_t * pxNewQueue )
 449:../src/FreeRTOS/queue.c **** {
 450:../src/FreeRTOS/queue.c ****     /* Remove compiler warnings about unused parameters should
 451:../src/FreeRTOS/queue.c ****      * configUSE_TRACE_FACILITY not be set to 1. */
 452:../src/FreeRTOS/queue.c ****     ( void ) ucQueueType;
 453:../src/FreeRTOS/queue.c **** 
 454:../src/FreeRTOS/queue.c ****     if( uxItemSize == ( UBaseType_t ) 0 )
 455:../src/FreeRTOS/queue.c ****     {
 456:../src/FreeRTOS/queue.c ****         /* No RAM was allocated for the queue storage area, but PC head cannot
 457:../src/FreeRTOS/queue.c ****          * be set to NULL because NULL is used as a key to say the queue is used as
 458:../src/FreeRTOS/queue.c ****          * a mutex.  Therefore just set pcHead to point to the queue as a benign
 459:../src/FreeRTOS/queue.c ****          * value that is known to be within the memory map. */
 460:../src/FreeRTOS/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 461:../src/FreeRTOS/queue.c ****     }
 462:../src/FreeRTOS/queue.c ****     else
 463:../src/FreeRTOS/queue.c ****     {
 464:../src/FreeRTOS/queue.c ****         /* Set the head to the start of the queue storage area. */
 465:../src/FreeRTOS/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 466:../src/FreeRTOS/queue.c ****     }
 467:../src/FreeRTOS/queue.c **** 
 468:../src/FreeRTOS/queue.c ****     /* Initialise the queue members as described where the queue type is
 469:../src/FreeRTOS/queue.c ****      * defined. */
 470:../src/FreeRTOS/queue.c ****     pxNewQueue->uxLength = uxQueueLength;
 471:../src/FreeRTOS/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 472:../src/FreeRTOS/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 473:../src/FreeRTOS/queue.c **** 
 474:../src/FreeRTOS/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 475:../src/FreeRTOS/queue.c ****         {
 476:../src/FreeRTOS/queue.c ****             pxNewQueue->ucQueueType = ucQueueType;
 477:../src/FreeRTOS/queue.c ****         }
 478:../src/FreeRTOS/queue.c ****     #endif /* configUSE_TRACE_FACILITY */
 479:../src/FreeRTOS/queue.c **** 
 480:../src/FreeRTOS/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 481:../src/FreeRTOS/queue.c ****         {
 482:../src/FreeRTOS/queue.c ****             pxNewQueue->pxQueueSetContainer = NULL;
 483:../src/FreeRTOS/queue.c ****         }
 484:../src/FreeRTOS/queue.c ****     #endif /* configUSE_QUEUE_SETS */
 485:../src/FreeRTOS/queue.c **** 
 486:../src/FreeRTOS/queue.c ****     traceQUEUE_CREATE( pxNewQueue );
 487:../src/FreeRTOS/queue.c **** }
 488:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 489:../src/FreeRTOS/queue.c **** 
 490:../src/FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 491:../src/FreeRTOS/queue.c **** 
 492:../src/FreeRTOS/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue )
 493:../src/FreeRTOS/queue.c ****     {
 494:../src/FreeRTOS/queue.c ****         if( pxNewQueue != NULL )
 495:../src/FreeRTOS/queue.c ****         {
 496:../src/FreeRTOS/queue.c ****             /* The queue create function will set all the queue structure members
 497:../src/FreeRTOS/queue.c ****             * correctly for a generic queue, but this function is creating a
 498:../src/FreeRTOS/queue.c ****             * mutex.  Overwrite those members that need to be set differently -
 499:../src/FreeRTOS/queue.c ****             * in particular the information required for priority inheritance. */
 500:../src/FreeRTOS/queue.c ****             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 501:../src/FreeRTOS/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 502:../src/FreeRTOS/queue.c **** 
 503:../src/FreeRTOS/queue.c ****             /* In case this is a recursive mutex. */
 504:../src/FreeRTOS/queue.c ****             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 505:../src/FreeRTOS/queue.c **** 
 506:../src/FreeRTOS/queue.c ****             traceCREATE_MUTEX( pxNewQueue );
 507:../src/FreeRTOS/queue.c **** 
 508:../src/FreeRTOS/queue.c ****             /* Start with the semaphore in the expected state. */
 509:../src/FreeRTOS/queue.c ****             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 510:../src/FreeRTOS/queue.c ****         }
 511:../src/FreeRTOS/queue.c ****         else
 512:../src/FreeRTOS/queue.c ****         {
 513:../src/FreeRTOS/queue.c ****             traceCREATE_MUTEX_FAILED();
 514:../src/FreeRTOS/queue.c ****         }
 515:../src/FreeRTOS/queue.c ****     }
 516:../src/FreeRTOS/queue.c **** 
 517:../src/FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 518:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 519:../src/FreeRTOS/queue.c **** 
 520:../src/FreeRTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 521:../src/FreeRTOS/queue.c **** 
 522:../src/FreeRTOS/queue.c ****     QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 523:../src/FreeRTOS/queue.c ****     {
 524:../src/FreeRTOS/queue.c ****         QueueHandle_t xNewQueue;
 525:../src/FreeRTOS/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 526:../src/FreeRTOS/queue.c **** 
 527:../src/FreeRTOS/queue.c ****         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 528:../src/FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 529:../src/FreeRTOS/queue.c **** 
 530:../src/FreeRTOS/queue.c ****         return xNewQueue;
 531:../src/FreeRTOS/queue.c ****     }
 532:../src/FreeRTOS/queue.c **** 
 533:../src/FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 534:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 535:../src/FreeRTOS/queue.c **** 
 536:../src/FreeRTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 537:../src/FreeRTOS/queue.c **** 
 538:../src/FreeRTOS/queue.c ****     QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
 539:../src/FreeRTOS/queue.c ****                                            StaticQueue_t * pxStaticQueue )
 540:../src/FreeRTOS/queue.c ****     {
 541:../src/FreeRTOS/queue.c ****         QueueHandle_t xNewQueue;
 542:../src/FreeRTOS/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 543:../src/FreeRTOS/queue.c **** 
 544:../src/FreeRTOS/queue.c ****         /* Prevent compiler warnings about unused parameters if
 545:../src/FreeRTOS/queue.c ****          * configUSE_TRACE_FACILITY does not equal 1. */
 546:../src/FreeRTOS/queue.c ****         ( void ) ucQueueType;
 547:../src/FreeRTOS/queue.c **** 
 548:../src/FreeRTOS/queue.c ****         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQ
 549:../src/FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 550:../src/FreeRTOS/queue.c **** 
 551:../src/FreeRTOS/queue.c ****         return xNewQueue;
 552:../src/FreeRTOS/queue.c ****     }
 553:../src/FreeRTOS/queue.c **** 
 554:../src/FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 555:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 556:../src/FreeRTOS/queue.c **** 
 557:../src/FreeRTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 558:../src/FreeRTOS/queue.c **** 
 559:../src/FreeRTOS/queue.c ****     TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 560:../src/FreeRTOS/queue.c ****     {
 561:../src/FreeRTOS/queue.c ****         TaskHandle_t pxReturn;
 562:../src/FreeRTOS/queue.c ****         Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 563:../src/FreeRTOS/queue.c **** 
 564:../src/FreeRTOS/queue.c ****         /* This function is called by xSemaphoreGetMutexHolder(), and should not
 565:../src/FreeRTOS/queue.c ****          * be called directly.  Note:  This is a good way of determining if the
 566:../src/FreeRTOS/queue.c ****          * calling task is the mutex holder, but not a good way of determining the
 567:../src/FreeRTOS/queue.c ****          * identity of the mutex holder, as the holder may change between the
 568:../src/FreeRTOS/queue.c ****          * following critical section exiting and the function returning. */
 569:../src/FreeRTOS/queue.c ****         taskENTER_CRITICAL();
 570:../src/FreeRTOS/queue.c ****         {
 571:../src/FreeRTOS/queue.c ****             if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 572:../src/FreeRTOS/queue.c ****             {
 573:../src/FreeRTOS/queue.c ****                 pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 574:../src/FreeRTOS/queue.c ****             }
 575:../src/FreeRTOS/queue.c ****             else
 576:../src/FreeRTOS/queue.c ****             {
 577:../src/FreeRTOS/queue.c ****                 pxReturn = NULL;
 578:../src/FreeRTOS/queue.c ****             }
 579:../src/FreeRTOS/queue.c ****         }
 580:../src/FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
 581:../src/FreeRTOS/queue.c **** 
 582:../src/FreeRTOS/queue.c ****         return pxReturn;
 583:../src/FreeRTOS/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 584:../src/FreeRTOS/queue.c **** 
 585:../src/FreeRTOS/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 586:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 587:../src/FreeRTOS/queue.c **** 
 588:../src/FreeRTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 589:../src/FreeRTOS/queue.c **** 
 590:../src/FreeRTOS/queue.c ****     TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 591:../src/FreeRTOS/queue.c ****     {
 592:../src/FreeRTOS/queue.c ****         TaskHandle_t pxReturn;
 593:../src/FreeRTOS/queue.c **** 
 594:../src/FreeRTOS/queue.c ****         configASSERT( xSemaphore );
 595:../src/FreeRTOS/queue.c **** 
 596:../src/FreeRTOS/queue.c ****         /* Mutexes cannot be used in interrupt service routines, so the mutex
 597:../src/FreeRTOS/queue.c ****          * holder should not change in an ISR, and therefore a critical section is
 598:../src/FreeRTOS/queue.c ****          * not required here. */
 599:../src/FreeRTOS/queue.c ****         if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 600:../src/FreeRTOS/queue.c ****         {
 601:../src/FreeRTOS/queue.c ****             pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 602:../src/FreeRTOS/queue.c ****         }
 603:../src/FreeRTOS/queue.c ****         else
 604:../src/FreeRTOS/queue.c ****         {
 605:../src/FreeRTOS/queue.c ****             pxReturn = NULL;
 606:../src/FreeRTOS/queue.c ****         }
 607:../src/FreeRTOS/queue.c **** 
 608:../src/FreeRTOS/queue.c ****         return pxReturn;
 609:../src/FreeRTOS/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 610:../src/FreeRTOS/queue.c **** 
 611:../src/FreeRTOS/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 612:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 613:../src/FreeRTOS/queue.c **** 
 614:../src/FreeRTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 615:../src/FreeRTOS/queue.c **** 
 616:../src/FreeRTOS/queue.c ****     BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 617:../src/FreeRTOS/queue.c ****     {
 618:../src/FreeRTOS/queue.c ****         BaseType_t xReturn;
 619:../src/FreeRTOS/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 620:../src/FreeRTOS/queue.c **** 
 621:../src/FreeRTOS/queue.c ****         configASSERT( pxMutex );
 622:../src/FreeRTOS/queue.c **** 
 623:../src/FreeRTOS/queue.c ****         /* If this is the task that holds the mutex then xMutexHolder will not
 624:../src/FreeRTOS/queue.c ****          * change outside of this task.  If this task does not hold the mutex then
 625:../src/FreeRTOS/queue.c ****          * pxMutexHolder can never coincidentally equal the tasks handle, and as
 626:../src/FreeRTOS/queue.c ****          * this is the only condition we are interested in it does not matter if
 627:../src/FreeRTOS/queue.c ****          * pxMutexHolder is accessed simultaneously by another task.  Therefore no
 628:../src/FreeRTOS/queue.c ****          * mutual exclusion is required to test the pxMutexHolder variable. */
 629:../src/FreeRTOS/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 630:../src/FreeRTOS/queue.c ****         {
 631:../src/FreeRTOS/queue.c ****             traceGIVE_MUTEX_RECURSIVE( pxMutex );
 632:../src/FreeRTOS/queue.c **** 
 633:../src/FreeRTOS/queue.c ****             /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 634:../src/FreeRTOS/queue.c ****              * the task handle, therefore no underflow check is required.  Also,
 635:../src/FreeRTOS/queue.c ****              * uxRecursiveCallCount is only modified by the mutex holder, and as
 636:../src/FreeRTOS/queue.c ****              * there can only be one, no mutual exclusion is required to modify the
 637:../src/FreeRTOS/queue.c ****              * uxRecursiveCallCount member. */
 638:../src/FreeRTOS/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 639:../src/FreeRTOS/queue.c **** 
 640:../src/FreeRTOS/queue.c ****             /* Has the recursive call count unwound to 0? */
 641:../src/FreeRTOS/queue.c ****             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 642:../src/FreeRTOS/queue.c ****             {
 643:../src/FreeRTOS/queue.c ****                 /* Return the mutex.  This will automatically unblock any other
 644:../src/FreeRTOS/queue.c ****                  * task that might be waiting to access the mutex. */
 645:../src/FreeRTOS/queue.c ****                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO
 646:../src/FreeRTOS/queue.c ****             }
 647:../src/FreeRTOS/queue.c ****             else
 648:../src/FreeRTOS/queue.c ****             {
 649:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 650:../src/FreeRTOS/queue.c ****             }
 651:../src/FreeRTOS/queue.c **** 
 652:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
 653:../src/FreeRTOS/queue.c ****         }
 654:../src/FreeRTOS/queue.c ****         else
 655:../src/FreeRTOS/queue.c ****         {
 656:../src/FreeRTOS/queue.c ****             /* The mutex cannot be given because the calling task is not the
 657:../src/FreeRTOS/queue.c ****              * holder. */
 658:../src/FreeRTOS/queue.c ****             xReturn = pdFAIL;
 659:../src/FreeRTOS/queue.c **** 
 660:../src/FreeRTOS/queue.c ****             traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 661:../src/FreeRTOS/queue.c ****         }
 662:../src/FreeRTOS/queue.c **** 
 663:../src/FreeRTOS/queue.c ****         return xReturn;
 664:../src/FreeRTOS/queue.c ****     }
 665:../src/FreeRTOS/queue.c **** 
 666:../src/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 667:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 668:../src/FreeRTOS/queue.c **** 
 669:../src/FreeRTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 670:../src/FreeRTOS/queue.c **** 
 671:../src/FreeRTOS/queue.c ****     BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
 672:../src/FreeRTOS/queue.c ****                                          TickType_t xTicksToWait )
 673:../src/FreeRTOS/queue.c ****     {
 674:../src/FreeRTOS/queue.c ****         BaseType_t xReturn;
 675:../src/FreeRTOS/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 676:../src/FreeRTOS/queue.c **** 
 677:../src/FreeRTOS/queue.c ****         configASSERT( pxMutex );
 678:../src/FreeRTOS/queue.c **** 
 679:../src/FreeRTOS/queue.c ****         /* Comments regarding mutual exclusion as per those within
 680:../src/FreeRTOS/queue.c ****          * xQueueGiveMutexRecursive(). */
 681:../src/FreeRTOS/queue.c **** 
 682:../src/FreeRTOS/queue.c ****         traceTAKE_MUTEX_RECURSIVE( pxMutex );
 683:../src/FreeRTOS/queue.c **** 
 684:../src/FreeRTOS/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 685:../src/FreeRTOS/queue.c ****         {
 686:../src/FreeRTOS/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 687:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
 688:../src/FreeRTOS/queue.c ****         }
 689:../src/FreeRTOS/queue.c ****         else
 690:../src/FreeRTOS/queue.c ****         {
 691:../src/FreeRTOS/queue.c ****             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 692:../src/FreeRTOS/queue.c **** 
 693:../src/FreeRTOS/queue.c ****             /* pdPASS will only be returned if the mutex was successfully
 694:../src/FreeRTOS/queue.c ****              * obtained.  The calling task may have entered the Blocked state
 695:../src/FreeRTOS/queue.c ****              * before reaching here. */
 696:../src/FreeRTOS/queue.c ****             if( xReturn != pdFAIL )
 697:../src/FreeRTOS/queue.c ****             {
 698:../src/FreeRTOS/queue.c ****                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 699:../src/FreeRTOS/queue.c ****             }
 700:../src/FreeRTOS/queue.c ****             else
 701:../src/FreeRTOS/queue.c ****             {
 702:../src/FreeRTOS/queue.c ****                 traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 703:../src/FreeRTOS/queue.c ****             }
 704:../src/FreeRTOS/queue.c ****         }
 705:../src/FreeRTOS/queue.c **** 
 706:../src/FreeRTOS/queue.c ****         return xReturn;
 707:../src/FreeRTOS/queue.c ****     }
 708:../src/FreeRTOS/queue.c **** 
 709:../src/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 710:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 711:../src/FreeRTOS/queue.c **** 
 712:../src/FreeRTOS/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 713:../src/FreeRTOS/queue.c **** 
 714:../src/FreeRTOS/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
 715:../src/FreeRTOS/queue.c ****                                                        const UBaseType_t uxInitialCount,
 716:../src/FreeRTOS/queue.c ****                                                        StaticQueue_t * pxStaticQueue )
 717:../src/FreeRTOS/queue.c ****     {
 718:../src/FreeRTOS/queue.c ****         QueueHandle_t xHandle;
 719:../src/FreeRTOS/queue.c **** 
 720:../src/FreeRTOS/queue.c ****         configASSERT( uxMaxCount != 0 );
 721:../src/FreeRTOS/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 722:../src/FreeRTOS/queue.c **** 
 723:../src/FreeRTOS/queue.c ****         xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, px
 724:../src/FreeRTOS/queue.c **** 
 725:../src/FreeRTOS/queue.c ****         if( xHandle != NULL )
 726:../src/FreeRTOS/queue.c ****         {
 727:../src/FreeRTOS/queue.c ****             ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 728:../src/FreeRTOS/queue.c **** 
 729:../src/FreeRTOS/queue.c ****             traceCREATE_COUNTING_SEMAPHORE();
 730:../src/FreeRTOS/queue.c ****         }
 731:../src/FreeRTOS/queue.c ****         else
 732:../src/FreeRTOS/queue.c ****         {
 733:../src/FreeRTOS/queue.c ****             traceCREATE_COUNTING_SEMAPHORE_FAILED();
 734:../src/FreeRTOS/queue.c ****         }
 735:../src/FreeRTOS/queue.c **** 
 736:../src/FreeRTOS/queue.c ****         return xHandle;
 737:../src/FreeRTOS/queue.c ****     }
 738:../src/FreeRTOS/queue.c **** 
 739:../src/FreeRTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 740:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 741:../src/FreeRTOS/queue.c **** 
 742:../src/FreeRTOS/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 743:../src/FreeRTOS/queue.c **** 
 744:../src/FreeRTOS/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
 745:../src/FreeRTOS/queue.c ****                                                  const UBaseType_t uxInitialCount )
 746:../src/FreeRTOS/queue.c ****     {
 747:../src/FreeRTOS/queue.c ****         QueueHandle_t xHandle;
 748:../src/FreeRTOS/queue.c **** 
 749:../src/FreeRTOS/queue.c ****         configASSERT( uxMaxCount != 0 );
 750:../src/FreeRTOS/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 751:../src/FreeRTOS/queue.c **** 
 752:../src/FreeRTOS/queue.c ****         xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYP
 753:../src/FreeRTOS/queue.c **** 
 754:../src/FreeRTOS/queue.c ****         if( xHandle != NULL )
 755:../src/FreeRTOS/queue.c ****         {
 756:../src/FreeRTOS/queue.c ****             ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 757:../src/FreeRTOS/queue.c **** 
 758:../src/FreeRTOS/queue.c ****             traceCREATE_COUNTING_SEMAPHORE();
 759:../src/FreeRTOS/queue.c ****         }
 760:../src/FreeRTOS/queue.c ****         else
 761:../src/FreeRTOS/queue.c ****         {
 762:../src/FreeRTOS/queue.c ****             traceCREATE_COUNTING_SEMAPHORE_FAILED();
 763:../src/FreeRTOS/queue.c ****         }
 764:../src/FreeRTOS/queue.c **** 
 765:../src/FreeRTOS/queue.c ****         return xHandle;
 766:../src/FreeRTOS/queue.c ****     }
 767:../src/FreeRTOS/queue.c **** 
 768:../src/FreeRTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 769:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 770:../src/FreeRTOS/queue.c **** 
 771:../src/FreeRTOS/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
 772:../src/FreeRTOS/queue.c ****                               const void * const pvItemToQueue,
 773:../src/FreeRTOS/queue.c ****                               TickType_t xTicksToWait,
 774:../src/FreeRTOS/queue.c ****                               const BaseType_t xCopyPosition )
 775:../src/FreeRTOS/queue.c **** {
 776:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 777:../src/FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 778:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 779:../src/FreeRTOS/queue.c **** 
 780:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
 781:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 782:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 783:../src/FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 784:../src/FreeRTOS/queue.c ****         {
 785:../src/FreeRTOS/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
 786:../src/FreeRTOS/queue.c ****         }
 787:../src/FreeRTOS/queue.c ****     #endif
 788:../src/FreeRTOS/queue.c **** 
 789:../src/FreeRTOS/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to
 790:../src/FreeRTOS/queue.c ****      * allow return statements within the function itself.  This is done in the
 791:../src/FreeRTOS/queue.c ****      * interest of execution time efficiency. */
 792:../src/FreeRTOS/queue.c ****     for( ; ; )
 793:../src/FreeRTOS/queue.c ****     {
 794:../src/FreeRTOS/queue.c ****         taskENTER_CRITICAL();
 795:../src/FreeRTOS/queue.c ****         {
 796:../src/FreeRTOS/queue.c ****             /* Is there room on the queue now?  The running task must be the
 797:../src/FreeRTOS/queue.c ****              * highest priority task wanting to access the queue.  If the head item
 798:../src/FreeRTOS/queue.c ****              * in the queue is to be overwritten then it does not matter if the
 799:../src/FreeRTOS/queue.c ****              * queue is full. */
 800:../src/FreeRTOS/queue.c ****             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERW
 801:../src/FreeRTOS/queue.c ****             {
 802:../src/FreeRTOS/queue.c ****                 traceQUEUE_SEND( pxQueue );
 803:../src/FreeRTOS/queue.c **** 
 804:../src/FreeRTOS/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
 805:../src/FreeRTOS/queue.c ****                     {
 806:../src/FreeRTOS/queue.c ****                         const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 807:../src/FreeRTOS/queue.c **** 
 808:../src/FreeRTOS/queue.c ****                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition 
 809:../src/FreeRTOS/queue.c **** 
 810:../src/FreeRTOS/queue.c ****                         if( pxQueue->pxQueueSetContainer != NULL )
 811:../src/FreeRTOS/queue.c ****                         {
 812:../src/FreeRTOS/queue.c ****                             if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting 
 813:../src/FreeRTOS/queue.c ****                             {
 814:../src/FreeRTOS/queue.c ****                                 /* Do not notify the queue set as an existing item
 815:../src/FreeRTOS/queue.c ****                                  * was overwritten in the queue so the number of items
 816:../src/FreeRTOS/queue.c ****                                  * in the queue has not changed. */
 817:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 818:../src/FreeRTOS/queue.c ****                             }
 819:../src/FreeRTOS/queue.c ****                             else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 820:../src/FreeRTOS/queue.c ****                             {
 821:../src/FreeRTOS/queue.c ****                                 /* The queue is a member of a queue set, and posting
 822:../src/FreeRTOS/queue.c ****                                  * to the queue set caused a higher priority task to
 823:../src/FreeRTOS/queue.c ****                                  * unblock. A context switch is required. */
 824:../src/FreeRTOS/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 825:../src/FreeRTOS/queue.c ****                             }
 826:../src/FreeRTOS/queue.c ****                             else
 827:../src/FreeRTOS/queue.c ****                             {
 828:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 829:../src/FreeRTOS/queue.c ****                             }
 830:../src/FreeRTOS/queue.c ****                         }
 831:../src/FreeRTOS/queue.c ****                         else
 832:../src/FreeRTOS/queue.c ****                         {
 833:../src/FreeRTOS/queue.c ****                             /* If there was a task waiting for data to arrive on the
 834:../src/FreeRTOS/queue.c ****                              * queue then unblock it now. */
 835:../src/FreeRTOS/queue.c ****                             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALS
 836:../src/FreeRTOS/queue.c ****                             {
 837:../src/FreeRTOS/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) 
 838:../src/FreeRTOS/queue.c ****                                 {
 839:../src/FreeRTOS/queue.c ****                                     /* The unblocked task has a priority higher than
 840:../src/FreeRTOS/queue.c ****                                      * our own so yield immediately.  Yes it is ok to
 841:../src/FreeRTOS/queue.c ****                                      * do this from within the critical section - the
 842:../src/FreeRTOS/queue.c ****                                      * kernel takes care of that. */
 843:../src/FreeRTOS/queue.c ****                                     queueYIELD_IF_USING_PREEMPTION();
 844:../src/FreeRTOS/queue.c ****                                 }
 845:../src/FreeRTOS/queue.c ****                                 else
 846:../src/FreeRTOS/queue.c ****                                 {
 847:../src/FreeRTOS/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
 848:../src/FreeRTOS/queue.c ****                                 }
 849:../src/FreeRTOS/queue.c ****                             }
 850:../src/FreeRTOS/queue.c ****                             else if( xYieldRequired != pdFALSE )
 851:../src/FreeRTOS/queue.c ****                             {
 852:../src/FreeRTOS/queue.c ****                                 /* This path is a special case that will only get
 853:../src/FreeRTOS/queue.c ****                                  * executed if the task was holding multiple mutexes
 854:../src/FreeRTOS/queue.c ****                                  * and the mutexes were given back in an order that is
 855:../src/FreeRTOS/queue.c ****                                  * different to that in which they were taken. */
 856:../src/FreeRTOS/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 857:../src/FreeRTOS/queue.c ****                             }
 858:../src/FreeRTOS/queue.c ****                             else
 859:../src/FreeRTOS/queue.c ****                             {
 860:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 861:../src/FreeRTOS/queue.c ****                             }
 862:../src/FreeRTOS/queue.c ****                         }
 863:../src/FreeRTOS/queue.c ****                     }
 864:../src/FreeRTOS/queue.c ****                 #else /* configUSE_QUEUE_SETS */
 865:../src/FreeRTOS/queue.c ****                     {
 866:../src/FreeRTOS/queue.c ****                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition 
 867:../src/FreeRTOS/queue.c **** 
 868:../src/FreeRTOS/queue.c ****                         /* If there was a task waiting for data to arrive on the
 869:../src/FreeRTOS/queue.c ****                          * queue then unblock it now. */
 870:../src/FreeRTOS/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 871:../src/FreeRTOS/queue.c ****                         {
 872:../src/FreeRTOS/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
 873:../src/FreeRTOS/queue.c ****                             {
 874:../src/FreeRTOS/queue.c ****                                 /* The unblocked task has a priority higher than
 875:../src/FreeRTOS/queue.c ****                                  * our own so yield immediately.  Yes it is ok to do
 876:../src/FreeRTOS/queue.c ****                                  * this from within the critical section - the kernel
 877:../src/FreeRTOS/queue.c ****                                  * takes care of that. */
 878:../src/FreeRTOS/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 879:../src/FreeRTOS/queue.c ****                             }
 880:../src/FreeRTOS/queue.c ****                             else
 881:../src/FreeRTOS/queue.c ****                             {
 882:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 883:../src/FreeRTOS/queue.c ****                             }
 884:../src/FreeRTOS/queue.c ****                         }
 885:../src/FreeRTOS/queue.c ****                         else if( xYieldRequired != pdFALSE )
 886:../src/FreeRTOS/queue.c ****                         {
 887:../src/FreeRTOS/queue.c ****                             /* This path is a special case that will only get
 888:../src/FreeRTOS/queue.c ****                              * executed if the task was holding multiple mutexes and
 889:../src/FreeRTOS/queue.c ****                              * the mutexes were given back in an order that is
 890:../src/FreeRTOS/queue.c ****                              * different to that in which they were taken. */
 891:../src/FreeRTOS/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 892:../src/FreeRTOS/queue.c ****                         }
 893:../src/FreeRTOS/queue.c ****                         else
 894:../src/FreeRTOS/queue.c ****                         {
 895:../src/FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 896:../src/FreeRTOS/queue.c ****                         }
 897:../src/FreeRTOS/queue.c ****                     }
 898:../src/FreeRTOS/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
 899:../src/FreeRTOS/queue.c **** 
 900:../src/FreeRTOS/queue.c ****                 taskEXIT_CRITICAL();
 901:../src/FreeRTOS/queue.c ****                 return pdPASS;
 902:../src/FreeRTOS/queue.c ****             }
 903:../src/FreeRTOS/queue.c ****             else
 904:../src/FreeRTOS/queue.c ****             {
 905:../src/FreeRTOS/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 906:../src/FreeRTOS/queue.c ****                 {
 907:../src/FreeRTOS/queue.c ****                     /* The queue was full and no block time is specified (or
 908:../src/FreeRTOS/queue.c ****                      * the block time has expired) so leave now. */
 909:../src/FreeRTOS/queue.c ****                     taskEXIT_CRITICAL();
 910:../src/FreeRTOS/queue.c **** 
 911:../src/FreeRTOS/queue.c ****                     /* Return to the original privilege level before exiting
 912:../src/FreeRTOS/queue.c ****                      * the function. */
 913:../src/FreeRTOS/queue.c ****                     traceQUEUE_SEND_FAILED( pxQueue );
 914:../src/FreeRTOS/queue.c ****                     return errQUEUE_FULL;
 915:../src/FreeRTOS/queue.c ****                 }
 916:../src/FreeRTOS/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 917:../src/FreeRTOS/queue.c ****                 {
 918:../src/FreeRTOS/queue.c ****                     /* The queue was full and a block time was specified so
 919:../src/FreeRTOS/queue.c ****                      * configure the timeout structure. */
 920:../src/FreeRTOS/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 921:../src/FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 922:../src/FreeRTOS/queue.c ****                 }
 923:../src/FreeRTOS/queue.c ****                 else
 924:../src/FreeRTOS/queue.c ****                 {
 925:../src/FreeRTOS/queue.c ****                     /* Entry time was already set. */
 926:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 927:../src/FreeRTOS/queue.c ****                 }
 928:../src/FreeRTOS/queue.c ****             }
 929:../src/FreeRTOS/queue.c ****         }
 930:../src/FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
 931:../src/FreeRTOS/queue.c **** 
 932:../src/FreeRTOS/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
 933:../src/FreeRTOS/queue.c ****          * now the critical section has been exited. */
 934:../src/FreeRTOS/queue.c **** 
 935:../src/FreeRTOS/queue.c ****         vTaskSuspendAll();
 936:../src/FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 937:../src/FreeRTOS/queue.c **** 
 938:../src/FreeRTOS/queue.c ****         /* Update the timeout state to see if it has expired yet. */
 939:../src/FreeRTOS/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 940:../src/FreeRTOS/queue.c ****         {
 941:../src/FreeRTOS/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
 942:../src/FreeRTOS/queue.c ****             {
 943:../src/FreeRTOS/queue.c ****                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 944:../src/FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 945:../src/FreeRTOS/queue.c **** 
 946:../src/FreeRTOS/queue.c ****                 /* Unlocking the queue means queue events can effect the
 947:../src/FreeRTOS/queue.c ****                  * event list.  It is possible that interrupts occurring now
 948:../src/FreeRTOS/queue.c ****                  * remove this task from the event list again - but as the
 949:../src/FreeRTOS/queue.c ****                  * scheduler is suspended the task will go onto the pending
 950:../src/FreeRTOS/queue.c ****                  * ready last instead of the actual ready list. */
 951:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
 952:../src/FreeRTOS/queue.c **** 
 953:../src/FreeRTOS/queue.c ****                 /* Resuming the scheduler will move tasks from the pending
 954:../src/FreeRTOS/queue.c ****                  * ready list into the ready list - so it is feasible that this
 955:../src/FreeRTOS/queue.c ****                  * task is already in a ready list before it yields - in which
 956:../src/FreeRTOS/queue.c ****                  * case the yield will not cause a context switch unless there
 957:../src/FreeRTOS/queue.c ****                  * is also a higher priority task in the pending ready list. */
 958:../src/FreeRTOS/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 959:../src/FreeRTOS/queue.c ****                 {
 960:../src/FreeRTOS/queue.c ****                     portYIELD_WITHIN_API();
 961:../src/FreeRTOS/queue.c ****                 }
 962:../src/FreeRTOS/queue.c ****             }
 963:../src/FreeRTOS/queue.c ****             else
 964:../src/FreeRTOS/queue.c ****             {
 965:../src/FreeRTOS/queue.c ****                 /* Try again. */
 966:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
 967:../src/FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
 968:../src/FreeRTOS/queue.c ****             }
 969:../src/FreeRTOS/queue.c ****         }
 970:../src/FreeRTOS/queue.c ****         else
 971:../src/FreeRTOS/queue.c ****         {
 972:../src/FreeRTOS/queue.c ****             /* The timeout has expired. */
 973:../src/FreeRTOS/queue.c ****             prvUnlockQueue( pxQueue );
 974:../src/FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
 975:../src/FreeRTOS/queue.c **** 
 976:../src/FreeRTOS/queue.c ****             traceQUEUE_SEND_FAILED( pxQueue );
 977:../src/FreeRTOS/queue.c ****             return errQUEUE_FULL;
 978:../src/FreeRTOS/queue.c ****         }
 979:../src/FreeRTOS/queue.c ****     } /*lint -restore */
 980:../src/FreeRTOS/queue.c **** }
 981:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 982:../src/FreeRTOS/queue.c **** 
 983:../src/FreeRTOS/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
 984:../src/FreeRTOS/queue.c ****                                      const void * const pvItemToQueue,
 985:../src/FreeRTOS/queue.c ****                                      BaseType_t * const pxHigherPriorityTaskWoken,
 986:../src/FreeRTOS/queue.c ****                                      const BaseType_t xCopyPosition )
 987:../src/FreeRTOS/queue.c **** {
 988:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 989:../src/FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 990:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 991:../src/FreeRTOS/queue.c **** 
 992:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
 993:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 994:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 995:../src/FreeRTOS/queue.c **** 
 996:../src/FreeRTOS/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
 997:../src/FreeRTOS/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
 998:../src/FreeRTOS/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
 999:../src/FreeRTOS/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1000:../src/FreeRTOS/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1001:../src/FreeRTOS/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1002:../src/FreeRTOS/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1003:../src/FreeRTOS/queue.c ****      * assigned a priority above the configured maximum system call priority.
1004:../src/FreeRTOS/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1005:../src/FreeRTOS/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1006:../src/FreeRTOS/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1007:../src/FreeRTOS/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1008:../src/FreeRTOS/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1009:../src/FreeRTOS/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1010:../src/FreeRTOS/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1011:../src/FreeRTOS/queue.c **** 
1012:../src/FreeRTOS/queue.c ****     /* Similar to xQueueGenericSend, except without blocking if there is no room
1013:../src/FreeRTOS/queue.c ****      * in the queue.  Also don't directly wake a task that was blocked on a queue
1014:../src/FreeRTOS/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1015:../src/FreeRTOS/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1016:../src/FreeRTOS/queue.c ****      * post). */
1017:../src/FreeRTOS/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1018:../src/FreeRTOS/queue.c ****     {
1019:../src/FreeRTOS/queue.c ****         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE
1020:../src/FreeRTOS/queue.c ****         {
1021:../src/FreeRTOS/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
1022:../src/FreeRTOS/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
1023:../src/FreeRTOS/queue.c **** 
1024:../src/FreeRTOS/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1025:../src/FreeRTOS/queue.c **** 
1026:../src/FreeRTOS/queue.c ****             /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1027:../src/FreeRTOS/queue.c ****              *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1028:../src/FreeRTOS/queue.c ****              *  in a task disinheriting a priority and prvCopyDataToQueue() can be
1029:../src/FreeRTOS/queue.c ****              *  called here even though the disinherit function does not check if
1030:../src/FreeRTOS/queue.c ****              *  the scheduler is suspended before accessing the ready lists. */
1031:../src/FreeRTOS/queue.c ****             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1032:../src/FreeRTOS/queue.c **** 
1033:../src/FreeRTOS/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1034:../src/FreeRTOS/queue.c ****              * be done when the queue is unlocked later. */
1035:../src/FreeRTOS/queue.c ****             if( cTxLock == queueUNLOCKED )
1036:../src/FreeRTOS/queue.c ****             {
1037:../src/FreeRTOS/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1038:../src/FreeRTOS/queue.c ****                     {
1039:../src/FreeRTOS/queue.c ****                         if( pxQueue->pxQueueSetContainer != NULL )
1040:../src/FreeRTOS/queue.c ****                         {
1041:../src/FreeRTOS/queue.c ****                             if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting 
1042:../src/FreeRTOS/queue.c ****                             {
1043:../src/FreeRTOS/queue.c ****                                 /* Do not notify the queue set as an existing item
1044:../src/FreeRTOS/queue.c ****                                  * was overwritten in the queue so the number of items
1045:../src/FreeRTOS/queue.c ****                                  * in the queue has not changed. */
1046:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1047:../src/FreeRTOS/queue.c ****                             }
1048:../src/FreeRTOS/queue.c ****                             else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1049:../src/FreeRTOS/queue.c ****                             {
1050:../src/FreeRTOS/queue.c ****                                 /* The queue is a member of a queue set, and posting
1051:../src/FreeRTOS/queue.c ****                                  * to the queue set caused a higher priority task to
1052:../src/FreeRTOS/queue.c ****                                  * unblock.  A context switch is required. */
1053:../src/FreeRTOS/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1054:../src/FreeRTOS/queue.c ****                                 {
1055:../src/FreeRTOS/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1056:../src/FreeRTOS/queue.c ****                                 }
1057:../src/FreeRTOS/queue.c ****                                 else
1058:../src/FreeRTOS/queue.c ****                                 {
1059:../src/FreeRTOS/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1060:../src/FreeRTOS/queue.c ****                                 }
1061:../src/FreeRTOS/queue.c ****                             }
1062:../src/FreeRTOS/queue.c ****                             else
1063:../src/FreeRTOS/queue.c ****                             {
1064:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1065:../src/FreeRTOS/queue.c ****                             }
1066:../src/FreeRTOS/queue.c ****                         }
1067:../src/FreeRTOS/queue.c ****                         else
1068:../src/FreeRTOS/queue.c ****                         {
1069:../src/FreeRTOS/queue.c ****                             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALS
1070:../src/FreeRTOS/queue.c ****                             {
1071:../src/FreeRTOS/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) 
1072:../src/FreeRTOS/queue.c ****                                 {
1073:../src/FreeRTOS/queue.c ****                                     /* The task waiting has a higher priority so
1074:../src/FreeRTOS/queue.c ****                                      *  record that a context switch is required. */
1075:../src/FreeRTOS/queue.c ****                                     if( pxHigherPriorityTaskWoken != NULL )
1076:../src/FreeRTOS/queue.c ****                                     {
1077:../src/FreeRTOS/queue.c ****                                         *pxHigherPriorityTaskWoken = pdTRUE;
1078:../src/FreeRTOS/queue.c ****                                     }
1079:../src/FreeRTOS/queue.c ****                                     else
1080:../src/FreeRTOS/queue.c ****                                     {
1081:../src/FreeRTOS/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1082:../src/FreeRTOS/queue.c ****                                     }
1083:../src/FreeRTOS/queue.c ****                                 }
1084:../src/FreeRTOS/queue.c ****                                 else
1085:../src/FreeRTOS/queue.c ****                                 {
1086:../src/FreeRTOS/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1087:../src/FreeRTOS/queue.c ****                                 }
1088:../src/FreeRTOS/queue.c ****                             }
1089:../src/FreeRTOS/queue.c ****                             else
1090:../src/FreeRTOS/queue.c ****                             {
1091:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1092:../src/FreeRTOS/queue.c ****                             }
1093:../src/FreeRTOS/queue.c ****                         }
1094:../src/FreeRTOS/queue.c ****                     }
1095:../src/FreeRTOS/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1096:../src/FreeRTOS/queue.c ****                     {
1097:../src/FreeRTOS/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1098:../src/FreeRTOS/queue.c ****                         {
1099:../src/FreeRTOS/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1100:../src/FreeRTOS/queue.c ****                             {
1101:../src/FreeRTOS/queue.c ****                                 /* The task waiting has a higher priority so record that a
1102:../src/FreeRTOS/queue.c ****                                  * context switch is required. */
1103:../src/FreeRTOS/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1104:../src/FreeRTOS/queue.c ****                                 {
1105:../src/FreeRTOS/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1106:../src/FreeRTOS/queue.c ****                                 }
1107:../src/FreeRTOS/queue.c ****                                 else
1108:../src/FreeRTOS/queue.c ****                                 {
1109:../src/FreeRTOS/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1110:../src/FreeRTOS/queue.c ****                                 }
1111:../src/FreeRTOS/queue.c ****                             }
1112:../src/FreeRTOS/queue.c ****                             else
1113:../src/FreeRTOS/queue.c ****                             {
1114:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1115:../src/FreeRTOS/queue.c ****                             }
1116:../src/FreeRTOS/queue.c ****                         }
1117:../src/FreeRTOS/queue.c ****                         else
1118:../src/FreeRTOS/queue.c ****                         {
1119:../src/FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1120:../src/FreeRTOS/queue.c ****                         }
1121:../src/FreeRTOS/queue.c **** 
1122:../src/FreeRTOS/queue.c ****                         /* Not used in this path. */
1123:../src/FreeRTOS/queue.c ****                         ( void ) uxPreviousMessagesWaiting;
1124:../src/FreeRTOS/queue.c ****                     }
1125:../src/FreeRTOS/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1126:../src/FreeRTOS/queue.c ****             }
1127:../src/FreeRTOS/queue.c ****             else
1128:../src/FreeRTOS/queue.c ****             {
1129:../src/FreeRTOS/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1130:../src/FreeRTOS/queue.c ****                  * knows that data was posted while it was locked. */
1131:../src/FreeRTOS/queue.c ****                 configASSERT( cTxLock != queueINT8_MAX );
1132:../src/FreeRTOS/queue.c **** 
1133:../src/FreeRTOS/queue.c ****                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1134:../src/FreeRTOS/queue.c ****             }
1135:../src/FreeRTOS/queue.c **** 
1136:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
1137:../src/FreeRTOS/queue.c ****         }
1138:../src/FreeRTOS/queue.c ****         else
1139:../src/FreeRTOS/queue.c ****         {
1140:../src/FreeRTOS/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1141:../src/FreeRTOS/queue.c ****             xReturn = errQUEUE_FULL;
1142:../src/FreeRTOS/queue.c ****         }
1143:../src/FreeRTOS/queue.c ****     }
1144:../src/FreeRTOS/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1145:../src/FreeRTOS/queue.c **** 
1146:../src/FreeRTOS/queue.c ****     return xReturn;
1147:../src/FreeRTOS/queue.c **** }
1148:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1149:../src/FreeRTOS/queue.c **** 
1150:../src/FreeRTOS/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
1151:../src/FreeRTOS/queue.c ****                               BaseType_t * const pxHigherPriorityTaskWoken )
1152:../src/FreeRTOS/queue.c **** {
1153:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
1154:../src/FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1155:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1156:../src/FreeRTOS/queue.c **** 
1157:../src/FreeRTOS/queue.c ****     /* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1158:../src/FreeRTOS/queue.c ****      * item size is 0.  Don't directly wake a task that was blocked on a queue
1159:../src/FreeRTOS/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1160:../src/FreeRTOS/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1161:../src/FreeRTOS/queue.c ****      * post). */
1162:../src/FreeRTOS/queue.c **** 
1163:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
1164:../src/FreeRTOS/queue.c **** 
1165:../src/FreeRTOS/queue.c ****     /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1166:../src/FreeRTOS/queue.c ****      * if the item size is not 0. */
1167:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
1168:../src/FreeRTOS/queue.c **** 
1169:../src/FreeRTOS/queue.c ****     /* Normally a mutex would not be given from an interrupt, especially if
1170:../src/FreeRTOS/queue.c ****      * there is a mutex holder, as priority inheritance makes no sense for an
1171:../src/FreeRTOS/queue.c ****      * interrupts, only tasks. */
1172:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMu
1173:../src/FreeRTOS/queue.c **** 
1174:../src/FreeRTOS/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1175:../src/FreeRTOS/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1176:../src/FreeRTOS/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1177:../src/FreeRTOS/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1178:../src/FreeRTOS/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1179:../src/FreeRTOS/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1180:../src/FreeRTOS/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1181:../src/FreeRTOS/queue.c ****      * assigned a priority above the configured maximum system call priority.
1182:../src/FreeRTOS/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1183:../src/FreeRTOS/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1184:../src/FreeRTOS/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1185:../src/FreeRTOS/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1186:../src/FreeRTOS/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1187:../src/FreeRTOS/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1188:../src/FreeRTOS/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1189:../src/FreeRTOS/queue.c **** 
1190:../src/FreeRTOS/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1191:../src/FreeRTOS/queue.c ****     {
1192:../src/FreeRTOS/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1193:../src/FreeRTOS/queue.c **** 
1194:../src/FreeRTOS/queue.c ****         /* When the queue is used to implement a semaphore no data is ever
1195:../src/FreeRTOS/queue.c ****          * moved through the queue but it is still valid to see if the queue 'has
1196:../src/FreeRTOS/queue.c ****          * space'. */
1197:../src/FreeRTOS/queue.c ****         if( uxMessagesWaiting < pxQueue->uxLength )
1198:../src/FreeRTOS/queue.c ****         {
1199:../src/FreeRTOS/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
1200:../src/FreeRTOS/queue.c **** 
1201:../src/FreeRTOS/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1202:../src/FreeRTOS/queue.c **** 
1203:../src/FreeRTOS/queue.c ****             /* A task can only have an inherited priority if it is a mutex
1204:../src/FreeRTOS/queue.c ****              * holder - and if there is a mutex holder then the mutex cannot be
1205:../src/FreeRTOS/queue.c ****              * given from an ISR.  As this is the ISR version of the function it
1206:../src/FreeRTOS/queue.c ****              * can be assumed there is no mutex holder and no need to determine if
1207:../src/FreeRTOS/queue.c ****              * priority disinheritance is needed.  Simply increase the count of
1208:../src/FreeRTOS/queue.c ****              * messages (semaphores) available. */
1209:../src/FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1210:../src/FreeRTOS/queue.c **** 
1211:../src/FreeRTOS/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1212:../src/FreeRTOS/queue.c ****              * be done when the queue is unlocked later. */
1213:../src/FreeRTOS/queue.c ****             if( cTxLock == queueUNLOCKED )
1214:../src/FreeRTOS/queue.c ****             {
1215:../src/FreeRTOS/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1216:../src/FreeRTOS/queue.c ****                     {
1217:../src/FreeRTOS/queue.c ****                         if( pxQueue->pxQueueSetContainer != NULL )
1218:../src/FreeRTOS/queue.c ****                         {
1219:../src/FreeRTOS/queue.c ****                             if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1220:../src/FreeRTOS/queue.c ****                             {
1221:../src/FreeRTOS/queue.c ****                                 /* The semaphore is a member of a queue set, and
1222:../src/FreeRTOS/queue.c ****                                  * posting to the queue set caused a higher priority
1223:../src/FreeRTOS/queue.c ****                                  * task to unblock.  A context switch is required. */
1224:../src/FreeRTOS/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1225:../src/FreeRTOS/queue.c ****                                 {
1226:../src/FreeRTOS/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1227:../src/FreeRTOS/queue.c ****                                 }
1228:../src/FreeRTOS/queue.c ****                                 else
1229:../src/FreeRTOS/queue.c ****                                 {
1230:../src/FreeRTOS/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1231:../src/FreeRTOS/queue.c ****                                 }
1232:../src/FreeRTOS/queue.c ****                             }
1233:../src/FreeRTOS/queue.c ****                             else
1234:../src/FreeRTOS/queue.c ****                             {
1235:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1236:../src/FreeRTOS/queue.c ****                             }
1237:../src/FreeRTOS/queue.c ****                         }
1238:../src/FreeRTOS/queue.c ****                         else
1239:../src/FreeRTOS/queue.c ****                         {
1240:../src/FreeRTOS/queue.c ****                             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALS
1241:../src/FreeRTOS/queue.c ****                             {
1242:../src/FreeRTOS/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) 
1243:../src/FreeRTOS/queue.c ****                                 {
1244:../src/FreeRTOS/queue.c ****                                     /* The task waiting has a higher priority so
1245:../src/FreeRTOS/queue.c ****                                      *  record that a context switch is required. */
1246:../src/FreeRTOS/queue.c ****                                     if( pxHigherPriorityTaskWoken != NULL )
1247:../src/FreeRTOS/queue.c ****                                     {
1248:../src/FreeRTOS/queue.c ****                                         *pxHigherPriorityTaskWoken = pdTRUE;
1249:../src/FreeRTOS/queue.c ****                                     }
1250:../src/FreeRTOS/queue.c ****                                     else
1251:../src/FreeRTOS/queue.c ****                                     {
1252:../src/FreeRTOS/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1253:../src/FreeRTOS/queue.c ****                                     }
1254:../src/FreeRTOS/queue.c ****                                 }
1255:../src/FreeRTOS/queue.c ****                                 else
1256:../src/FreeRTOS/queue.c ****                                 {
1257:../src/FreeRTOS/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1258:../src/FreeRTOS/queue.c ****                                 }
1259:../src/FreeRTOS/queue.c ****                             }
1260:../src/FreeRTOS/queue.c ****                             else
1261:../src/FreeRTOS/queue.c ****                             {
1262:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1263:../src/FreeRTOS/queue.c ****                             }
1264:../src/FreeRTOS/queue.c ****                         }
1265:../src/FreeRTOS/queue.c ****                     }
1266:../src/FreeRTOS/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1267:../src/FreeRTOS/queue.c ****                     {
1268:../src/FreeRTOS/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1269:../src/FreeRTOS/queue.c ****                         {
1270:../src/FreeRTOS/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1271:../src/FreeRTOS/queue.c ****                             {
1272:../src/FreeRTOS/queue.c ****                                 /* The task waiting has a higher priority so record that a
1273:../src/FreeRTOS/queue.c ****                                  * context switch is required. */
1274:../src/FreeRTOS/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1275:../src/FreeRTOS/queue.c ****                                 {
1276:../src/FreeRTOS/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1277:../src/FreeRTOS/queue.c ****                                 }
1278:../src/FreeRTOS/queue.c ****                                 else
1279:../src/FreeRTOS/queue.c ****                                 {
1280:../src/FreeRTOS/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1281:../src/FreeRTOS/queue.c ****                                 }
1282:../src/FreeRTOS/queue.c ****                             }
1283:../src/FreeRTOS/queue.c ****                             else
1284:../src/FreeRTOS/queue.c ****                             {
1285:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1286:../src/FreeRTOS/queue.c ****                             }
1287:../src/FreeRTOS/queue.c ****                         }
1288:../src/FreeRTOS/queue.c ****                         else
1289:../src/FreeRTOS/queue.c ****                         {
1290:../src/FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1291:../src/FreeRTOS/queue.c ****                         }
1292:../src/FreeRTOS/queue.c ****                     }
1293:../src/FreeRTOS/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1294:../src/FreeRTOS/queue.c ****             }
1295:../src/FreeRTOS/queue.c ****             else
1296:../src/FreeRTOS/queue.c ****             {
1297:../src/FreeRTOS/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1298:../src/FreeRTOS/queue.c ****                  * knows that data was posted while it was locked. */
1299:../src/FreeRTOS/queue.c ****                 configASSERT( cTxLock != queueINT8_MAX );
1300:../src/FreeRTOS/queue.c **** 
1301:../src/FreeRTOS/queue.c ****                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1302:../src/FreeRTOS/queue.c ****             }
1303:../src/FreeRTOS/queue.c **** 
1304:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
1305:../src/FreeRTOS/queue.c ****         }
1306:../src/FreeRTOS/queue.c ****         else
1307:../src/FreeRTOS/queue.c ****         {
1308:../src/FreeRTOS/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1309:../src/FreeRTOS/queue.c ****             xReturn = errQUEUE_FULL;
1310:../src/FreeRTOS/queue.c ****         }
1311:../src/FreeRTOS/queue.c ****     }
1312:../src/FreeRTOS/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1313:../src/FreeRTOS/queue.c **** 
1314:../src/FreeRTOS/queue.c ****     return xReturn;
1315:../src/FreeRTOS/queue.c **** }
1316:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1317:../src/FreeRTOS/queue.c **** 
1318:../src/FreeRTOS/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue,
1319:../src/FreeRTOS/queue.c ****                           void * const pvBuffer,
1320:../src/FreeRTOS/queue.c ****                           TickType_t xTicksToWait )
1321:../src/FreeRTOS/queue.c **** {
1322:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1323:../src/FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
1324:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1325:../src/FreeRTOS/queue.c **** 
1326:../src/FreeRTOS/queue.c ****     /* Check the pointer is not NULL. */
1327:../src/FreeRTOS/queue.c ****     configASSERT( ( pxQueue ) );
1328:../src/FreeRTOS/queue.c **** 
1329:../src/FreeRTOS/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1330:../src/FreeRTOS/queue.c ****      * is zero (so no data is copied into the buffer). */
1331:../src/FreeRTOS/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
1332:../src/FreeRTOS/queue.c **** 
1333:../src/FreeRTOS/queue.c ****     /* Cannot block if the scheduler is suspended. */
1334:../src/FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1335:../src/FreeRTOS/queue.c ****         {
1336:../src/FreeRTOS/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
1337:../src/FreeRTOS/queue.c ****         }
1338:../src/FreeRTOS/queue.c ****     #endif
1339:../src/FreeRTOS/queue.c **** 
1340:../src/FreeRTOS/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1341:../src/FreeRTOS/queue.c ****      * allow return statements within the function itself.  This is done in the
1342:../src/FreeRTOS/queue.c ****      * interest of execution time efficiency. */
1343:../src/FreeRTOS/queue.c ****     for( ; ; )
1344:../src/FreeRTOS/queue.c ****     {
1345:../src/FreeRTOS/queue.c ****         taskENTER_CRITICAL();
1346:../src/FreeRTOS/queue.c ****         {
1347:../src/FreeRTOS/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1348:../src/FreeRTOS/queue.c **** 
1349:../src/FreeRTOS/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1350:../src/FreeRTOS/queue.c ****              * must be the highest priority task wanting to access the queue. */
1351:../src/FreeRTOS/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1352:../src/FreeRTOS/queue.c ****             {
1353:../src/FreeRTOS/queue.c ****                 /* Data available, remove one item. */
1354:../src/FreeRTOS/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
1355:../src/FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1356:../src/FreeRTOS/queue.c ****                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1357:../src/FreeRTOS/queue.c **** 
1358:../src/FreeRTOS/queue.c ****                 /* There is now space in the queue, were any tasks waiting to
1359:../src/FreeRTOS/queue.c ****                  * post to the queue?  If so, unblock the highest priority waiting
1360:../src/FreeRTOS/queue.c ****                  * task. */
1361:../src/FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1362:../src/FreeRTOS/queue.c ****                 {
1363:../src/FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1364:../src/FreeRTOS/queue.c ****                     {
1365:../src/FreeRTOS/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1366:../src/FreeRTOS/queue.c ****                     }
1367:../src/FreeRTOS/queue.c ****                     else
1368:../src/FreeRTOS/queue.c ****                     {
1369:../src/FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1370:../src/FreeRTOS/queue.c ****                     }
1371:../src/FreeRTOS/queue.c ****                 }
1372:../src/FreeRTOS/queue.c ****                 else
1373:../src/FreeRTOS/queue.c ****                 {
1374:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1375:../src/FreeRTOS/queue.c ****                 }
1376:../src/FreeRTOS/queue.c **** 
1377:../src/FreeRTOS/queue.c ****                 taskEXIT_CRITICAL();
1378:../src/FreeRTOS/queue.c ****                 return pdPASS;
1379:../src/FreeRTOS/queue.c ****             }
1380:../src/FreeRTOS/queue.c ****             else
1381:../src/FreeRTOS/queue.c ****             {
1382:../src/FreeRTOS/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1383:../src/FreeRTOS/queue.c ****                 {
1384:../src/FreeRTOS/queue.c ****                     /* The queue was empty and no block time is specified (or
1385:../src/FreeRTOS/queue.c ****                      * the block time has expired) so leave now. */
1386:../src/FreeRTOS/queue.c ****                     taskEXIT_CRITICAL();
1387:../src/FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1388:../src/FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
1389:../src/FreeRTOS/queue.c ****                 }
1390:../src/FreeRTOS/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1391:../src/FreeRTOS/queue.c ****                 {
1392:../src/FreeRTOS/queue.c ****                     /* The queue was empty and a block time was specified so
1393:../src/FreeRTOS/queue.c ****                      * configure the timeout structure. */
1394:../src/FreeRTOS/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1395:../src/FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
1396:../src/FreeRTOS/queue.c ****                 }
1397:../src/FreeRTOS/queue.c ****                 else
1398:../src/FreeRTOS/queue.c ****                 {
1399:../src/FreeRTOS/queue.c ****                     /* Entry time was already set. */
1400:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1401:../src/FreeRTOS/queue.c ****                 }
1402:../src/FreeRTOS/queue.c ****             }
1403:../src/FreeRTOS/queue.c ****         }
1404:../src/FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
1405:../src/FreeRTOS/queue.c **** 
1406:../src/FreeRTOS/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1407:../src/FreeRTOS/queue.c ****          * now the critical section has been exited. */
1408:../src/FreeRTOS/queue.c **** 
1409:../src/FreeRTOS/queue.c ****         vTaskSuspendAll();
1410:../src/FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
1411:../src/FreeRTOS/queue.c **** 
1412:../src/FreeRTOS/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1413:../src/FreeRTOS/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1414:../src/FreeRTOS/queue.c ****         {
1415:../src/FreeRTOS/queue.c ****             /* The timeout has not expired.  If the queue is still empty place
1416:../src/FreeRTOS/queue.c ****              * the task on the list of tasks waiting to receive from the queue. */
1417:../src/FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1418:../src/FreeRTOS/queue.c ****             {
1419:../src/FreeRTOS/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1420:../src/FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1421:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1422:../src/FreeRTOS/queue.c **** 
1423:../src/FreeRTOS/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1424:../src/FreeRTOS/queue.c ****                 {
1425:../src/FreeRTOS/queue.c ****                     portYIELD_WITHIN_API();
1426:../src/FreeRTOS/queue.c ****                 }
1427:../src/FreeRTOS/queue.c ****                 else
1428:../src/FreeRTOS/queue.c ****                 {
1429:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1430:../src/FreeRTOS/queue.c ****                 }
1431:../src/FreeRTOS/queue.c ****             }
1432:../src/FreeRTOS/queue.c ****             else
1433:../src/FreeRTOS/queue.c ****             {
1434:../src/FreeRTOS/queue.c ****                 /* The queue contains data again.  Loop back to try and read the
1435:../src/FreeRTOS/queue.c ****                  * data. */
1436:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1437:../src/FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
1438:../src/FreeRTOS/queue.c ****             }
1439:../src/FreeRTOS/queue.c ****         }
1440:../src/FreeRTOS/queue.c ****         else
1441:../src/FreeRTOS/queue.c ****         {
1442:../src/FreeRTOS/queue.c ****             /* Timed out.  If there is no data in the queue exit, otherwise loop
1443:../src/FreeRTOS/queue.c ****              * back and attempt to read the data. */
1444:../src/FreeRTOS/queue.c ****             prvUnlockQueue( pxQueue );
1445:../src/FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
1446:../src/FreeRTOS/queue.c **** 
1447:../src/FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1448:../src/FreeRTOS/queue.c ****             {
1449:../src/FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1450:../src/FreeRTOS/queue.c ****                 return errQUEUE_EMPTY;
1451:../src/FreeRTOS/queue.c ****             }
1452:../src/FreeRTOS/queue.c ****             else
1453:../src/FreeRTOS/queue.c ****             {
1454:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1455:../src/FreeRTOS/queue.c ****             }
1456:../src/FreeRTOS/queue.c ****         }
1457:../src/FreeRTOS/queue.c ****     } /*lint -restore */
1458:../src/FreeRTOS/queue.c **** }
1459:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1460:../src/FreeRTOS/queue.c **** 
1461:../src/FreeRTOS/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
1462:../src/FreeRTOS/queue.c ****                                 TickType_t xTicksToWait )
1463:../src/FreeRTOS/queue.c **** {
1464:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1465:../src/FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
1466:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1467:../src/FreeRTOS/queue.c **** 
1468:../src/FreeRTOS/queue.c ****     #if ( configUSE_MUTEXES == 1 )
1469:../src/FreeRTOS/queue.c ****         BaseType_t xInheritanceOccurred = pdFALSE;
1470:../src/FreeRTOS/queue.c ****     #endif
1471:../src/FreeRTOS/queue.c **** 
1472:../src/FreeRTOS/queue.c ****     /* Check the queue pointer is not NULL. */
1473:../src/FreeRTOS/queue.c ****     configASSERT( ( pxQueue ) );
1474:../src/FreeRTOS/queue.c **** 
1475:../src/FreeRTOS/queue.c ****     /* Check this really is a semaphore, in which case the item size will be
1476:../src/FreeRTOS/queue.c ****      * 0. */
1477:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
1478:../src/FreeRTOS/queue.c **** 
1479:../src/FreeRTOS/queue.c ****     /* Cannot block if the scheduler is suspended. */
1480:../src/FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1481:../src/FreeRTOS/queue.c ****         {
1482:../src/FreeRTOS/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
1483:../src/FreeRTOS/queue.c ****         }
1484:../src/FreeRTOS/queue.c ****     #endif
1485:../src/FreeRTOS/queue.c **** 
1486:../src/FreeRTOS/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1487:../src/FreeRTOS/queue.c ****      * statements within the function itself.  This is done in the interest
1488:../src/FreeRTOS/queue.c ****      * of execution time efficiency. */
1489:../src/FreeRTOS/queue.c ****     for( ; ; )
1490:../src/FreeRTOS/queue.c ****     {
1491:../src/FreeRTOS/queue.c ****         taskENTER_CRITICAL();
1492:../src/FreeRTOS/queue.c ****         {
1493:../src/FreeRTOS/queue.c ****             /* Semaphores are queues with an item size of 0, and where the
1494:../src/FreeRTOS/queue.c ****              * number of messages in the queue is the semaphore's count value. */
1495:../src/FreeRTOS/queue.c ****             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1496:../src/FreeRTOS/queue.c **** 
1497:../src/FreeRTOS/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1498:../src/FreeRTOS/queue.c ****              * must be the highest priority task wanting to access the queue. */
1499:../src/FreeRTOS/queue.c ****             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1500:../src/FreeRTOS/queue.c ****             {
1501:../src/FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1502:../src/FreeRTOS/queue.c **** 
1503:../src/FreeRTOS/queue.c ****                 /* Semaphores are queues with a data size of zero and where the
1504:../src/FreeRTOS/queue.c ****                  * messages waiting is the semaphore's count.  Reduce the count. */
1505:../src/FreeRTOS/queue.c ****                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1506:../src/FreeRTOS/queue.c **** 
1507:../src/FreeRTOS/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1508:../src/FreeRTOS/queue.c ****                     {
1509:../src/FreeRTOS/queue.c ****                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1510:../src/FreeRTOS/queue.c ****                         {
1511:../src/FreeRTOS/queue.c ****                             /* Record the information required to implement
1512:../src/FreeRTOS/queue.c ****                              * priority inheritance should it become necessary. */
1513:../src/FreeRTOS/queue.c ****                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1514:../src/FreeRTOS/queue.c ****                         }
1515:../src/FreeRTOS/queue.c ****                         else
1516:../src/FreeRTOS/queue.c ****                         {
1517:../src/FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1518:../src/FreeRTOS/queue.c ****                         }
1519:../src/FreeRTOS/queue.c ****                     }
1520:../src/FreeRTOS/queue.c ****                 #endif /* configUSE_MUTEXES */
1521:../src/FreeRTOS/queue.c **** 
1522:../src/FreeRTOS/queue.c ****                 /* Check to see if other tasks are blocked waiting to give the
1523:../src/FreeRTOS/queue.c ****                  * semaphore, and if so, unblock the highest priority such task. */
1524:../src/FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1525:../src/FreeRTOS/queue.c ****                 {
1526:../src/FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1527:../src/FreeRTOS/queue.c ****                     {
1528:../src/FreeRTOS/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1529:../src/FreeRTOS/queue.c ****                     }
1530:../src/FreeRTOS/queue.c ****                     else
1531:../src/FreeRTOS/queue.c ****                     {
1532:../src/FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1533:../src/FreeRTOS/queue.c ****                     }
1534:../src/FreeRTOS/queue.c ****                 }
1535:../src/FreeRTOS/queue.c ****                 else
1536:../src/FreeRTOS/queue.c ****                 {
1537:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1538:../src/FreeRTOS/queue.c ****                 }
1539:../src/FreeRTOS/queue.c **** 
1540:../src/FreeRTOS/queue.c ****                 taskEXIT_CRITICAL();
1541:../src/FreeRTOS/queue.c ****                 return pdPASS;
1542:../src/FreeRTOS/queue.c ****             }
1543:../src/FreeRTOS/queue.c ****             else
1544:../src/FreeRTOS/queue.c ****             {
1545:../src/FreeRTOS/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1546:../src/FreeRTOS/queue.c ****                 {
1547:../src/FreeRTOS/queue.c ****                     /* For inheritance to have occurred there must have been an
1548:../src/FreeRTOS/queue.c ****                      * initial timeout, and an adjusted timeout cannot become 0, as
1549:../src/FreeRTOS/queue.c ****                      * if it were 0 the function would have exited. */
1550:../src/FreeRTOS/queue.c ****                     #if ( configUSE_MUTEXES == 1 )
1551:../src/FreeRTOS/queue.c ****                         {
1552:../src/FreeRTOS/queue.c ****                             configASSERT( xInheritanceOccurred == pdFALSE );
1553:../src/FreeRTOS/queue.c ****                         }
1554:../src/FreeRTOS/queue.c ****                     #endif /* configUSE_MUTEXES */
1555:../src/FreeRTOS/queue.c **** 
1556:../src/FreeRTOS/queue.c ****                     /* The semaphore count was 0 and no block time is specified
1557:../src/FreeRTOS/queue.c ****                      * (or the block time has expired) so exit now. */
1558:../src/FreeRTOS/queue.c ****                     taskEXIT_CRITICAL();
1559:../src/FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1560:../src/FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
1561:../src/FreeRTOS/queue.c ****                 }
1562:../src/FreeRTOS/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1563:../src/FreeRTOS/queue.c ****                 {
1564:../src/FreeRTOS/queue.c ****                     /* The semaphore count was 0 and a block time was specified
1565:../src/FreeRTOS/queue.c ****                      * so configure the timeout structure ready to block. */
1566:../src/FreeRTOS/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1567:../src/FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
1568:../src/FreeRTOS/queue.c ****                 }
1569:../src/FreeRTOS/queue.c ****                 else
1570:../src/FreeRTOS/queue.c ****                 {
1571:../src/FreeRTOS/queue.c ****                     /* Entry time was already set. */
1572:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1573:../src/FreeRTOS/queue.c ****                 }
1574:../src/FreeRTOS/queue.c ****             }
1575:../src/FreeRTOS/queue.c ****         }
1576:../src/FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
1577:../src/FreeRTOS/queue.c **** 
1578:../src/FreeRTOS/queue.c ****         /* Interrupts and other tasks can give to and take from the semaphore
1579:../src/FreeRTOS/queue.c ****          * now the critical section has been exited. */
1580:../src/FreeRTOS/queue.c **** 
1581:../src/FreeRTOS/queue.c ****         vTaskSuspendAll();
1582:../src/FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
1583:../src/FreeRTOS/queue.c **** 
1584:../src/FreeRTOS/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1585:../src/FreeRTOS/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1586:../src/FreeRTOS/queue.c ****         {
1587:../src/FreeRTOS/queue.c ****             /* A block time is specified and not expired.  If the semaphore
1588:../src/FreeRTOS/queue.c ****              * count is 0 then enter the Blocked state to wait for a semaphore to
1589:../src/FreeRTOS/queue.c ****              * become available.  As semaphores are implemented with queues the
1590:../src/FreeRTOS/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1591:../src/FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1592:../src/FreeRTOS/queue.c ****             {
1593:../src/FreeRTOS/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1594:../src/FreeRTOS/queue.c **** 
1595:../src/FreeRTOS/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1596:../src/FreeRTOS/queue.c ****                     {
1597:../src/FreeRTOS/queue.c ****                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1598:../src/FreeRTOS/queue.c ****                         {
1599:../src/FreeRTOS/queue.c ****                             taskENTER_CRITICAL();
1600:../src/FreeRTOS/queue.c ****                             {
1601:../src/FreeRTOS/queue.c ****                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.
1602:../src/FreeRTOS/queue.c ****                             }
1603:../src/FreeRTOS/queue.c ****                             taskEXIT_CRITICAL();
1604:../src/FreeRTOS/queue.c ****                         }
1605:../src/FreeRTOS/queue.c ****                         else
1606:../src/FreeRTOS/queue.c ****                         {
1607:../src/FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1608:../src/FreeRTOS/queue.c ****                         }
1609:../src/FreeRTOS/queue.c ****                     }
1610:../src/FreeRTOS/queue.c ****                 #endif /* if ( configUSE_MUTEXES == 1 ) */
1611:../src/FreeRTOS/queue.c **** 
1612:../src/FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1613:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1614:../src/FreeRTOS/queue.c **** 
1615:../src/FreeRTOS/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1616:../src/FreeRTOS/queue.c ****                 {
1617:../src/FreeRTOS/queue.c ****                     portYIELD_WITHIN_API();
1618:../src/FreeRTOS/queue.c ****                 }
1619:../src/FreeRTOS/queue.c ****                 else
1620:../src/FreeRTOS/queue.c ****                 {
1621:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1622:../src/FreeRTOS/queue.c ****                 }
1623:../src/FreeRTOS/queue.c ****             }
1624:../src/FreeRTOS/queue.c ****             else
1625:../src/FreeRTOS/queue.c ****             {
1626:../src/FreeRTOS/queue.c ****                 /* There was no timeout and the semaphore count was not 0, so
1627:../src/FreeRTOS/queue.c ****                  * attempt to take the semaphore again. */
1628:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1629:../src/FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
1630:../src/FreeRTOS/queue.c ****             }
1631:../src/FreeRTOS/queue.c ****         }
1632:../src/FreeRTOS/queue.c ****         else
1633:../src/FreeRTOS/queue.c ****         {
1634:../src/FreeRTOS/queue.c ****             /* Timed out. */
1635:../src/FreeRTOS/queue.c ****             prvUnlockQueue( pxQueue );
1636:../src/FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
1637:../src/FreeRTOS/queue.c **** 
1638:../src/FreeRTOS/queue.c ****             /* If the semaphore count is 0 exit now as the timeout has
1639:../src/FreeRTOS/queue.c ****              * expired.  Otherwise return to attempt to take the semaphore that is
1640:../src/FreeRTOS/queue.c ****              * known to be available.  As semaphores are implemented by queues the
1641:../src/FreeRTOS/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1642:../src/FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1643:../src/FreeRTOS/queue.c ****             {
1644:../src/FreeRTOS/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1645:../src/FreeRTOS/queue.c ****                     {
1646:../src/FreeRTOS/queue.c ****                         /* xInheritanceOccurred could only have be set if
1647:../src/FreeRTOS/queue.c ****                          * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1648:../src/FreeRTOS/queue.c ****                          * test the mutex type again to check it is actually a mutex. */
1649:../src/FreeRTOS/queue.c ****                         if( xInheritanceOccurred != pdFALSE )
1650:../src/FreeRTOS/queue.c ****                         {
1651:../src/FreeRTOS/queue.c ****                             taskENTER_CRITICAL();
1652:../src/FreeRTOS/queue.c ****                             {
1653:../src/FreeRTOS/queue.c ****                                 UBaseType_t uxHighestWaitingPriority;
1654:../src/FreeRTOS/queue.c **** 
1655:../src/FreeRTOS/queue.c ****                                 /* This task blocking on the mutex caused another
1656:../src/FreeRTOS/queue.c ****                                  * task to inherit this task's priority.  Now this task
1657:../src/FreeRTOS/queue.c ****                                  * has timed out the priority should be disinherited
1658:../src/FreeRTOS/queue.c ****                                  * again, but only as low as the next highest priority
1659:../src/FreeRTOS/queue.c ****                                  * task that is waiting for the same mutex. */
1660:../src/FreeRTOS/queue.c ****                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( px
1661:../src/FreeRTOS/queue.c ****                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHo
1662:../src/FreeRTOS/queue.c ****                             }
1663:../src/FreeRTOS/queue.c ****                             taskEXIT_CRITICAL();
1664:../src/FreeRTOS/queue.c ****                         }
1665:../src/FreeRTOS/queue.c ****                     }
1666:../src/FreeRTOS/queue.c ****                 #endif /* configUSE_MUTEXES */
1667:../src/FreeRTOS/queue.c **** 
1668:../src/FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1669:../src/FreeRTOS/queue.c ****                 return errQUEUE_EMPTY;
1670:../src/FreeRTOS/queue.c ****             }
1671:../src/FreeRTOS/queue.c ****             else
1672:../src/FreeRTOS/queue.c ****             {
1673:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1674:../src/FreeRTOS/queue.c ****             }
1675:../src/FreeRTOS/queue.c ****         }
1676:../src/FreeRTOS/queue.c ****     } /*lint -restore */
1677:../src/FreeRTOS/queue.c **** }
1678:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1679:../src/FreeRTOS/queue.c **** 
1680:../src/FreeRTOS/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue,
1681:../src/FreeRTOS/queue.c ****                        void * const pvBuffer,
1682:../src/FreeRTOS/queue.c ****                        TickType_t xTicksToWait )
1683:../src/FreeRTOS/queue.c **** {
1684:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1685:../src/FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
1686:../src/FreeRTOS/queue.c ****     int8_t * pcOriginalReadPosition;
1687:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1688:../src/FreeRTOS/queue.c **** 
1689:../src/FreeRTOS/queue.c ****     /* Check the pointer is not NULL. */
1690:../src/FreeRTOS/queue.c ****     configASSERT( ( pxQueue ) );
1691:../src/FreeRTOS/queue.c **** 
1692:../src/FreeRTOS/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1693:../src/FreeRTOS/queue.c ****      * is zero (so no data is copied into the buffer. */
1694:../src/FreeRTOS/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
1695:../src/FreeRTOS/queue.c **** 
1696:../src/FreeRTOS/queue.c ****     /* Cannot block if the scheduler is suspended. */
1697:../src/FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1698:../src/FreeRTOS/queue.c ****         {
1699:../src/FreeRTOS/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
1700:../src/FreeRTOS/queue.c ****         }
1701:../src/FreeRTOS/queue.c ****     #endif
1702:../src/FreeRTOS/queue.c **** 
1703:../src/FreeRTOS/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1704:../src/FreeRTOS/queue.c ****      * allow return statements within the function itself.  This is done in the
1705:../src/FreeRTOS/queue.c ****      * interest of execution time efficiency. */
1706:../src/FreeRTOS/queue.c ****     for( ; ; )
1707:../src/FreeRTOS/queue.c ****     {
1708:../src/FreeRTOS/queue.c ****         taskENTER_CRITICAL();
1709:../src/FreeRTOS/queue.c ****         {
1710:../src/FreeRTOS/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1711:../src/FreeRTOS/queue.c **** 
1712:../src/FreeRTOS/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1713:../src/FreeRTOS/queue.c ****              * must be the highest priority task wanting to access the queue. */
1714:../src/FreeRTOS/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1715:../src/FreeRTOS/queue.c ****             {
1716:../src/FreeRTOS/queue.c ****                 /* Remember the read position so it can be reset after the data
1717:../src/FreeRTOS/queue.c ****                  * is read from the queue as this function is only peeking the
1718:../src/FreeRTOS/queue.c ****                  * data, not removing it. */
1719:../src/FreeRTOS/queue.c ****                 pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1720:../src/FreeRTOS/queue.c **** 
1721:../src/FreeRTOS/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
1722:../src/FreeRTOS/queue.c ****                 traceQUEUE_PEEK( pxQueue );
1723:../src/FreeRTOS/queue.c **** 
1724:../src/FreeRTOS/queue.c ****                 /* The data is not being removed, so reset the read pointer. */
1725:../src/FreeRTOS/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1726:../src/FreeRTOS/queue.c **** 
1727:../src/FreeRTOS/queue.c ****                 /* The data is being left in the queue, so see if there are
1728:../src/FreeRTOS/queue.c ****                  * any other tasks waiting for the data. */
1729:../src/FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1730:../src/FreeRTOS/queue.c ****                 {
1731:../src/FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE
1732:../src/FreeRTOS/queue.c ****                     {
1733:../src/FreeRTOS/queue.c ****                         /* The task waiting has a higher priority than this task. */
1734:../src/FreeRTOS/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1735:../src/FreeRTOS/queue.c ****                     }
1736:../src/FreeRTOS/queue.c ****                     else
1737:../src/FreeRTOS/queue.c ****                     {
1738:../src/FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1739:../src/FreeRTOS/queue.c ****                     }
1740:../src/FreeRTOS/queue.c ****                 }
1741:../src/FreeRTOS/queue.c ****                 else
1742:../src/FreeRTOS/queue.c ****                 {
1743:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1744:../src/FreeRTOS/queue.c ****                 }
1745:../src/FreeRTOS/queue.c **** 
1746:../src/FreeRTOS/queue.c ****                 taskEXIT_CRITICAL();
1747:../src/FreeRTOS/queue.c ****                 return pdPASS;
1748:../src/FreeRTOS/queue.c ****             }
1749:../src/FreeRTOS/queue.c ****             else
1750:../src/FreeRTOS/queue.c ****             {
1751:../src/FreeRTOS/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1752:../src/FreeRTOS/queue.c ****                 {
1753:../src/FreeRTOS/queue.c ****                     /* The queue was empty and no block time is specified (or
1754:../src/FreeRTOS/queue.c ****                      * the block time has expired) so leave now. */
1755:../src/FreeRTOS/queue.c ****                     taskEXIT_CRITICAL();
1756:../src/FreeRTOS/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
1757:../src/FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
1758:../src/FreeRTOS/queue.c ****                 }
1759:../src/FreeRTOS/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1760:../src/FreeRTOS/queue.c ****                 {
1761:../src/FreeRTOS/queue.c ****                     /* The queue was empty and a block time was specified so
1762:../src/FreeRTOS/queue.c ****                      * configure the timeout structure ready to enter the blocked
1763:../src/FreeRTOS/queue.c ****                      * state. */
1764:../src/FreeRTOS/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1765:../src/FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
1766:../src/FreeRTOS/queue.c ****                 }
1767:../src/FreeRTOS/queue.c ****                 else
1768:../src/FreeRTOS/queue.c ****                 {
1769:../src/FreeRTOS/queue.c ****                     /* Entry time was already set. */
1770:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1771:../src/FreeRTOS/queue.c ****                 }
1772:../src/FreeRTOS/queue.c ****             }
1773:../src/FreeRTOS/queue.c ****         }
1774:../src/FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
1775:../src/FreeRTOS/queue.c **** 
1776:../src/FreeRTOS/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1777:../src/FreeRTOS/queue.c ****          * now the critical section has been exited. */
1778:../src/FreeRTOS/queue.c **** 
1779:../src/FreeRTOS/queue.c ****         vTaskSuspendAll();
1780:../src/FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
1781:../src/FreeRTOS/queue.c **** 
1782:../src/FreeRTOS/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1783:../src/FreeRTOS/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1784:../src/FreeRTOS/queue.c ****         {
1785:../src/FreeRTOS/queue.c ****             /* Timeout has not expired yet, check to see if there is data in the
1786:../src/FreeRTOS/queue.c ****             * queue now, and if not enter the Blocked state to wait for data. */
1787:../src/FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1788:../src/FreeRTOS/queue.c ****             {
1789:../src/FreeRTOS/queue.c ****                 traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1790:../src/FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1791:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1792:../src/FreeRTOS/queue.c **** 
1793:../src/FreeRTOS/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1794:../src/FreeRTOS/queue.c ****                 {
1795:../src/FreeRTOS/queue.c ****                     portYIELD_WITHIN_API();
1796:../src/FreeRTOS/queue.c ****                 }
1797:../src/FreeRTOS/queue.c ****                 else
1798:../src/FreeRTOS/queue.c ****                 {
1799:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1800:../src/FreeRTOS/queue.c ****                 }
1801:../src/FreeRTOS/queue.c ****             }
1802:../src/FreeRTOS/queue.c ****             else
1803:../src/FreeRTOS/queue.c ****             {
1804:../src/FreeRTOS/queue.c ****                 /* There is data in the queue now, so don't enter the blocked
1805:../src/FreeRTOS/queue.c ****                  * state, instead return to try and obtain the data. */
1806:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1807:../src/FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
1808:../src/FreeRTOS/queue.c ****             }
1809:../src/FreeRTOS/queue.c ****         }
1810:../src/FreeRTOS/queue.c ****         else
1811:../src/FreeRTOS/queue.c ****         {
1812:../src/FreeRTOS/queue.c ****             /* The timeout has expired.  If there is still no data in the queue
1813:../src/FreeRTOS/queue.c ****              * exit, otherwise go back and try to read the data again. */
1814:../src/FreeRTOS/queue.c ****             prvUnlockQueue( pxQueue );
1815:../src/FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
1816:../src/FreeRTOS/queue.c **** 
1817:../src/FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1818:../src/FreeRTOS/queue.c ****             {
1819:../src/FreeRTOS/queue.c ****                 traceQUEUE_PEEK_FAILED( pxQueue );
1820:../src/FreeRTOS/queue.c ****                 return errQUEUE_EMPTY;
1821:../src/FreeRTOS/queue.c ****             }
1822:../src/FreeRTOS/queue.c ****             else
1823:../src/FreeRTOS/queue.c ****             {
1824:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1825:../src/FreeRTOS/queue.c ****             }
1826:../src/FreeRTOS/queue.c ****         }
1827:../src/FreeRTOS/queue.c ****     } /*lint -restore */
1828:../src/FreeRTOS/queue.c **** }
1829:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1830:../src/FreeRTOS/queue.c **** 
1831:../src/FreeRTOS/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
1832:../src/FreeRTOS/queue.c ****                                  void * const pvBuffer,
1833:../src/FreeRTOS/queue.c ****                                  BaseType_t * const pxHigherPriorityTaskWoken )
1834:../src/FreeRTOS/queue.c **** {
1835:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
1836:../src/FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1837:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1838:../src/FreeRTOS/queue.c **** 
1839:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
1840:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1841:../src/FreeRTOS/queue.c **** 
1842:../src/FreeRTOS/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1843:../src/FreeRTOS/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1844:../src/FreeRTOS/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1845:../src/FreeRTOS/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1846:../src/FreeRTOS/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1847:../src/FreeRTOS/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1848:../src/FreeRTOS/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1849:../src/FreeRTOS/queue.c ****      * assigned a priority above the configured maximum system call priority.
1850:../src/FreeRTOS/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1851:../src/FreeRTOS/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1852:../src/FreeRTOS/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1853:../src/FreeRTOS/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1854:../src/FreeRTOS/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1855:../src/FreeRTOS/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1856:../src/FreeRTOS/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1857:../src/FreeRTOS/queue.c **** 
1858:../src/FreeRTOS/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1859:../src/FreeRTOS/queue.c ****     {
1860:../src/FreeRTOS/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1861:../src/FreeRTOS/queue.c **** 
1862:../src/FreeRTOS/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
1863:../src/FreeRTOS/queue.c ****         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1864:../src/FreeRTOS/queue.c ****         {
1865:../src/FreeRTOS/queue.c ****             const int8_t cRxLock = pxQueue->cRxLock;
1866:../src/FreeRTOS/queue.c **** 
1867:../src/FreeRTOS/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1868:../src/FreeRTOS/queue.c **** 
1869:../src/FreeRTOS/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
1870:../src/FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1871:../src/FreeRTOS/queue.c **** 
1872:../src/FreeRTOS/queue.c ****             /* If the queue is locked the event list will not be modified.
1873:../src/FreeRTOS/queue.c ****              * Instead update the lock count so the task that unlocks the queue
1874:../src/FreeRTOS/queue.c ****              * will know that an ISR has removed data while the queue was
1875:../src/FreeRTOS/queue.c ****              * locked. */
1876:../src/FreeRTOS/queue.c ****             if( cRxLock == queueUNLOCKED )
1877:../src/FreeRTOS/queue.c ****             {
1878:../src/FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1879:../src/FreeRTOS/queue.c ****                 {
1880:../src/FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1881:../src/FreeRTOS/queue.c ****                     {
1882:../src/FreeRTOS/queue.c ****                         /* The task waiting has a higher priority than us so
1883:../src/FreeRTOS/queue.c ****                          * force a context switch. */
1884:../src/FreeRTOS/queue.c ****                         if( pxHigherPriorityTaskWoken != NULL )
1885:../src/FreeRTOS/queue.c ****                         {
1886:../src/FreeRTOS/queue.c ****                             *pxHigherPriorityTaskWoken = pdTRUE;
1887:../src/FreeRTOS/queue.c ****                         }
1888:../src/FreeRTOS/queue.c ****                         else
1889:../src/FreeRTOS/queue.c ****                         {
1890:../src/FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1891:../src/FreeRTOS/queue.c ****                         }
1892:../src/FreeRTOS/queue.c ****                     }
1893:../src/FreeRTOS/queue.c ****                     else
1894:../src/FreeRTOS/queue.c ****                     {
1895:../src/FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1896:../src/FreeRTOS/queue.c ****                     }
1897:../src/FreeRTOS/queue.c ****                 }
1898:../src/FreeRTOS/queue.c ****                 else
1899:../src/FreeRTOS/queue.c ****                 {
1900:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1901:../src/FreeRTOS/queue.c ****                 }
1902:../src/FreeRTOS/queue.c ****             }
1903:../src/FreeRTOS/queue.c ****             else
1904:../src/FreeRTOS/queue.c ****             {
1905:../src/FreeRTOS/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1906:../src/FreeRTOS/queue.c ****                  * knows that data was removed while it was locked. */
1907:../src/FreeRTOS/queue.c ****                 configASSERT( cRxLock != queueINT8_MAX );
1908:../src/FreeRTOS/queue.c **** 
1909:../src/FreeRTOS/queue.c ****                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
1910:../src/FreeRTOS/queue.c ****             }
1911:../src/FreeRTOS/queue.c **** 
1912:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
1913:../src/FreeRTOS/queue.c ****         }
1914:../src/FreeRTOS/queue.c ****         else
1915:../src/FreeRTOS/queue.c ****         {
1916:../src/FreeRTOS/queue.c ****             xReturn = pdFAIL;
1917:../src/FreeRTOS/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1918:../src/FreeRTOS/queue.c ****         }
1919:../src/FreeRTOS/queue.c ****     }
1920:../src/FreeRTOS/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1921:../src/FreeRTOS/queue.c **** 
1922:../src/FreeRTOS/queue.c ****     return xReturn;
1923:../src/FreeRTOS/queue.c **** }
1924:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1925:../src/FreeRTOS/queue.c **** 
1926:../src/FreeRTOS/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
1927:../src/FreeRTOS/queue.c ****                               void * const pvBuffer )
1928:../src/FreeRTOS/queue.c **** {
1929:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
1930:../src/FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1931:../src/FreeRTOS/queue.c ****     int8_t * pcOriginalReadPosition;
1932:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1933:../src/FreeRTOS/queue.c **** 
1934:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
1935:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1936:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1937:../src/FreeRTOS/queue.c **** 
1938:../src/FreeRTOS/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1939:../src/FreeRTOS/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1940:../src/FreeRTOS/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1941:../src/FreeRTOS/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1942:../src/FreeRTOS/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1943:../src/FreeRTOS/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1944:../src/FreeRTOS/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1945:../src/FreeRTOS/queue.c ****      * assigned a priority above the configured maximum system call priority.
1946:../src/FreeRTOS/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1947:../src/FreeRTOS/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1948:../src/FreeRTOS/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1949:../src/FreeRTOS/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1950:../src/FreeRTOS/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1951:../src/FreeRTOS/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1952:../src/FreeRTOS/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1953:../src/FreeRTOS/queue.c **** 
1954:../src/FreeRTOS/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1955:../src/FreeRTOS/queue.c ****     {
1956:../src/FreeRTOS/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
1957:../src/FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1958:../src/FreeRTOS/queue.c ****         {
1959:../src/FreeRTOS/queue.c ****             traceQUEUE_PEEK_FROM_ISR( pxQueue );
1960:../src/FreeRTOS/queue.c **** 
1961:../src/FreeRTOS/queue.c ****             /* Remember the read position so it can be reset as nothing is
1962:../src/FreeRTOS/queue.c ****              * actually being removed from the queue. */
1963:../src/FreeRTOS/queue.c ****             pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1964:../src/FreeRTOS/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
1965:../src/FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1966:../src/FreeRTOS/queue.c **** 
1967:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
1968:../src/FreeRTOS/queue.c ****         }
1969:../src/FreeRTOS/queue.c ****         else
1970:../src/FreeRTOS/queue.c ****         {
1971:../src/FreeRTOS/queue.c ****             xReturn = pdFAIL;
1972:../src/FreeRTOS/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1973:../src/FreeRTOS/queue.c ****         }
1974:../src/FreeRTOS/queue.c ****     }
1975:../src/FreeRTOS/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1976:../src/FreeRTOS/queue.c **** 
1977:../src/FreeRTOS/queue.c ****     return xReturn;
1978:../src/FreeRTOS/queue.c **** }
1979:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1980:../src/FreeRTOS/queue.c **** 
1981:../src/FreeRTOS/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1982:../src/FreeRTOS/queue.c **** {
1983:../src/FreeRTOS/queue.c ****     UBaseType_t uxReturn;
1984:../src/FreeRTOS/queue.c **** 
1985:../src/FreeRTOS/queue.c ****     configASSERT( xQueue );
1986:../src/FreeRTOS/queue.c **** 
1987:../src/FreeRTOS/queue.c ****     taskENTER_CRITICAL();
1988:../src/FreeRTOS/queue.c ****     {
1989:../src/FreeRTOS/queue.c ****         uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1990:../src/FreeRTOS/queue.c ****     }
1991:../src/FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
1992:../src/FreeRTOS/queue.c **** 
1993:../src/FreeRTOS/queue.c ****     return uxReturn;
1994:../src/FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1995:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1996:../src/FreeRTOS/queue.c **** 
1997:../src/FreeRTOS/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1998:../src/FreeRTOS/queue.c **** {
1999:../src/FreeRTOS/queue.c ****     UBaseType_t uxReturn;
2000:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
2001:../src/FreeRTOS/queue.c **** 
2002:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
2003:../src/FreeRTOS/queue.c **** 
2004:../src/FreeRTOS/queue.c ****     taskENTER_CRITICAL();
2005:../src/FreeRTOS/queue.c ****     {
2006:../src/FreeRTOS/queue.c ****         uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
2007:../src/FreeRTOS/queue.c ****     }
2008:../src/FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
2009:../src/FreeRTOS/queue.c **** 
2010:../src/FreeRTOS/queue.c ****     return uxReturn;
2011:../src/FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2012:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2013:../src/FreeRTOS/queue.c **** 
2014:../src/FreeRTOS/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
2015:../src/FreeRTOS/queue.c **** {
2016:../src/FreeRTOS/queue.c ****     UBaseType_t uxReturn;
2017:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
2018:../src/FreeRTOS/queue.c **** 
2019:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
2020:../src/FreeRTOS/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
2021:../src/FreeRTOS/queue.c **** 
2022:../src/FreeRTOS/queue.c ****     return uxReturn;
2023:../src/FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2024:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2025:../src/FreeRTOS/queue.c **** 
2026:../src/FreeRTOS/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
2027:../src/FreeRTOS/queue.c **** {
2028:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
2029:../src/FreeRTOS/queue.c **** 
2030:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
2031:../src/FreeRTOS/queue.c ****     traceQUEUE_DELETE( pxQueue );
2032:../src/FreeRTOS/queue.c **** 
2033:../src/FreeRTOS/queue.c ****     #if ( configQUEUE_REGISTRY_SIZE > 0 )
2034:../src/FreeRTOS/queue.c ****         {
2035:../src/FreeRTOS/queue.c ****             vQueueUnregisterQueue( pxQueue );
2036:../src/FreeRTOS/queue.c ****         }
2037:../src/FreeRTOS/queue.c ****     #endif
2038:../src/FreeRTOS/queue.c **** 
2039:../src/FreeRTOS/queue.c ****     #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
2040:../src/FreeRTOS/queue.c ****         {
2041:../src/FreeRTOS/queue.c ****             /* The queue can only have been allocated dynamically - free it
2042:../src/FreeRTOS/queue.c ****              * again. */
2043:../src/FreeRTOS/queue.c ****             vPortFree( pxQueue );
2044:../src/FreeRTOS/queue.c ****         }
2045:../src/FreeRTOS/queue.c ****     #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
2046:../src/FreeRTOS/queue.c ****         {
2047:../src/FreeRTOS/queue.c ****             /* The queue could have been allocated statically or dynamically, so
2048:../src/FreeRTOS/queue.c ****              * check before attempting to free the memory. */
2049:../src/FreeRTOS/queue.c ****             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
2050:../src/FreeRTOS/queue.c ****             {
2051:../src/FreeRTOS/queue.c ****                 vPortFree( pxQueue );
2052:../src/FreeRTOS/queue.c ****             }
2053:../src/FreeRTOS/queue.c ****             else
2054:../src/FreeRTOS/queue.c ****             {
2055:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2056:../src/FreeRTOS/queue.c ****             }
2057:../src/FreeRTOS/queue.c ****         }
2058:../src/FreeRTOS/queue.c ****     #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION ==
2059:../src/FreeRTOS/queue.c ****         {
2060:../src/FreeRTOS/queue.c ****             /* The queue must have been statically allocated, so is not going to be
2061:../src/FreeRTOS/queue.c ****              * deleted.  Avoid compiler warnings about the unused parameter. */
2062:../src/FreeRTOS/queue.c ****             ( void ) pxQueue;
2063:../src/FreeRTOS/queue.c ****         }
2064:../src/FreeRTOS/queue.c ****     #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2065:../src/FreeRTOS/queue.c **** }
2066:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2067:../src/FreeRTOS/queue.c **** 
2068:../src/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2069:../src/FreeRTOS/queue.c **** 
2070:../src/FreeRTOS/queue.c ****     UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2071:../src/FreeRTOS/queue.c ****     {
2072:../src/FreeRTOS/queue.c ****         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2073:../src/FreeRTOS/queue.c ****     }
2074:../src/FreeRTOS/queue.c **** 
2075:../src/FreeRTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2076:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2077:../src/FreeRTOS/queue.c **** 
2078:../src/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2079:../src/FreeRTOS/queue.c **** 
2080:../src/FreeRTOS/queue.c ****     void vQueueSetQueueNumber( QueueHandle_t xQueue,
2081:../src/FreeRTOS/queue.c ****                                UBaseType_t uxQueueNumber )
2082:../src/FreeRTOS/queue.c ****     {
2083:../src/FreeRTOS/queue.c ****         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2084:../src/FreeRTOS/queue.c ****     }
2085:../src/FreeRTOS/queue.c **** 
2086:../src/FreeRTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2087:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2088:../src/FreeRTOS/queue.c **** 
2089:../src/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2090:../src/FreeRTOS/queue.c **** 
2091:../src/FreeRTOS/queue.c ****     uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2092:../src/FreeRTOS/queue.c ****     {
2093:../src/FreeRTOS/queue.c ****         return ( ( Queue_t * ) xQueue )->ucQueueType;
2094:../src/FreeRTOS/queue.c ****     }
2095:../src/FreeRTOS/queue.c **** 
2096:../src/FreeRTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2097:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2098:../src/FreeRTOS/queue.c **** 
2099:../src/FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
2100:../src/FreeRTOS/queue.c **** 
2101:../src/FreeRTOS/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2102:../src/FreeRTOS/queue.c ****     {
  29              		.loc 1 2102 5 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34              		.loc 1 2102 5 is_stmt 0 view .LVU1
  35 0000 0030A0E1 		mov	r3, r0
2103:../src/FreeRTOS/queue.c ****         UBaseType_t uxHighestPriorityOfWaitingTasks;
  36              		.loc 1 2103 9 is_stmt 1 view .LVU2
2104:../src/FreeRTOS/queue.c **** 
2105:../src/FreeRTOS/queue.c ****         /* If a task waiting for a mutex causes the mutex holder to inherit a
2106:../src/FreeRTOS/queue.c ****          * priority, but the waiting task times out, then the holder should
2107:../src/FreeRTOS/queue.c ****          * disinherit the priority - but only down to the highest priority of any
2108:../src/FreeRTOS/queue.c ****          * other tasks that are waiting for the same mutex.  For this purpose,
2109:../src/FreeRTOS/queue.c ****          * return the priority of the highest priority task that is waiting for the
2110:../src/FreeRTOS/queue.c ****          * mutex. */
2111:../src/FreeRTOS/queue.c ****         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
  37              		.loc 1 2111 9 view .LVU3
  38              		.loc 1 2111 13 is_stmt 0 view .LVU4
  39 0004 240090E5 		ldr	r0, [r0, #36]
  40              	.LVL1:
  41              		.loc 1 2111 11 view .LVU5
  42 0008 000050E3 		cmp	r0, #0
  43 000c 1EFF2F01 		bxeq	lr
2112:../src/FreeRTOS/queue.c ****         {
2113:../src/FreeRTOS/queue.c ****             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t 
  44              		.loc 1 2113 13 is_stmt 1 view .LVU6
  45              		.loc 1 2113 102 is_stmt 0 view .LVU7
  46 0010 303093E5 		ldr	r3, [r3, #48]
  47              	.LVL2:
  48              		.loc 1 2113 102 view .LVU8
  49 0014 000093E5 		ldr	r0, [r3]
  50              		.loc 1 2113 45 view .LVU9
  51 0018 140060E2 		rsb	r0, r0, #20
  52              	.LVL3:
2114:../src/FreeRTOS/queue.c ****         }
2115:../src/FreeRTOS/queue.c ****         else
2116:../src/FreeRTOS/queue.c ****         {
2117:../src/FreeRTOS/queue.c ****             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2118:../src/FreeRTOS/queue.c ****         }
2119:../src/FreeRTOS/queue.c **** 
2120:../src/FreeRTOS/queue.c ****         return uxHighestPriorityOfWaitingTasks;
  53              		.loc 1 2120 9 is_stmt 1 view .LVU10
2121:../src/FreeRTOS/queue.c ****     }
  54              		.loc 1 2121 5 is_stmt 0 view .LVU11
  55 001c 1EFF2FE1 		bx	lr
  56              		.cfi_endproc
  57              	.LFE25:
  59              		.section	.text.prvIsQueueFull,"ax",%progbits
  60              		.align	2
  61              		.syntax unified
  62              		.arm
  63              		.fpu neon
  65              	prvIsQueueFull:
  66              	.LVL4:
  67              	.LFB31:
2122:../src/FreeRTOS/queue.c **** 
2123:../src/FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
2124:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2125:../src/FreeRTOS/queue.c **** 
2126:../src/FreeRTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
2127:../src/FreeRTOS/queue.c ****                                       const void * pvItemToQueue,
2128:../src/FreeRTOS/queue.c ****                                       const BaseType_t xPosition )
2129:../src/FreeRTOS/queue.c **** {
2130:../src/FreeRTOS/queue.c ****     BaseType_t xReturn = pdFALSE;
2131:../src/FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
2132:../src/FreeRTOS/queue.c **** 
2133:../src/FreeRTOS/queue.c ****     /* This function is called from a critical section. */
2134:../src/FreeRTOS/queue.c **** 
2135:../src/FreeRTOS/queue.c ****     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2136:../src/FreeRTOS/queue.c **** 
2137:../src/FreeRTOS/queue.c ****     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2138:../src/FreeRTOS/queue.c ****     {
2139:../src/FreeRTOS/queue.c ****         #if ( configUSE_MUTEXES == 1 )
2140:../src/FreeRTOS/queue.c ****             {
2141:../src/FreeRTOS/queue.c ****                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2142:../src/FreeRTOS/queue.c ****                 {
2143:../src/FreeRTOS/queue.c ****                     /* The mutex is no longer being held. */
2144:../src/FreeRTOS/queue.c ****                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2145:../src/FreeRTOS/queue.c ****                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
2146:../src/FreeRTOS/queue.c ****                 }
2147:../src/FreeRTOS/queue.c ****                 else
2148:../src/FreeRTOS/queue.c ****                 {
2149:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2150:../src/FreeRTOS/queue.c ****                 }
2151:../src/FreeRTOS/queue.c ****             }
2152:../src/FreeRTOS/queue.c ****         #endif /* configUSE_MUTEXES */
2153:../src/FreeRTOS/queue.c ****     }
2154:../src/FreeRTOS/queue.c ****     else if( xPosition == queueSEND_TO_BACK )
2155:../src/FreeRTOS/queue.c ****     {
2156:../src/FreeRTOS/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSi
2157:../src/FreeRTOS/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
2158:../src/FreeRTOS/queue.c **** 
2159:../src/FreeRTOS/queue.c ****         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                       
2160:../src/FreeRTOS/queue.c ****         {
2161:../src/FreeRTOS/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
2162:../src/FreeRTOS/queue.c ****         }
2163:../src/FreeRTOS/queue.c ****         else
2164:../src/FreeRTOS/queue.c ****         {
2165:../src/FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2166:../src/FreeRTOS/queue.c ****         }
2167:../src/FreeRTOS/queue.c ****     }
2168:../src/FreeRTOS/queue.c ****     else
2169:../src/FreeRTOS/queue.c ****     {
2170:../src/FreeRTOS/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue
2171:../src/FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
2172:../src/FreeRTOS/queue.c **** 
2173:../src/FreeRTOS/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified
2174:../src/FreeRTOS/queue.c ****         {
2175:../src/FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
2176:../src/FreeRTOS/queue.c ****         }
2177:../src/FreeRTOS/queue.c ****         else
2178:../src/FreeRTOS/queue.c ****         {
2179:../src/FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2180:../src/FreeRTOS/queue.c ****         }
2181:../src/FreeRTOS/queue.c **** 
2182:../src/FreeRTOS/queue.c ****         if( xPosition == queueOVERWRITE )
2183:../src/FreeRTOS/queue.c ****         {
2184:../src/FreeRTOS/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2185:../src/FreeRTOS/queue.c ****             {
2186:../src/FreeRTOS/queue.c ****                 /* An item is not being added but overwritten, so subtract
2187:../src/FreeRTOS/queue.c ****                  * one from the recorded number of items in the queue so when
2188:../src/FreeRTOS/queue.c ****                  * one is added again below the number of recorded items remains
2189:../src/FreeRTOS/queue.c ****                  * correct. */
2190:../src/FreeRTOS/queue.c ****                 --uxMessagesWaiting;
2191:../src/FreeRTOS/queue.c ****             }
2192:../src/FreeRTOS/queue.c ****             else
2193:../src/FreeRTOS/queue.c ****             {
2194:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2195:../src/FreeRTOS/queue.c ****             }
2196:../src/FreeRTOS/queue.c ****         }
2197:../src/FreeRTOS/queue.c ****         else
2198:../src/FreeRTOS/queue.c ****         {
2199:../src/FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2200:../src/FreeRTOS/queue.c ****         }
2201:../src/FreeRTOS/queue.c ****     }
2202:../src/FreeRTOS/queue.c **** 
2203:../src/FreeRTOS/queue.c ****     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2204:../src/FreeRTOS/queue.c **** 
2205:../src/FreeRTOS/queue.c ****     return xReturn;
2206:../src/FreeRTOS/queue.c **** }
2207:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2208:../src/FreeRTOS/queue.c **** 
2209:../src/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
2210:../src/FreeRTOS/queue.c ****                                   void * const pvBuffer )
2211:../src/FreeRTOS/queue.c **** {
2212:../src/FreeRTOS/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2213:../src/FreeRTOS/queue.c ****     {
2214:../src/FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithm
2215:../src/FreeRTOS/queue.c **** 
2216:../src/FreeRTOS/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception
2217:../src/FreeRTOS/queue.c ****         {
2218:../src/FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2219:../src/FreeRTOS/queue.c ****         }
2220:../src/FreeRTOS/queue.c ****         else
2221:../src/FreeRTOS/queue.c ****         {
2222:../src/FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2223:../src/FreeRTOS/queue.c ****         }
2224:../src/FreeRTOS/queue.c **** 
2225:../src/FreeRTOS/queue.c ****         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) p
2226:../src/FreeRTOS/queue.c ****     }
2227:../src/FreeRTOS/queue.c **** }
2228:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2229:../src/FreeRTOS/queue.c **** 
2230:../src/FreeRTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2231:../src/FreeRTOS/queue.c **** {
2232:../src/FreeRTOS/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2233:../src/FreeRTOS/queue.c **** 
2234:../src/FreeRTOS/queue.c ****     /* The lock counts contains the number of extra data items placed or
2235:../src/FreeRTOS/queue.c ****      * removed from the queue while the queue was locked.  When a queue is
2236:../src/FreeRTOS/queue.c ****      * locked items can be added or removed, but the event lists cannot be
2237:../src/FreeRTOS/queue.c ****      * updated. */
2238:../src/FreeRTOS/queue.c ****     taskENTER_CRITICAL();
2239:../src/FreeRTOS/queue.c ****     {
2240:../src/FreeRTOS/queue.c ****         int8_t cTxLock = pxQueue->cTxLock;
2241:../src/FreeRTOS/queue.c **** 
2242:../src/FreeRTOS/queue.c ****         /* See if data was added to the queue while it was locked. */
2243:../src/FreeRTOS/queue.c ****         while( cTxLock > queueLOCKED_UNMODIFIED )
2244:../src/FreeRTOS/queue.c ****         {
2245:../src/FreeRTOS/queue.c ****             /* Data was posted while the queue was locked.  Are any tasks
2246:../src/FreeRTOS/queue.c ****              * blocked waiting for data to become available? */
2247:../src/FreeRTOS/queue.c ****             #if ( configUSE_QUEUE_SETS == 1 )
2248:../src/FreeRTOS/queue.c ****                 {
2249:../src/FreeRTOS/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
2250:../src/FreeRTOS/queue.c ****                     {
2251:../src/FreeRTOS/queue.c ****                         if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2252:../src/FreeRTOS/queue.c ****                         {
2253:../src/FreeRTOS/queue.c ****                             /* The queue is a member of a queue set, and posting to
2254:../src/FreeRTOS/queue.c ****                              * the queue set caused a higher priority task to unblock.
2255:../src/FreeRTOS/queue.c ****                              * A context switch is required. */
2256:../src/FreeRTOS/queue.c ****                             vTaskMissedYield();
2257:../src/FreeRTOS/queue.c ****                         }
2258:../src/FreeRTOS/queue.c ****                         else
2259:../src/FreeRTOS/queue.c ****                         {
2260:../src/FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
2261:../src/FreeRTOS/queue.c ****                         }
2262:../src/FreeRTOS/queue.c ****                     }
2263:../src/FreeRTOS/queue.c ****                     else
2264:../src/FreeRTOS/queue.c ****                     {
2265:../src/FreeRTOS/queue.c ****                         /* Tasks that are removed from the event list will get
2266:../src/FreeRTOS/queue.c ****                          * added to the pending ready list as the scheduler is still
2267:../src/FreeRTOS/queue.c ****                          * suspended. */
2268:../src/FreeRTOS/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2269:../src/FreeRTOS/queue.c ****                         {
2270:../src/FreeRTOS/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
2271:../src/FreeRTOS/queue.c ****                             {
2272:../src/FreeRTOS/queue.c ****                                 /* The task waiting has a higher priority so record that a
2273:../src/FreeRTOS/queue.c ****                                  * context switch is required. */
2274:../src/FreeRTOS/queue.c ****                                 vTaskMissedYield();
2275:../src/FreeRTOS/queue.c ****                             }
2276:../src/FreeRTOS/queue.c ****                             else
2277:../src/FreeRTOS/queue.c ****                             {
2278:../src/FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
2279:../src/FreeRTOS/queue.c ****                             }
2280:../src/FreeRTOS/queue.c ****                         }
2281:../src/FreeRTOS/queue.c ****                         else
2282:../src/FreeRTOS/queue.c ****                         {
2283:../src/FreeRTOS/queue.c ****                             break;
2284:../src/FreeRTOS/queue.c ****                         }
2285:../src/FreeRTOS/queue.c ****                     }
2286:../src/FreeRTOS/queue.c ****                 }
2287:../src/FreeRTOS/queue.c ****             #else /* configUSE_QUEUE_SETS */
2288:../src/FreeRTOS/queue.c ****                 {
2289:../src/FreeRTOS/queue.c ****                     /* Tasks that are removed from the event list will get added to
2290:../src/FreeRTOS/queue.c ****                      * the pending ready list as the scheduler is still suspended. */
2291:../src/FreeRTOS/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2292:../src/FreeRTOS/queue.c ****                     {
2293:../src/FreeRTOS/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
2294:../src/FreeRTOS/queue.c ****                         {
2295:../src/FreeRTOS/queue.c ****                             /* The task waiting has a higher priority so record that
2296:../src/FreeRTOS/queue.c ****                              * a context switch is required. */
2297:../src/FreeRTOS/queue.c ****                             vTaskMissedYield();
2298:../src/FreeRTOS/queue.c ****                         }
2299:../src/FreeRTOS/queue.c ****                         else
2300:../src/FreeRTOS/queue.c ****                         {
2301:../src/FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
2302:../src/FreeRTOS/queue.c ****                         }
2303:../src/FreeRTOS/queue.c ****                     }
2304:../src/FreeRTOS/queue.c ****                     else
2305:../src/FreeRTOS/queue.c ****                     {
2306:../src/FreeRTOS/queue.c ****                         break;
2307:../src/FreeRTOS/queue.c ****                     }
2308:../src/FreeRTOS/queue.c ****                 }
2309:../src/FreeRTOS/queue.c ****             #endif /* configUSE_QUEUE_SETS */
2310:../src/FreeRTOS/queue.c **** 
2311:../src/FreeRTOS/queue.c ****             --cTxLock;
2312:../src/FreeRTOS/queue.c ****         }
2313:../src/FreeRTOS/queue.c **** 
2314:../src/FreeRTOS/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
2315:../src/FreeRTOS/queue.c ****     }
2316:../src/FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
2317:../src/FreeRTOS/queue.c **** 
2318:../src/FreeRTOS/queue.c ****     /* Do the same for the Rx lock. */
2319:../src/FreeRTOS/queue.c ****     taskENTER_CRITICAL();
2320:../src/FreeRTOS/queue.c ****     {
2321:../src/FreeRTOS/queue.c ****         int8_t cRxLock = pxQueue->cRxLock;
2322:../src/FreeRTOS/queue.c **** 
2323:../src/FreeRTOS/queue.c ****         while( cRxLock > queueLOCKED_UNMODIFIED )
2324:../src/FreeRTOS/queue.c ****         {
2325:../src/FreeRTOS/queue.c ****             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2326:../src/FreeRTOS/queue.c ****             {
2327:../src/FreeRTOS/queue.c ****                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2328:../src/FreeRTOS/queue.c ****                 {
2329:../src/FreeRTOS/queue.c ****                     vTaskMissedYield();
2330:../src/FreeRTOS/queue.c ****                 }
2331:../src/FreeRTOS/queue.c ****                 else
2332:../src/FreeRTOS/queue.c ****                 {
2333:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2334:../src/FreeRTOS/queue.c ****                 }
2335:../src/FreeRTOS/queue.c **** 
2336:../src/FreeRTOS/queue.c ****                 --cRxLock;
2337:../src/FreeRTOS/queue.c ****             }
2338:../src/FreeRTOS/queue.c ****             else
2339:../src/FreeRTOS/queue.c ****             {
2340:../src/FreeRTOS/queue.c ****                 break;
2341:../src/FreeRTOS/queue.c ****             }
2342:../src/FreeRTOS/queue.c ****         }
2343:../src/FreeRTOS/queue.c **** 
2344:../src/FreeRTOS/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
2345:../src/FreeRTOS/queue.c ****     }
2346:../src/FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
2347:../src/FreeRTOS/queue.c **** }
2348:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2349:../src/FreeRTOS/queue.c **** 
2350:../src/FreeRTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
2351:../src/FreeRTOS/queue.c **** {
2352:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
2353:../src/FreeRTOS/queue.c **** 
2354:../src/FreeRTOS/queue.c ****     taskENTER_CRITICAL();
2355:../src/FreeRTOS/queue.c ****     {
2356:../src/FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2357:../src/FreeRTOS/queue.c ****         {
2358:../src/FreeRTOS/queue.c ****             xReturn = pdTRUE;
2359:../src/FreeRTOS/queue.c ****         }
2360:../src/FreeRTOS/queue.c ****         else
2361:../src/FreeRTOS/queue.c ****         {
2362:../src/FreeRTOS/queue.c ****             xReturn = pdFALSE;
2363:../src/FreeRTOS/queue.c ****         }
2364:../src/FreeRTOS/queue.c ****     }
2365:../src/FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
2366:../src/FreeRTOS/queue.c **** 
2367:../src/FreeRTOS/queue.c ****     return xReturn;
2368:../src/FreeRTOS/queue.c **** }
2369:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2370:../src/FreeRTOS/queue.c **** 
2371:../src/FreeRTOS/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2372:../src/FreeRTOS/queue.c **** {
2373:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
2374:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
2375:../src/FreeRTOS/queue.c **** 
2376:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
2377:../src/FreeRTOS/queue.c **** 
2378:../src/FreeRTOS/queue.c ****     if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2379:../src/FreeRTOS/queue.c ****     {
2380:../src/FreeRTOS/queue.c ****         xReturn = pdTRUE;
2381:../src/FreeRTOS/queue.c ****     }
2382:../src/FreeRTOS/queue.c ****     else
2383:../src/FreeRTOS/queue.c ****     {
2384:../src/FreeRTOS/queue.c ****         xReturn = pdFALSE;
2385:../src/FreeRTOS/queue.c ****     }
2386:../src/FreeRTOS/queue.c **** 
2387:../src/FreeRTOS/queue.c ****     return xReturn;
2388:../src/FreeRTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2389:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2390:../src/FreeRTOS/queue.c **** 
2391:../src/FreeRTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
2392:../src/FreeRTOS/queue.c **** {
  68              		.loc 1 2392 1 is_stmt 1 view -0
  69              		.cfi_startproc
  70              		@ args = 0, pretend = 0, frame = 0
  71              		@ frame_needed = 0, uses_anonymous_args = 0
  72              		.loc 1 2392 1 is_stmt 0 view .LVU13
  73 0000 10402DE9 		push	{r4, lr}
  74              		.cfi_def_cfa_offset 8
  75              		.cfi_offset 4, -8
  76              		.cfi_offset 14, -4
  77 0004 0040A0E1 		mov	r4, r0
2393:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
  78              		.loc 1 2393 5 is_stmt 1 view .LVU14
2394:../src/FreeRTOS/queue.c **** 
2395:../src/FreeRTOS/queue.c ****     taskENTER_CRITICAL();
  79              		.loc 1 2395 5 view .LVU15
  80 0008 FEFFFFEB 		bl	vPortEnterCritical
  81              	.LVL5:
  82              		.loc 1 2395 25 view .LVU16
2396:../src/FreeRTOS/queue.c ****     {
2397:../src/FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  83              		.loc 1 2397 9 view .LVU17
  84              		.loc 1 2397 20 is_stmt 0 view .LVU18
  85 000c 382094E5 		ldr	r2, [r4, #56]
  86              		.loc 1 2397 50 view .LVU19
  87 0010 3C3094E5 		ldr	r3, [r4, #60]
  88              		.loc 1 2397 11 view .LVU20
  89 0014 030052E1 		cmp	r2, r3
  90 0018 0300000A 		beq	.L7
2398:../src/FreeRTOS/queue.c ****         {
2399:../src/FreeRTOS/queue.c ****             xReturn = pdTRUE;
2400:../src/FreeRTOS/queue.c ****         }
2401:../src/FreeRTOS/queue.c ****         else
2402:../src/FreeRTOS/queue.c ****         {
2403:../src/FreeRTOS/queue.c ****             xReturn = pdFALSE;
  91              		.loc 1 2403 21 view .LVU21
  92 001c 0040A0E3 		mov	r4, #0
  93              	.LVL6:
  94              	.L4:
2404:../src/FreeRTOS/queue.c ****         }
2405:../src/FreeRTOS/queue.c ****     }
2406:../src/FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
  95              		.loc 1 2406 5 is_stmt 1 view .LVU22
  96 0020 FEFFFFEB 		bl	vPortExitCritical
  97              	.LVL7:
  98              		.loc 1 2406 24 view .LVU23
2407:../src/FreeRTOS/queue.c **** 
2408:../src/FreeRTOS/queue.c ****     return xReturn;
  99              		.loc 1 2408 5 view .LVU24
2409:../src/FreeRTOS/queue.c **** }
 100              		.loc 1 2409 1 is_stmt 0 view .LVU25
 101 0024 0400A0E1 		mov	r0, r4
 102 0028 1080BDE8 		pop	{r4, pc}
 103              	.LVL8:
 104              	.L7:
2399:../src/FreeRTOS/queue.c ****         }
 105              		.loc 1 2399 21 view .LVU26
 106 002c 0140A0E3 		mov	r4, #1
 107              	.LVL9:
2399:../src/FreeRTOS/queue.c ****         }
 108              		.loc 1 2399 21 view .LVU27
 109 0030 FAFFFFEA 		b	.L4
 110              		.cfi_endproc
 111              	.LFE31:
 113              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 114              		.align	2
 115              		.syntax unified
 116              		.arm
 117              		.fpu neon
 119              	prvIsQueueEmpty:
 120              	.LVL10:
 121              	.LFB29:
2351:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 122              		.loc 1 2351 1 is_stmt 1 view -0
 123              		.cfi_startproc
 124              		@ args = 0, pretend = 0, frame = 0
 125              		@ frame_needed = 0, uses_anonymous_args = 0
2351:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 126              		.loc 1 2351 1 is_stmt 0 view .LVU29
 127 0000 10402DE9 		push	{r4, lr}
 128              		.cfi_def_cfa_offset 8
 129              		.cfi_offset 4, -8
 130              		.cfi_offset 14, -4
 131 0004 0040A0E1 		mov	r4, r0
2352:../src/FreeRTOS/queue.c **** 
 132              		.loc 1 2352 5 is_stmt 1 view .LVU30
2354:../src/FreeRTOS/queue.c ****     {
 133              		.loc 1 2354 5 view .LVU31
 134 0008 FEFFFFEB 		bl	vPortEnterCritical
 135              	.LVL11:
2354:../src/FreeRTOS/queue.c ****     {
 136              		.loc 1 2354 25 view .LVU32
2356:../src/FreeRTOS/queue.c ****         {
 137              		.loc 1 2356 9 view .LVU33
2356:../src/FreeRTOS/queue.c ****         {
 138              		.loc 1 2356 20 is_stmt 0 view .LVU34
 139 000c 383094E5 		ldr	r3, [r4, #56]
2356:../src/FreeRTOS/queue.c ****         {
 140              		.loc 1 2356 11 view .LVU35
 141 0010 000053E3 		cmp	r3, #0
 142 0014 0300001A 		bne	.L10
2358:../src/FreeRTOS/queue.c ****         }
 143              		.loc 1 2358 21 view .LVU36
 144 0018 0140A0E3 		mov	r4, #1
 145              	.LVL12:
 146              	.L9:
2365:../src/FreeRTOS/queue.c **** 
 147              		.loc 1 2365 5 is_stmt 1 view .LVU37
 148 001c FEFFFFEB 		bl	vPortExitCritical
 149              	.LVL13:
2365:../src/FreeRTOS/queue.c **** 
 150              		.loc 1 2365 24 view .LVU38
2367:../src/FreeRTOS/queue.c **** }
 151              		.loc 1 2367 5 view .LVU39
2368:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 152              		.loc 1 2368 1 is_stmt 0 view .LVU40
 153 0020 0400A0E1 		mov	r0, r4
 154 0024 1080BDE8 		pop	{r4, pc}
 155              	.LVL14:
 156              	.L10:
2362:../src/FreeRTOS/queue.c ****         }
 157              		.loc 1 2362 21 view .LVU41
 158 0028 0040A0E3 		mov	r4, #0
 159              	.LVL15:
2362:../src/FreeRTOS/queue.c ****         }
 160              		.loc 1 2362 21 view .LVU42
 161 002c FAFFFFEA 		b	.L9
 162              		.cfi_endproc
 163              	.LFE29:
 165              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 166              		.align	2
 167              		.syntax unified
 168              		.arm
 169              		.fpu neon
 171              	prvCopyDataToQueue:
 172              	.LVL16:
 173              	.LFB26:
2129:../src/FreeRTOS/queue.c ****     BaseType_t xReturn = pdFALSE;
 174              		.loc 1 2129 1 is_stmt 1 view -0
 175              		.cfi_startproc
 176              		@ args = 0, pretend = 0, frame = 0
 177              		@ frame_needed = 0, uses_anonymous_args = 0
2129:../src/FreeRTOS/queue.c ****     BaseType_t xReturn = pdFALSE;
 178              		.loc 1 2129 1 is_stmt 0 view .LVU44
 179 0000 70402DE9 		push	{r4, r5, r6, lr}
 180              		.cfi_def_cfa_offset 16
 181              		.cfi_offset 4, -16
 182              		.cfi_offset 5, -12
 183              		.cfi_offset 6, -8
 184              		.cfi_offset 14, -4
 185 0004 0040A0E1 		mov	r4, r0
 186 0008 0250A0E1 		mov	r5, r2
2130:../src/FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 187              		.loc 1 2130 5 is_stmt 1 view .LVU45
 188              	.LVL17:
2131:../src/FreeRTOS/queue.c **** 
 189              		.loc 1 2131 5 view .LVU46
2135:../src/FreeRTOS/queue.c **** 
 190              		.loc 1 2135 5 view .LVU47
2135:../src/FreeRTOS/queue.c **** 
 191              		.loc 1 2135 23 is_stmt 0 view .LVU48
 192 000c 386090E5 		ldr	r6, [r0, #56]
 193              	.LVL18:
2137:../src/FreeRTOS/queue.c ****     {
 194              		.loc 1 2137 5 is_stmt 1 view .LVU49
2137:../src/FreeRTOS/queue.c ****     {
 195              		.loc 1 2137 16 is_stmt 0 view .LVU50
 196 0010 402090E5 		ldr	r2, [r0, #64]
 197              	.LVL19:
2137:../src/FreeRTOS/queue.c ****     {
 198              		.loc 1 2137 7 view .LVU51
 199 0014 000052E3 		cmp	r2, #0
 200 0018 0B00001A 		bne	.L13
2141:../src/FreeRTOS/queue.c ****                 {
 201              		.loc 1 2141 17 is_stmt 1 view .LVU52
2141:../src/FreeRTOS/queue.c ****                 {
 202              		.loc 1 2141 28 is_stmt 0 view .LVU53
 203 001c 003090E5 		ldr	r3, [r0]
2141:../src/FreeRTOS/queue.c ****                 {
 204              		.loc 1 2141 19 view .LVU54
 205 0020 000053E3 		cmp	r3, #0
 206 0024 0300000A 		beq	.L22
2130:../src/FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 207              		.loc 1 2130 16 view .LVU55
 208 0028 0000A0E3 		mov	r0, #0
 209              	.LVL20:
 210              	.L14:
2199:../src/FreeRTOS/queue.c ****         }
 211              		.loc 1 2199 37 is_stmt 1 view .LVU56
2203:../src/FreeRTOS/queue.c **** 
 212              		.loc 1 2203 5 view .LVU57
2203:../src/FreeRTOS/queue.c **** 
 213              		.loc 1 2203 52 is_stmt 0 view .LVU58
 214 002c 013086E2 		add	r3, r6, #1
2203:../src/FreeRTOS/queue.c **** 
 215              		.loc 1 2203 32 view .LVU59
 216 0030 383084E5 		str	r3, [r4, #56]
2205:../src/FreeRTOS/queue.c **** }
 217              		.loc 1 2205 5 is_stmt 1 view .LVU60
2206:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 218              		.loc 1 2206 1 is_stmt 0 view .LVU61
 219 0034 7080BDE8 		pop	{r4, r5, r6, pc}
 220              	.LVL21:
 221              	.L22:
2144:../src/FreeRTOS/queue.c ****                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
 222              		.loc 1 2144 21 is_stmt 1 view .LVU62
2144:../src/FreeRTOS/queue.c ****                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
 223              		.loc 1 2144 31 is_stmt 0 view .LVU63
 224 0038 080090E5 		ldr	r0, [r0, #8]
 225              	.LVL22:
2144:../src/FreeRTOS/queue.c ****                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
 226              		.loc 1 2144 31 view .LVU64
 227 003c FEFFFFEB 		bl	xTaskPriorityDisinherit
 228              	.LVL23:
2145:../src/FreeRTOS/queue.c ****                 }
 229              		.loc 1 2145 21 is_stmt 1 view .LVU65
2145:../src/FreeRTOS/queue.c ****                 }
 230              		.loc 1 2145 56 is_stmt 0 view .LVU66
 231 0040 0030A0E3 		mov	r3, #0
 232 0044 083084E5 		str	r3, [r4, #8]
 233 0048 F7FFFFEA 		b	.L14
 234              	.LVL24:
 235              	.L13:
2154:../src/FreeRTOS/queue.c ****     {
 236              		.loc 1 2154 10 is_stmt 1 view .LVU67
2154:../src/FreeRTOS/queue.c ****     {
 237              		.loc 1 2154 12 is_stmt 0 view .LVU68
 238 004c 000055E3 		cmp	r5, #0
 239 0050 0C00001A 		bne	.L15
2156:../src/FreeRTOS/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 240              		.loc 1 2156 9 is_stmt 1 view .LVU69
2156:../src/FreeRTOS/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 241              		.loc 1 2156 18 is_stmt 0 view .LVU70
 242 0054 040090E5 		ldr	r0, [r0, #4]
 243              	.LVL25:
2156:../src/FreeRTOS/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 244              		.loc 1 2156 18 view .LVU71
 245 0058 FEFFFFEB 		bl	memcpy
 246              	.LVL26:
2157:../src/FreeRTOS/queue.c **** 
 247              		.loc 1 2157 9 is_stmt 1 view .LVU72
2157:../src/FreeRTOS/queue.c **** 
 248              		.loc 1 2157 38 is_stmt 0 view .LVU73
 249 005c 402094E5 		ldr	r2, [r4, #64]
2157:../src/FreeRTOS/queue.c **** 
 250              		.loc 1 2157 28 view .LVU74
 251 0060 043094E5 		ldr	r3, [r4, #4]
 252 0064 023083E0 		add	r3, r3, r2
 253 0068 043084E5 		str	r3, [r4, #4]
2159:../src/FreeRTOS/queue.c ****         {
 254              		.loc 1 2159 9 is_stmt 1 view .LVU75
2159:../src/FreeRTOS/queue.c ****         {
 255              		.loc 1 2159 52 is_stmt 0 view .LVU76
 256 006c 082094E5 		ldr	r2, [r4, #8]
2159:../src/FreeRTOS/queue.c ****         {
 257              		.loc 1 2159 11 view .LVU77
 258 0070 020053E1 		cmp	r3, r2
 259 0074 1700003A 		bcc	.L18
2161:../src/FreeRTOS/queue.c ****         }
 260              		.loc 1 2161 13 is_stmt 1 view .LVU78
2161:../src/FreeRTOS/queue.c ****         }
 261              		.loc 1 2161 41 is_stmt 0 view .LVU79
 262 0078 003094E5 		ldr	r3, [r4]
2161:../src/FreeRTOS/queue.c ****         }
 263              		.loc 1 2161 32 view .LVU80
 264 007c 043084E5 		str	r3, [r4, #4]
2130:../src/FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 265              		.loc 1 2130 16 view .LVU81
 266 0080 0500A0E1 		mov	r0, r5
 267 0084 E8FFFFEA 		b	.L14
 268              	.LVL27:
 269              	.L15:
2170:../src/FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 270              		.loc 1 2170 9 is_stmt 1 view .LVU82
2170:../src/FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 271              		.loc 1 2170 18 is_stmt 0 view .LVU83
 272 0088 0C0090E5 		ldr	r0, [r0, #12]
 273              	.LVL28:
2170:../src/FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 274              		.loc 1 2170 18 view .LVU84
 275 008c FEFFFFEB 		bl	memcpy
 276              	.LVL29:
2171:../src/FreeRTOS/queue.c **** 
 277              		.loc 1 2171 9 is_stmt 1 view .LVU85
2171:../src/FreeRTOS/queue.c **** 
 278              		.loc 1 2171 48 is_stmt 0 view .LVU86
 279 0090 402094E5 		ldr	r2, [r4, #64]
2171:../src/FreeRTOS/queue.c **** 
 280              		.loc 1 2171 38 view .LVU87
 281 0094 001062E2 		rsb	r1, r2, #0
 282 0098 0C3094E5 		ldr	r3, [r4, #12]
 283 009c 023043E0 		sub	r3, r3, r2
 284 00a0 0C3084E5 		str	r3, [r4, #12]
2173:../src/FreeRTOS/queue.c ****         {
 285              		.loc 1 2173 9 is_stmt 1 view .LVU88
2173:../src/FreeRTOS/queue.c ****         {
 286              		.loc 1 2173 51 is_stmt 0 view .LVU89
 287 00a4 002094E5 		ldr	r2, [r4]
2173:../src/FreeRTOS/queue.c ****         {
 288              		.loc 1 2173 11 view .LVU90
 289 00a8 020053E1 		cmp	r3, r2
2175:../src/FreeRTOS/queue.c ****         }
 290              		.loc 1 2175 13 is_stmt 1 view .LVU91
2175:../src/FreeRTOS/queue.c ****         }
 291              		.loc 1 2175 63 is_stmt 0 view .LVU92
 292 00ac 08309435 		ldrcc	r3, [r4, #8]
2175:../src/FreeRTOS/queue.c ****         }
 293              		.loc 1 2175 71 view .LVU93
 294 00b0 01308330 		addcc	r3, r3, r1
2175:../src/FreeRTOS/queue.c ****         }
 295              		.loc 1 2175 42 view .LVU94
 296 00b4 0C308435 		strcc	r3, [r4, #12]
 297              	.L16:
2179:../src/FreeRTOS/queue.c ****         }
 298              		.loc 1 2179 37 is_stmt 1 view .LVU95
2182:../src/FreeRTOS/queue.c ****         {
 299              		.loc 1 2182 9 view .LVU96
2182:../src/FreeRTOS/queue.c ****         {
 300              		.loc 1 2182 11 is_stmt 0 view .LVU97
 301 00b8 020055E3 		cmp	r5, #2
2130:../src/FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 302              		.loc 1 2130 16 view .LVU98
 303 00bc 0000A013 		movne	r0, #0
 304 00c0 D9FFFF1A 		bne	.L14
 305              	.L23:
2184:../src/FreeRTOS/queue.c ****             {
 306              		.loc 1 2184 13 is_stmt 1 view .LVU99
2184:../src/FreeRTOS/queue.c ****             {
 307              		.loc 1 2184 15 is_stmt 0 view .LVU100
 308 00c4 000056E3 		cmp	r6, #0
 309 00c8 0400000A 		beq	.L20
2190:../src/FreeRTOS/queue.c ****             }
 310              		.loc 1 2190 17 is_stmt 1 view .LVU101
 311 00cc 016046E2 		sub	r6, r6, #1
 312              	.LVL30:
2130:../src/FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 313              		.loc 1 2130 16 is_stmt 0 view .LVU102
 314 00d0 0000A0E3 		mov	r0, #0
 315 00d4 D4FFFFEA 		b	.L14
 316              	.L18:
2130:../src/FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 317              		.loc 1 2130 16 view .LVU103
 318 00d8 0500A0E1 		mov	r0, r5
 319 00dc D2FFFFEA 		b	.L14
 320              	.L20:
2130:../src/FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 321              		.loc 1 2130 16 view .LVU104
 322 00e0 0000A0E3 		mov	r0, #0
 323 00e4 D0FFFFEA 		b	.L14
 324              		.cfi_endproc
 325              	.LFE26:
 327              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 328              		.align	2
 329              		.syntax unified
 330              		.arm
 331              		.fpu neon
 333              	prvCopyDataFromQueue:
 334              	.LVL31:
 335              	.LFB27:
2211:../src/FreeRTOS/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 336              		.loc 1 2211 1 is_stmt 1 view -0
 337              		.cfi_startproc
 338              		@ args = 0, pretend = 0, frame = 0
 339              		@ frame_needed = 0, uses_anonymous_args = 0
2211:../src/FreeRTOS/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 340              		.loc 1 2211 1 is_stmt 0 view .LVU106
 341 0000 0030A0E1 		mov	r3, r0
2212:../src/FreeRTOS/queue.c ****     {
 342              		.loc 1 2212 5 is_stmt 1 view .LVU107
2212:../src/FreeRTOS/queue.c ****     {
 343              		.loc 1 2212 16 is_stmt 0 view .LVU108
 344 0004 402090E5 		ldr	r2, [r0, #64]
2212:../src/FreeRTOS/queue.c ****     {
 345              		.loc 1 2212 7 view .LVU109
 346 0008 000052E3 		cmp	r2, #0
 347 000c 1EFF2F01 		bxeq	lr
2211:../src/FreeRTOS/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 348              		.loc 1 2211 1 view .LVU110
 349 0010 10402DE9 		push	{r4, lr}
 350              		.cfi_def_cfa_offset 8
 351              		.cfi_offset 4, -8
 352              		.cfi_offset 14, -4
 353 0014 0100A0E1 		mov	r0, r1
 354              	.LVL32:
2214:../src/FreeRTOS/queue.c **** 
 355              		.loc 1 2214 9 is_stmt 1 view .LVU111
2214:../src/FreeRTOS/queue.c **** 
 356              		.loc 1 2214 38 is_stmt 0 view .LVU112
 357 0018 0C1093E5 		ldr	r1, [r3, #12]
 358              	.LVL33:
2214:../src/FreeRTOS/queue.c **** 
 359              		.loc 1 2214 38 view .LVU113
 360 001c 021081E0 		add	r1, r1, r2
 361 0020 0C1083E5 		str	r1, [r3, #12]
2216:../src/FreeRTOS/queue.c ****         {
 362              		.loc 1 2216 9 is_stmt 1 view .LVU114
2216:../src/FreeRTOS/queue.c ****         {
 363              		.loc 1 2216 62 is_stmt 0 view .LVU115
 364 0024 08C093E5 		ldr	ip, [r3, #8]
2216:../src/FreeRTOS/queue.c ****         {
 365              		.loc 1 2216 11 view .LVU116
 366 0028 0C0051E1 		cmp	r1, ip
2218:../src/FreeRTOS/queue.c ****         }
 367              		.loc 1 2218 13 is_stmt 1 view .LVU117
2218:../src/FreeRTOS/queue.c ****         }
 368              		.loc 1 2218 51 is_stmt 0 view .LVU118
 369 002c 00109325 		ldrcs	r1, [r3]
2218:../src/FreeRTOS/queue.c ****         }
 370              		.loc 1 2218 42 view .LVU119
 371 0030 0C108325 		strcs	r1, [r3, #12]
 372              	.L26:
2222:../src/FreeRTOS/queue.c ****         }
 373              		.loc 1 2222 37 is_stmt 1 view .LVU120
2225:../src/FreeRTOS/queue.c ****     }
 374              		.loc 1 2225 9 view .LVU121
2225:../src/FreeRTOS/queue.c ****     }
 375              		.loc 1 2225 18 is_stmt 0 view .LVU122
 376 0034 0C1093E5 		ldr	r1, [r3, #12]
 377 0038 FEFFFFEB 		bl	memcpy
 378              	.LVL34:
2227:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 379              		.loc 1 2227 1 view .LVU123
 380 003c 1080BDE8 		pop	{r4, pc}
 381              		.cfi_endproc
 382              	.LFE27:
 384              		.section	.text.prvUnlockQueue,"ax",%progbits
 385              		.align	2
 386              		.syntax unified
 387              		.arm
 388              		.fpu neon
 390              	prvUnlockQueue:
 391              	.LVL35:
 392              	.LFB28:
2231:../src/FreeRTOS/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 393              		.loc 1 2231 1 is_stmt 1 view -0
 394              		.cfi_startproc
 395              		@ args = 0, pretend = 0, frame = 0
 396              		@ frame_needed = 0, uses_anonymous_args = 0
2231:../src/FreeRTOS/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 397              		.loc 1 2231 1 is_stmt 0 view .LVU125
 398 0000 70402DE9 		push	{r4, r5, r6, lr}
 399              		.cfi_def_cfa_offset 16
 400              		.cfi_offset 4, -16
 401              		.cfi_offset 5, -12
 402              		.cfi_offset 6, -8
 403              		.cfi_offset 14, -4
 404 0004 0050A0E1 		mov	r5, r0
2238:../src/FreeRTOS/queue.c ****     {
 405              		.loc 1 2238 5 is_stmt 1 view .LVU126
 406 0008 FEFFFFEB 		bl	vPortEnterCritical
 407              	.LVL36:
2238:../src/FreeRTOS/queue.c ****     {
 408              		.loc 1 2238 25 view .LVU127
 409              	.LBB2:
2240:../src/FreeRTOS/queue.c **** 
 410              		.loc 1 2240 9 view .LVU128
2240:../src/FreeRTOS/queue.c **** 
 411              		.loc 1 2240 16 is_stmt 0 view .LVU129
 412 000c 4540D5E5 		ldrb	r4, [r5, #69]	@ zero_extendqisi2
 413 0010 7440AFE6 		sxtb	r4, r4
 414              	.LVL37:
2243:../src/FreeRTOS/queue.c ****         {
 415              		.loc 1 2243 9 is_stmt 1 view .LVU130
2243:../src/FreeRTOS/queue.c ****         {
 416              		.loc 1 2243 14 is_stmt 0 view .LVU131
 417 0014 020000EA 		b	.L32
 418              	.L41:
2297:../src/FreeRTOS/queue.c ****                         }
 419              		.loc 1 2297 29 is_stmt 1 view .LVU132
 420 0018 FEFFFFEB 		bl	vTaskMissedYield
 421              	.LVL38:
 422              	.L34:
2301:../src/FreeRTOS/queue.c ****                         }
 423              		.loc 1 2301 53 view .LVU133
2311:../src/FreeRTOS/queue.c ****         }
 424              		.loc 1 2311 13 view .LVU134
 425 001c 014044E2 		sub	r4, r4, #1
 426              	.LVL39:
2311:../src/FreeRTOS/queue.c ****         }
 427              		.loc 1 2311 13 is_stmt 0 view .LVU135
 428 0020 7440AFE6 		sxtb	r4, r4
 429              	.LVL40:
 430              	.L32:
2243:../src/FreeRTOS/queue.c ****         {
 431              		.loc 1 2243 14 is_stmt 1 view .LVU136
 432 0024 000054E3 		cmp	r4, #0
 433 0028 070000DA 		ble	.L33
2291:../src/FreeRTOS/queue.c ****                     {
 434              		.loc 1 2291 21 view .LVU137
2291:../src/FreeRTOS/queue.c ****                     {
 435              		.loc 1 2291 25 is_stmt 0 view .LVU138
 436 002c 243095E5 		ldr	r3, [r5, #36]
2291:../src/FreeRTOS/queue.c ****                     {
 437              		.loc 1 2291 23 view .LVU139
 438 0030 000053E3 		cmp	r3, #0
 439 0034 0400000A 		beq	.L33
2293:../src/FreeRTOS/queue.c ****                         {
 440              		.loc 1 2293 25 is_stmt 1 view .LVU140
2293:../src/FreeRTOS/queue.c ****                         {
 441              		.loc 1 2293 29 is_stmt 0 view .LVU141
 442 0038 240085E2 		add	r0, r5, #36
 443 003c FEFFFFEB 		bl	xTaskRemoveFromEventList
 444              	.LVL41:
2293:../src/FreeRTOS/queue.c ****                         {
 445              		.loc 1 2293 27 view .LVU142
 446 0040 000050E3 		cmp	r0, #0
 447 0044 F4FFFF0A 		beq	.L34
 448 0048 F2FFFFEA 		b	.L41
 449              	.L33:
2314:../src/FreeRTOS/queue.c ****     }
 450              		.loc 1 2314 9 is_stmt 1 view .LVU143
2314:../src/FreeRTOS/queue.c ****     }
 451              		.loc 1 2314 26 is_stmt 0 view .LVU144
 452 004c 0030E0E3 		mvn	r3, #0
 453 0050 4530C5E5 		strb	r3, [r5, #69]
 454              	.LBE2:
2316:../src/FreeRTOS/queue.c **** 
 455              		.loc 1 2316 5 is_stmt 1 view .LVU145
 456 0054 FEFFFFEB 		bl	vPortExitCritical
 457              	.LVL42:
2316:../src/FreeRTOS/queue.c **** 
 458              		.loc 1 2316 24 view .LVU146
2319:../src/FreeRTOS/queue.c ****     {
 459              		.loc 1 2319 5 view .LVU147
 460 0058 FEFFFFEB 		bl	vPortEnterCritical
 461              	.LVL43:
2319:../src/FreeRTOS/queue.c ****     {
 462              		.loc 1 2319 25 view .LVU148
 463              	.LBB3:
2321:../src/FreeRTOS/queue.c **** 
 464              		.loc 1 2321 9 view .LVU149
2321:../src/FreeRTOS/queue.c **** 
 465              		.loc 1 2321 16 is_stmt 0 view .LVU150
 466 005c 4440D5E5 		ldrb	r4, [r5, #68]	@ zero_extendqisi2
 467              	.LVL44:
2321:../src/FreeRTOS/queue.c **** 
 468              		.loc 1 2321 16 view .LVU151
 469 0060 7440AFE6 		sxtb	r4, r4
 470              	.LVL45:
2323:../src/FreeRTOS/queue.c ****         {
 471              		.loc 1 2323 9 is_stmt 1 view .LVU152
2323:../src/FreeRTOS/queue.c ****         {
 472              		.loc 1 2323 14 is_stmt 0 view .LVU153
 473 0064 020000EA 		b	.L36
 474              	.L42:
2329:../src/FreeRTOS/queue.c ****                 }
 475              		.loc 1 2329 21 is_stmt 1 view .LVU154
 476 0068 FEFFFFEB 		bl	vTaskMissedYield
 477              	.LVL46:
 478              	.L38:
2333:../src/FreeRTOS/queue.c ****                 }
 479              		.loc 1 2333 45 view .LVU155
2336:../src/FreeRTOS/queue.c ****             }
 480              		.loc 1 2336 17 view .LVU156
 481 006c 014044E2 		sub	r4, r4, #1
 482              	.LVL47:
2336:../src/FreeRTOS/queue.c ****             }
 483              		.loc 1 2336 17 is_stmt 0 view .LVU157
 484 0070 7440AFE6 		sxtb	r4, r4
 485              	.LVL48:
 486              	.L36:
2323:../src/FreeRTOS/queue.c ****         {
 487              		.loc 1 2323 14 is_stmt 1 view .LVU158
 488 0074 000054E3 		cmp	r4, #0
 489 0078 070000DA 		ble	.L37
2325:../src/FreeRTOS/queue.c ****             {
 490              		.loc 1 2325 13 view .LVU159
2325:../src/FreeRTOS/queue.c ****             {
 491              		.loc 1 2325 17 is_stmt 0 view .LVU160
 492 007c 103095E5 		ldr	r3, [r5, #16]
2325:../src/FreeRTOS/queue.c ****             {
 493              		.loc 1 2325 15 view .LVU161
 494 0080 000053E3 		cmp	r3, #0
 495 0084 0400000A 		beq	.L37
2327:../src/FreeRTOS/queue.c ****                 {
 496              		.loc 1 2327 17 is_stmt 1 view .LVU162
2327:../src/FreeRTOS/queue.c ****                 {
 497              		.loc 1 2327 21 is_stmt 0 view .LVU163
 498 0088 100085E2 		add	r0, r5, #16
 499 008c FEFFFFEB 		bl	xTaskRemoveFromEventList
 500              	.LVL49:
2327:../src/FreeRTOS/queue.c ****                 {
 501              		.loc 1 2327 19 view .LVU164
 502 0090 000050E3 		cmp	r0, #0
 503 0094 F4FFFF0A 		beq	.L38
 504 0098 F2FFFFEA 		b	.L42
 505              	.L37:
2344:../src/FreeRTOS/queue.c ****     }
 506              		.loc 1 2344 9 is_stmt 1 view .LVU165
2344:../src/FreeRTOS/queue.c ****     }
 507              		.loc 1 2344 26 is_stmt 0 view .LVU166
 508 009c 0030E0E3 		mvn	r3, #0
 509 00a0 4430C5E5 		strb	r3, [r5, #68]
 510              	.LBE3:
2346:../src/FreeRTOS/queue.c **** }
 511              		.loc 1 2346 5 is_stmt 1 view .LVU167
 512 00a4 FEFFFFEB 		bl	vPortExitCritical
 513              	.LVL50:
2346:../src/FreeRTOS/queue.c **** }
 514              		.loc 1 2346 24 view .LVU168
2347:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 515              		.loc 1 2347 1 is_stmt 0 view .LVU169
 516 00a8 7080BDE8 		pop	{r4, r5, r6, pc}
 517              		.cfi_endproc
 518              	.LFE28:
 520              		.section	.rodata.xQueueGenericReset.str1.4,"aMS",%progbits,1
 521              		.align	2
 522              	.LC0:
 523 0000 2E2E2F73 		.ascii	"../src/FreeRTOS/queue.c\000"
 523      72632F46 
 523      72656552 
 523      544F532F 
 523      71756575 
 524              		.section	.text.xQueueGenericReset,"ax",%progbits
 525              		.align	2
 526              		.global	xQueueGenericReset
 527              		.syntax unified
 528              		.arm
 529              		.fpu neon
 531              	xQueueGenericReset:
 532              	.LVL51:
 533              	.LFB0:
 266:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 534              		.loc 1 266 1 is_stmt 1 view -0
 535              		.cfi_startproc
 536              		@ args = 0, pretend = 0, frame = 0
 537              		@ frame_needed = 0, uses_anonymous_args = 0
 266:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 538              		.loc 1 266 1 is_stmt 0 view .LVU171
 539 0000 70402DE9 		push	{r4, r5, r6, lr}
 540              		.cfi_def_cfa_offset 16
 541              		.cfi_offset 4, -16
 542              		.cfi_offset 5, -12
 543              		.cfi_offset 6, -8
 544              		.cfi_offset 14, -4
 545 0004 0150A0E1 		mov	r5, r1
 267:../src/FreeRTOS/queue.c **** 
 546              		.loc 1 267 5 is_stmt 1 view .LVU172
 547              	.LVL52:
 269:../src/FreeRTOS/queue.c **** 
 548              		.loc 1 269 5 view .LVU173
 549 0008 004050E2 		subs	r4, r0, #0
 550 000c 1600000A 		beq	.L48
 551              	.LVL53:
 552              	.L44:
 269:../src/FreeRTOS/queue.c **** 
 553              		.loc 1 269 28 discriminator 3 view .LVU174
 271:../src/FreeRTOS/queue.c ****     {
 554              		.loc 1 271 5 discriminator 3 view .LVU175
 555 0010 FEFFFFEB 		bl	vPortEnterCritical
 556              	.LVL54:
 271:../src/FreeRTOS/queue.c ****     {
 557              		.loc 1 271 25 discriminator 3 view .LVU176
 273:../src/FreeRTOS/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 558              		.loc 1 273 9 discriminator 3 view .LVU177
 273:../src/FreeRTOS/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 559              		.loc 1 273 43 is_stmt 0 discriminator 3 view .LVU178
 560 0014 001094E5 		ldr	r1, [r4]
 273:../src/FreeRTOS/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 561              		.loc 1 273 63 discriminator 3 view .LVU179
 562 0018 3C2094E5 		ldr	r2, [r4, #60]
 273:../src/FreeRTOS/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 563              		.loc 1 273 83 discriminator 3 view .LVU180
 564 001c 403094E5 		ldr	r3, [r4, #64]
 273:../src/FreeRTOS/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 565              		.loc 1 273 52 discriminator 3 view .LVU181
 566 0020 931220E0 		mla	r0, r3, r2, r1
 273:../src/FreeRTOS/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 567              		.loc 1 273 34 discriminator 3 view .LVU182
 568 0024 080084E5 		str	r0, [r4, #8]
 274:../src/FreeRTOS/queue.c ****         pxQueue->pcWriteTo = pxQueue->pcHead;
 569              		.loc 1 274 9 is_stmt 1 discriminator 3 view .LVU183
 274:../src/FreeRTOS/queue.c ****         pxQueue->pcWriteTo = pxQueue->pcHead;
 570              		.loc 1 274 36 is_stmt 0 discriminator 3 view .LVU184
 571 0028 0000A0E3 		mov	r0, #0
 572 002c 380084E5 		str	r0, [r4, #56]
 275:../src/FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->ux
 573              		.loc 1 275 9 is_stmt 1 discriminator 3 view .LVU185
 275:../src/FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->ux
 574              		.loc 1 275 28 is_stmt 0 discriminator 3 view .LVU186
 575 0030 041084E5 		str	r1, [r4, #4]
 276:../src/FreeRTOS/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
 576              		.loc 1 276 9 is_stmt 1 discriminator 3 view .LVU187
 276:../src/FreeRTOS/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
 577              		.loc 1 276 80 is_stmt 0 discriminator 3 view .LVU188
 578 0034 012042E2 		sub	r2, r2, #1
 276:../src/FreeRTOS/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
 579              		.loc 1 276 56 discriminator 3 view .LVU189
 580 0038 921323E0 		mla	r3, r2, r3, r1
 276:../src/FreeRTOS/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
 581              		.loc 1 276 38 discriminator 3 view .LVU190
 582 003c 0C3084E5 		str	r3, [r4, #12]
 277:../src/FreeRTOS/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
 583              		.loc 1 277 9 is_stmt 1 discriminator 3 view .LVU191
 277:../src/FreeRTOS/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
 584              		.loc 1 277 26 is_stmt 0 discriminator 3 view .LVU192
 585 0040 0030E0E3 		mvn	r3, #0
 586 0044 4430C4E5 		strb	r3, [r4, #68]
 278:../src/FreeRTOS/queue.c **** 
 587              		.loc 1 278 9 is_stmt 1 discriminator 3 view .LVU193
 278:../src/FreeRTOS/queue.c **** 
 588              		.loc 1 278 26 is_stmt 0 discriminator 3 view .LVU194
 589 0048 4530C4E5 		strb	r3, [r4, #69]
 280:../src/FreeRTOS/queue.c ****         {
 590              		.loc 1 280 9 is_stmt 1 discriminator 3 view .LVU195
 280:../src/FreeRTOS/queue.c ****         {
 591              		.loc 1 280 11 is_stmt 0 discriminator 3 view .LVU196
 592 004c 000055E1 		cmp	r5, r0
 593 0050 1000001A 		bne	.L45
 287:../src/FreeRTOS/queue.c ****             {
 594              		.loc 1 287 13 is_stmt 1 view .LVU197
 287:../src/FreeRTOS/queue.c ****             {
 595              		.loc 1 287 17 is_stmt 0 view .LVU198
 596 0054 103094E5 		ldr	r3, [r4, #16]
 287:../src/FreeRTOS/queue.c ****             {
 597              		.loc 1 287 15 view .LVU199
 598 0058 000053E1 		cmp	r3, r0
 599 005c 0700001A 		bne	.L49
 600              	.L46:
 310:../src/FreeRTOS/queue.c **** 
 601              		.loc 1 310 5 is_stmt 1 view .LVU200
 602 0060 FEFFFFEB 		bl	vPortExitCritical
 603              	.LVL55:
 310:../src/FreeRTOS/queue.c **** 
 604              		.loc 1 310 24 view .LVU201
 314:../src/FreeRTOS/queue.c **** }
 605              		.loc 1 314 5 view .LVU202
 315:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 606              		.loc 1 315 1 is_stmt 0 view .LVU203
 607 0064 0100A0E3 		mov	r0, #1
 608 0068 7080BDE8 		pop	{r4, r5, r6, pc}
 609              	.LVL56:
 610              	.L48:
 269:../src/FreeRTOS/queue.c **** 
 611              		.loc 1 269 5 is_stmt 1 discriminator 1 view .LVU204
 612 006c 0D1100E3 		movw	r1, #269
 613              	.LVL57:
 269:../src/FreeRTOS/queue.c **** 
 614              		.loc 1 269 5 is_stmt 0 discriminator 1 view .LVU205
 615 0070 000000E3 		movw	r0, #:lower16:.LC0
 616              	.LVL58:
 269:../src/FreeRTOS/queue.c **** 
 617              		.loc 1 269 5 discriminator 1 view .LVU206
 618 0074 000040E3 		movt	r0, #:upper16:.LC0
 619 0078 FEFFFFEB 		bl	R_OS_AssertCalled
 620              	.LVL59:
 621 007c E3FFFFEA 		b	.L44
 622              	.L49:
 289:../src/FreeRTOS/queue.c ****                 {
 623              		.loc 1 289 17 is_stmt 1 view .LVU207
 289:../src/FreeRTOS/queue.c ****                 {
 624              		.loc 1 289 21 is_stmt 0 view .LVU208
 625 0080 100084E2 		add	r0, r4, #16
 626 0084 FEFFFFEB 		bl	xTaskRemoveFromEventList
 627              	.LVL60:
 289:../src/FreeRTOS/queue.c ****                 {
 628              		.loc 1 289 19 view .LVU209
 629 0088 000050E3 		cmp	r0, #0
 630 008c F3FFFF0A 		beq	.L46
 291:../src/FreeRTOS/queue.c ****                 }
 631              		.loc 1 291 21 is_stmt 1 view .LVU210
 632              		.syntax divided
 633              	@ 291 "../src/FreeRTOS/queue.c" 1
 634 0090 000000EF 		SWI 0
 635              	@ 0 "" 2
 291:../src/FreeRTOS/queue.c ****                 }
 636              		.loc 1 291 53 view .LVU211
 637              		.arm
 638              		.syntax unified
 639 0094 F1FFFFEA 		b	.L46
 640              	.L45:
 306:../src/FreeRTOS/queue.c ****             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 641              		.loc 1 306 13 view .LVU212
 642 0098 100084E2 		add	r0, r4, #16
 643 009c FEFFFFEB 		bl	vListInitialise
 644              	.LVL61:
 307:../src/FreeRTOS/queue.c ****         }
 645              		.loc 1 307 13 view .LVU213
 646 00a0 240084E2 		add	r0, r4, #36
 647 00a4 FEFFFFEB 		bl	vListInitialise
 648              	.LVL62:
 649 00a8 ECFFFFEA 		b	.L46
 650              		.cfi_endproc
 651              	.LFE0:
 653              		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 654              		.align	2
 655              		.syntax unified
 656              		.arm
 657              		.fpu neon
 659              	prvInitialiseNewQueue:
 660              	.LVL63:
 661              	.LFB2:
 449:../src/FreeRTOS/queue.c ****     /* Remove compiler warnings about unused parameters should
 662              		.loc 1 449 1 view -0
 663              		.cfi_startproc
 664              		@ args = 4, pretend = 0, frame = 0
 665              		@ frame_needed = 0, uses_anonymous_args = 0
 449:../src/FreeRTOS/queue.c ****     /* Remove compiler warnings about unused parameters should
 666              		.loc 1 449 1 is_stmt 0 view .LVU215
 667 0000 70402DE9 		push	{r4, r5, r6, lr}
 668              		.cfi_def_cfa_offset 16
 669              		.cfi_offset 4, -16
 670              		.cfi_offset 5, -12
 671              		.cfi_offset 6, -8
 672              		.cfi_offset 14, -4
 673 0004 0350A0E1 		mov	r5, r3
 674 0008 10409DE5 		ldr	r4, [sp, #16]
 452:../src/FreeRTOS/queue.c **** 
 675              		.loc 1 452 5 is_stmt 1 view .LVU216
 454:../src/FreeRTOS/queue.c ****     {
 676              		.loc 1 454 5 view .LVU217
 454:../src/FreeRTOS/queue.c ****     {
 677              		.loc 1 454 7 is_stmt 0 view .LVU218
 678 000c 000051E3 		cmp	r1, #0
 454:../src/FreeRTOS/queue.c ****     {
 679              		.loc 1 454 7 view .LVU219
 680 0010 0700001A 		bne	.L51
 460:../src/FreeRTOS/queue.c ****     }
 681              		.loc 1 460 9 is_stmt 1 view .LVU220
 460:../src/FreeRTOS/queue.c ****     }
 682              		.loc 1 460 28 is_stmt 0 view .LVU221
 683 0014 004084E5 		str	r4, [r4]
 684              	.L52:
 470:../src/FreeRTOS/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 685              		.loc 1 470 5 is_stmt 1 view .LVU222
 470:../src/FreeRTOS/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 686              		.loc 1 470 26 is_stmt 0 view .LVU223
 687 0018 3C0084E5 		str	r0, [r4, #60]
 471:../src/FreeRTOS/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 688              		.loc 1 471 5 is_stmt 1 view .LVU224
 471:../src/FreeRTOS/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 689              		.loc 1 471 28 is_stmt 0 view .LVU225
 690 001c 401084E5 		str	r1, [r4, #64]
 472:../src/FreeRTOS/queue.c **** 
 691              		.loc 1 472 5 is_stmt 1 view .LVU226
 472:../src/FreeRTOS/queue.c **** 
 692              		.loc 1 472 14 is_stmt 0 view .LVU227
 693 0020 0110A0E3 		mov	r1, #1
 694              	.LVL64:
 472:../src/FreeRTOS/queue.c **** 
 695              		.loc 1 472 14 view .LVU228
 696 0024 0400A0E1 		mov	r0, r4
 697              	.LVL65:
 472:../src/FreeRTOS/queue.c **** 
 698              		.loc 1 472 14 view .LVU229
 699 0028 FEFFFFEB 		bl	xQueueGenericReset
 700              	.LVL66:
 476:../src/FreeRTOS/queue.c ****         }
 701              		.loc 1 476 13 is_stmt 1 view .LVU230
 476:../src/FreeRTOS/queue.c ****         }
 702              		.loc 1 476 37 is_stmt 0 view .LVU231
 703 002c 4C50C4E5 		strb	r5, [r4, #76]
 486:../src/FreeRTOS/queue.c **** }
 704              		.loc 1 486 36 is_stmt 1 view .LVU232
 487:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 705              		.loc 1 487 1 is_stmt 0 view .LVU233
 706 0030 7080BDE8 		pop	{r4, r5, r6, pc}
 707              	.LVL67:
 708              	.L51:
 465:../src/FreeRTOS/queue.c ****     }
 709              		.loc 1 465 9 is_stmt 1 view .LVU234
 465:../src/FreeRTOS/queue.c ****     }
 710              		.loc 1 465 28 is_stmt 0 view .LVU235
 711 0034 002084E5 		str	r2, [r4]
 712 0038 F6FFFFEA 		b	.L52
 713              		.cfi_endproc
 714              	.LFE2:
 716              		.global	__aeabi_uidiv
 717              		.section	.text.xQueueGenericCreate,"ax",%progbits
 718              		.align	2
 719              		.global	xQueueGenericCreate
 720              		.syntax unified
 721              		.arm
 722              		.fpu neon
 724              	xQueueGenericCreate:
 725              	.LVL68:
 726              	.LFB1:
 385:../src/FreeRTOS/queue.c ****         Queue_t * pxNewQueue;
 727              		.loc 1 385 5 is_stmt 1 view -0
 728              		.cfi_startproc
 729              		@ args = 0, pretend = 0, frame = 0
 730              		@ frame_needed = 0, uses_anonymous_args = 0
 385:../src/FreeRTOS/queue.c ****         Queue_t * pxNewQueue;
 731              		.loc 1 385 5 is_stmt 0 view .LVU237
 732 0000 F0402DE9 		push	{r4, r5, r6, r7, lr}
 733              		.cfi_def_cfa_offset 20
 734              		.cfi_offset 4, -20
 735              		.cfi_offset 5, -16
 736              		.cfi_offset 6, -12
 737              		.cfi_offset 7, -8
 738              		.cfi_offset 14, -4
 739 0004 0CD04DE2 		sub	sp, sp, #12
 740              		.cfi_def_cfa_offset 32
 741 0008 0160A0E1 		mov	r6, r1
 742 000c 0270A0E1 		mov	r7, r2
 386:../src/FreeRTOS/queue.c ****         size_t xQueueSizeInBytes;
 743              		.loc 1 386 9 is_stmt 1 view .LVU238
 387:../src/FreeRTOS/queue.c ****         uint8_t * pucQueueStorage;
 744              		.loc 1 387 9 view .LVU239
 388:../src/FreeRTOS/queue.c **** 
 745              		.loc 1 388 9 view .LVU240
 390:../src/FreeRTOS/queue.c **** 
 746              		.loc 1 390 9 view .LVU241
 747 0010 005050E2 		subs	r5, r0, #0
 748 0014 1600000A 		beq	.L60
 749              	.LVL69:
 750              	.L55:
 390:../src/FreeRTOS/queue.c **** 
 751              		.loc 1 390 58 discriminator 3 view .LVU242
 395:../src/FreeRTOS/queue.c **** 
 752              		.loc 1 395 9 discriminator 3 view .LVU243
 395:../src/FreeRTOS/queue.c **** 
 753              		.loc 1 395 27 is_stmt 0 discriminator 3 view .LVU244
 754 0018 960504E0 		mul	r4, r6, r5
 755              	.LVL70:
 398:../src/FreeRTOS/queue.c **** 
 756              		.loc 1 398 9 is_stmt 1 discriminator 3 view .LVU245
 757 001c 000056E3 		cmp	r6, #0
 758 0020 0400000A 		beq	.L56
 398:../src/FreeRTOS/queue.c **** 
 759              		.loc 1 398 9 is_stmt 0 discriminator 2 view .LVU246
 760 0024 0610A0E1 		mov	r1, r6
 761 0028 0400A0E1 		mov	r0, r4
 762 002c FEFFFFEB 		bl	__aeabi_uidiv
 763              	.LVL71:
 764 0030 050050E1 		cmp	r0, r5
 765 0034 1300001A 		bne	.L61
 766              	.L56:
 398:../src/FreeRTOS/queue.c **** 
 767              		.loc 1 398 103 is_stmt 1 discriminator 9 view .LVU247
 401:../src/FreeRTOS/queue.c **** 
 768              		.loc 1 401 9 discriminator 9 view .LVU248
 769 0038 510074E3 		cmn	r4, #81
 770 003c 1600008A 		bhi	.L62
 771              	.L57:
 401:../src/FreeRTOS/queue.c **** 
 772              		.loc 1 401 87 discriminator 3 view .LVU249
 412:../src/FreeRTOS/queue.c **** 
 773              		.loc 1 412 9 discriminator 3 view .LVU250
 412:../src/FreeRTOS/queue.c **** 
 774              		.loc 1 412 36 is_stmt 0 discriminator 3 view .LVU251
 775 0040 500084E2 		add	r0, r4, #80
 776 0044 FEFFFFEB 		bl	pvPortMalloc
 777              	.LVL72:
 414:../src/FreeRTOS/queue.c ****         {
 778              		.loc 1 414 9 is_stmt 1 discriminator 3 view .LVU252
 414:../src/FreeRTOS/queue.c ****         {
 779              		.loc 1 414 11 is_stmt 0 discriminator 3 view .LVU253
 780 0048 004050E2 		subs	r4, r0, #0
 781              	.LVL73:
 414:../src/FreeRTOS/queue.c ****         {
 782              		.loc 1 414 11 discriminator 3 view .LVU254
 783 004c 0500000A 		beq	.L54
 418:../src/FreeRTOS/queue.c ****             pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char 
 784              		.loc 1 418 13 is_stmt 1 view .LVU255
 785              	.LVL74:
 419:../src/FreeRTOS/queue.c **** 
 786              		.loc 1 419 13 view .LVU256
 430:../src/FreeRTOS/queue.c ****         }
 787              		.loc 1 430 13 view .LVU257
 788 0050 00408DE5 		str	r4, [sp]
 789 0054 0730A0E1 		mov	r3, r7
 790 0058 502084E2 		add	r2, r4, #80
 791              	.LVL75:
 430:../src/FreeRTOS/queue.c ****         }
 792              		.loc 1 430 13 is_stmt 0 view .LVU258
 793 005c 0610A0E1 		mov	r1, r6
 794 0060 0500A0E1 		mov	r0, r5
 795              	.LVL76:
 430:../src/FreeRTOS/queue.c ****         }
 796              		.loc 1 430 13 view .LVU259
 797 0064 FEFFFFEB 		bl	prvInitialiseNewQueue
 798              	.LVL77:
 434:../src/FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 799              		.loc 1 434 52 is_stmt 1 view .LVU260
 435:../src/FreeRTOS/queue.c ****         }
 800              		.loc 1 435 37 view .LVU261
 438:../src/FreeRTOS/queue.c ****     }
 801              		.loc 1 438 9 view .LVU262
 802              	.L54:
 439:../src/FreeRTOS/queue.c **** 
 803              		.loc 1 439 5 is_stmt 0 view .LVU263
 804 0068 0400A0E1 		mov	r0, r4
 805 006c 0CD08DE2 		add	sp, sp, #12
 806              		.cfi_remember_state
 807              		.cfi_def_cfa_offset 20
 808              		@ sp needed
 809 0070 F080BDE8 		pop	{r4, r5, r6, r7, pc}
 810              	.LVL78:
 811              	.L60:
 812              		.cfi_restore_state
 390:../src/FreeRTOS/queue.c **** 
 813              		.loc 1 390 9 is_stmt 1 discriminator 1 view .LVU264
 814 0074 861100E3 		movw	r1, #390
 815              	.LVL79:
 390:../src/FreeRTOS/queue.c **** 
 816              		.loc 1 390 9 is_stmt 0 discriminator 1 view .LVU265
 817 0078 000000E3 		movw	r0, #:lower16:.LC0
 818              	.LVL80:
 390:../src/FreeRTOS/queue.c **** 
 819              		.loc 1 390 9 discriminator 1 view .LVU266
 820 007c 000040E3 		movt	r0, #:upper16:.LC0
 821 0080 FEFFFFEB 		bl	R_OS_AssertCalled
 822              	.LVL81:
 390:../src/FreeRTOS/queue.c **** 
 823              		.loc 1 390 9 discriminator 1 view .LVU267
 824 0084 E3FFFFEA 		b	.L55
 825              	.LVL82:
 826              	.L61:
 398:../src/FreeRTOS/queue.c **** 
 827              		.loc 1 398 9 is_stmt 1 view .LVU268
 828 0088 8E1100E3 		movw	r1, #398
 829 008c 000000E3 		movw	r0, #:lower16:.LC0
 830 0090 000040E3 		movt	r0, #:upper16:.LC0
 831 0094 FEFFFFEB 		bl	R_OS_AssertCalled
 832              	.LVL83:
 833 0098 E6FFFFEA 		b	.L56
 834              	.L62:
 401:../src/FreeRTOS/queue.c **** 
 835              		.loc 1 401 9 discriminator 1 view .LVU269
 836 009c 911100E3 		movw	r1, #401
 837 00a0 000000E3 		movw	r0, #:lower16:.LC0
 838 00a4 000040E3 		movt	r0, #:upper16:.LC0
 839 00a8 FEFFFFEB 		bl	R_OS_AssertCalled
 840              	.LVL84:
 841 00ac E3FFFFEA 		b	.L57
 842              		.cfi_endproc
 843              	.LFE1:
 845              		.section	.text.xQueueGetMutexHolder,"ax",%progbits
 846              		.align	2
 847              		.global	xQueueGetMutexHolder
 848              		.syntax unified
 849              		.arm
 850              		.fpu neon
 852              	xQueueGetMutexHolder:
 853              	.LVL85:
 854              	.LFB5:
 560:../src/FreeRTOS/queue.c ****         TaskHandle_t pxReturn;
 855              		.loc 1 560 5 view -0
 856              		.cfi_startproc
 857              		@ args = 0, pretend = 0, frame = 0
 858              		@ frame_needed = 0, uses_anonymous_args = 0
 560:../src/FreeRTOS/queue.c ****         TaskHandle_t pxReturn;
 859              		.loc 1 560 5 is_stmt 0 view .LVU271
 860 0000 10402DE9 		push	{r4, lr}
 861              		.cfi_def_cfa_offset 8
 862              		.cfi_offset 4, -8
 863              		.cfi_offset 14, -4
 864 0004 0040A0E1 		mov	r4, r0
 561:../src/FreeRTOS/queue.c ****         Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 865              		.loc 1 561 9 is_stmt 1 view .LVU272
 562:../src/FreeRTOS/queue.c **** 
 866              		.loc 1 562 9 view .LVU273
 867              	.LVL86:
 569:../src/FreeRTOS/queue.c ****         {
 868              		.loc 1 569 9 view .LVU274
 869 0008 FEFFFFEB 		bl	vPortEnterCritical
 870              	.LVL87:
 569:../src/FreeRTOS/queue.c ****         {
 871              		.loc 1 569 29 view .LVU275
 571:../src/FreeRTOS/queue.c ****             {
 872              		.loc 1 571 13 view .LVU276
 571:../src/FreeRTOS/queue.c ****             {
 873              		.loc 1 571 28 is_stmt 0 view .LVU277
 874 000c 003094E5 		ldr	r3, [r4]
 571:../src/FreeRTOS/queue.c ****             {
 875              		.loc 1 571 15 view .LVU278
 876 0010 000053E3 		cmp	r3, #0
 877 0014 0300001A 		bne	.L65
 573:../src/FreeRTOS/queue.c ****             }
 878              		.loc 1 573 17 is_stmt 1 view .LVU279
 573:../src/FreeRTOS/queue.c ****             }
 879              		.loc 1 573 26 is_stmt 0 view .LVU280
 880 0018 084094E5 		ldr	r4, [r4, #8]
 881              	.LVL88:
 882              	.L64:
 580:../src/FreeRTOS/queue.c **** 
 883              		.loc 1 580 9 is_stmt 1 view .LVU281
 884 001c FEFFFFEB 		bl	vPortExitCritical
 885              	.LVL89:
 580:../src/FreeRTOS/queue.c **** 
 886              		.loc 1 580 28 view .LVU282
 582:../src/FreeRTOS/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 887              		.loc 1 582 9 view .LVU283
 583:../src/FreeRTOS/queue.c **** 
 888              		.loc 1 583 5 is_stmt 0 view .LVU284
 889 0020 0400A0E1 		mov	r0, r4
 890 0024 1080BDE8 		pop	{r4, pc}
 891              	.LVL90:
 892              	.L65:
 577:../src/FreeRTOS/queue.c ****             }
 893              		.loc 1 577 26 view .LVU285
 894 0028 0040A0E3 		mov	r4, #0
 895              	.LVL91:
 577:../src/FreeRTOS/queue.c ****             }
 896              		.loc 1 577 26 view .LVU286
 897 002c FAFFFFEA 		b	.L64
 898              		.cfi_endproc
 899              	.LFE5:
 901              		.section	.text.xQueueGetMutexHolderFromISR,"ax",%progbits
 902              		.align	2
 903              		.global	xQueueGetMutexHolderFromISR
 904              		.syntax unified
 905              		.arm
 906              		.fpu neon
 908              	xQueueGetMutexHolderFromISR:
 909              	.LVL92:
 910              	.LFB6:
 591:../src/FreeRTOS/queue.c ****         TaskHandle_t pxReturn;
 911              		.loc 1 591 5 is_stmt 1 view -0
 912              		.cfi_startproc
 913              		@ args = 0, pretend = 0, frame = 0
 914              		@ frame_needed = 0, uses_anonymous_args = 0
 591:../src/FreeRTOS/queue.c ****         TaskHandle_t pxReturn;
 915              		.loc 1 591 5 is_stmt 0 view .LVU288
 916 0000 10402DE9 		push	{r4, lr}
 917              		.cfi_def_cfa_offset 8
 918              		.cfi_offset 4, -8
 919              		.cfi_offset 14, -4
 592:../src/FreeRTOS/queue.c **** 
 920              		.loc 1 592 9 is_stmt 1 view .LVU289
 594:../src/FreeRTOS/queue.c **** 
 921              		.loc 1 594 9 view .LVU290
 922 0004 004050E2 		subs	r4, r0, #0
 923 0008 0400000A 		beq	.L72
 924              	.LVL93:
 925              	.L68:
 594:../src/FreeRTOS/queue.c **** 
 926              		.loc 1 594 35 discriminator 3 view .LVU291
 599:../src/FreeRTOS/queue.c ****         {
 927              		.loc 1 599 9 discriminator 3 view .LVU292
 599:../src/FreeRTOS/queue.c ****         {
 928              		.loc 1 599 41 is_stmt 0 discriminator 3 view .LVU293
 929 000c 003094E5 		ldr	r3, [r4]
 599:../src/FreeRTOS/queue.c ****         {
 930              		.loc 1 599 11 discriminator 3 view .LVU294
 931 0010 000053E3 		cmp	r3, #0
 932 0014 0600001A 		bne	.L70
 601:../src/FreeRTOS/queue.c ****         }
 933              		.loc 1 601 13 is_stmt 1 view .LVU295
 601:../src/FreeRTOS/queue.c ****         }
 934              		.loc 1 601 22 is_stmt 0 view .LVU296
 935 0018 080094E5 		ldr	r0, [r4, #8]
 936              	.LVL94:
 601:../src/FreeRTOS/queue.c ****         }
 937              		.loc 1 601 22 view .LVU297
 938 001c 1080BDE8 		pop	{r4, pc}
 939              	.LVL95:
 940              	.L72:
 594:../src/FreeRTOS/queue.c **** 
 941              		.loc 1 594 9 is_stmt 1 discriminator 1 view .LVU298
 942 0020 521200E3 		movw	r1, #594
 943 0024 000000E3 		movw	r0, #:lower16:.LC0
 944              	.LVL96:
 594:../src/FreeRTOS/queue.c **** 
 945              		.loc 1 594 9 is_stmt 0 discriminator 1 view .LVU299
 946 0028 000040E3 		movt	r0, #:upper16:.LC0
 947 002c FEFFFFEB 		bl	R_OS_AssertCalled
 948              	.LVL97:
 949 0030 F5FFFFEA 		b	.L68
 950              	.L70:
 605:../src/FreeRTOS/queue.c ****         }
 951              		.loc 1 605 22 view .LVU300
 952 0034 0000A0E3 		mov	r0, #0
 953              	.LVL98:
 608:../src/FreeRTOS/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 954              		.loc 1 608 9 is_stmt 1 view .LVU301
 609:../src/FreeRTOS/queue.c **** 
 955              		.loc 1 609 5 is_stmt 0 view .LVU302
 956 0038 1080BDE8 		pop	{r4, pc}
 957              		.cfi_endproc
 958              	.LFE6:
 960              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 961              		.align	2
 962              		.global	xQueueCreateCountingSemaphore
 963              		.syntax unified
 964              		.arm
 965              		.fpu neon
 967              	xQueueCreateCountingSemaphore:
 968              	.LVL99:
 969              	.LFB9:
 746:../src/FreeRTOS/queue.c ****         QueueHandle_t xHandle;
 970              		.loc 1 746 5 is_stmt 1 view -0
 971              		.cfi_startproc
 972              		@ args = 0, pretend = 0, frame = 0
 973              		@ frame_needed = 0, uses_anonymous_args = 0
 746:../src/FreeRTOS/queue.c ****         QueueHandle_t xHandle;
 974              		.loc 1 746 5 is_stmt 0 view .LVU304
 975 0000 70402DE9 		push	{r4, r5, r6, lr}
 976              		.cfi_def_cfa_offset 16
 977              		.cfi_offset 4, -16
 978              		.cfi_offset 5, -12
 979              		.cfi_offset 6, -8
 980              		.cfi_offset 14, -4
 981 0004 0150A0E1 		mov	r5, r1
 747:../src/FreeRTOS/queue.c **** 
 982              		.loc 1 747 9 is_stmt 1 view .LVU305
 749:../src/FreeRTOS/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 983              		.loc 1 749 9 view .LVU306
 984 0008 004050E2 		subs	r4, r0, #0
 985 000c 0900000A 		beq	.L78
 986              	.LVL100:
 987              	.L74:
 749:../src/FreeRTOS/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 988              		.loc 1 749 40 discriminator 3 view .LVU307
 750:../src/FreeRTOS/queue.c **** 
 989              		.loc 1 750 9 discriminator 3 view .LVU308
 990 0010 050054E1 		cmp	r4, r5
 991 0014 0C00003A 		bcc	.L79
 992              	.L75:
 750:../src/FreeRTOS/queue.c **** 
 993              		.loc 1 750 53 discriminator 3 view .LVU309
 752:../src/FreeRTOS/queue.c **** 
 994              		.loc 1 752 9 discriminator 3 view .LVU310
 752:../src/FreeRTOS/queue.c **** 
 995              		.loc 1 752 19 is_stmt 0 discriminator 3 view .LVU311
 996 0018 0220A0E3 		mov	r2, #2
 997 001c 0010A0E3 		mov	r1, #0
 998 0020 0400A0E1 		mov	r0, r4
 999 0024 FEFFFFEB 		bl	xQueueGenericCreate
 1000              	.LVL101:
 754:../src/FreeRTOS/queue.c ****         {
 1001              		.loc 1 754 9 is_stmt 1 discriminator 3 view .LVU312
 754:../src/FreeRTOS/queue.c ****         {
 1002              		.loc 1 754 11 is_stmt 0 discriminator 3 view .LVU313
 1003 0028 000050E3 		cmp	r0, #0
 754:../src/FreeRTOS/queue.c ****         {
 1004              		.loc 1 754 11 discriminator 3 view .LVU314
 1005 002c 7080BD08 		popeq	{r4, r5, r6, pc}
 756:../src/FreeRTOS/queue.c **** 
 1006              		.loc 1 756 13 is_stmt 1 view .LVU315
 756:../src/FreeRTOS/queue.c **** 
 1007              		.loc 1 756 58 is_stmt 0 view .LVU316
 1008 0030 385080E5 		str	r5, [r0, #56]
 758:../src/FreeRTOS/queue.c ****         }
 1009              		.loc 1 758 45 is_stmt 1 view .LVU317
 762:../src/FreeRTOS/queue.c ****         }
 1010              		.loc 1 762 52 view .LVU318
 765:../src/FreeRTOS/queue.c ****     }
 1011              		.loc 1 765 9 view .LVU319
 766:../src/FreeRTOS/queue.c **** 
 1012              		.loc 1 766 5 is_stmt 0 view .LVU320
 1013 0034 7080BDE8 		pop	{r4, r5, r6, pc}
 1014              	.LVL102:
 1015              	.L78:
 749:../src/FreeRTOS/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 1016              		.loc 1 749 9 is_stmt 1 discriminator 1 view .LVU321
 1017 0038 ED1200E3 		movw	r1, #749
 1018              	.LVL103:
 749:../src/FreeRTOS/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 1019              		.loc 1 749 9 is_stmt 0 discriminator 1 view .LVU322
 1020 003c 000000E3 		movw	r0, #:lower16:.LC0
 1021              	.LVL104:
 749:../src/FreeRTOS/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 1022              		.loc 1 749 9 discriminator 1 view .LVU323
 1023 0040 000040E3 		movt	r0, #:upper16:.LC0
 1024 0044 FEFFFFEB 		bl	R_OS_AssertCalled
 1025              	.LVL105:
 1026 0048 F0FFFFEA 		b	.L74
 1027              	.L79:
 750:../src/FreeRTOS/queue.c **** 
 1028              		.loc 1 750 9 is_stmt 1 discriminator 1 view .LVU324
 1029 004c EE1200E3 		movw	r1, #750
 1030 0050 000000E3 		movw	r0, #:lower16:.LC0
 1031 0054 000040E3 		movt	r0, #:upper16:.LC0
 1032 0058 FEFFFFEB 		bl	R_OS_AssertCalled
 1033              	.LVL106:
 1034 005c EDFFFFEA 		b	.L75
 1035              		.cfi_endproc
 1036              	.LFE9:
 1038              		.section	.text.xQueueGenericSend,"ax",%progbits
 1039              		.align	2
 1040              		.global	xQueueGenericSend
 1041              		.syntax unified
 1042              		.arm
 1043              		.fpu neon
 1045              	xQueueGenericSend:
 1046              	.LVL107:
 1047              	.LFB10:
 775:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1048              		.loc 1 775 1 view -0
 1049              		.cfi_startproc
 1050              		@ args = 0, pretend = 0, frame = 16
 1051              		@ frame_needed = 0, uses_anonymous_args = 0
 775:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1052              		.loc 1 775 1 is_stmt 0 view .LVU326
 1053 0000 F0402DE9 		push	{r4, r5, r6, r7, lr}
 1054              		.cfi_def_cfa_offset 20
 1055              		.cfi_offset 4, -20
 1056              		.cfi_offset 5, -16
 1057              		.cfi_offset 6, -12
 1058              		.cfi_offset 7, -8
 1059              		.cfi_offset 14, -4
 1060 0004 14D04DE2 		sub	sp, sp, #20
 1061              		.cfi_def_cfa_offset 40
 1062 0008 0170A0E1 		mov	r7, r1
 1063 000c 04208DE5 		str	r2, [sp, #4]
 1064 0010 0350A0E1 		mov	r5, r3
 776:../src/FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 1065              		.loc 1 776 5 is_stmt 1 view .LVU327
 1066              	.LVL108:
 777:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 1067              		.loc 1 777 5 view .LVU328
 778:../src/FreeRTOS/queue.c **** 
 1068              		.loc 1 778 5 view .LVU329
 780:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1069              		.loc 1 780 5 view .LVU330
 1070 0014 004050E2 		subs	r4, r0, #0
 1071 0018 0B00000A 		beq	.L99
 1072              	.LVL109:
 1073              	.L81:
 780:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1074              		.loc 1 780 28 discriminator 3 view .LVU331
 781:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1075              		.loc 1 781 5 discriminator 3 view .LVU332
 1076 001c 000057E3 		cmp	r7, #0
 1077 0020 0E00000A 		beq	.L100
 1078              	.L82:
 781:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1079              		.loc 1 781 100 discriminator 9 view .LVU333
 782:../src/FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1080              		.loc 1 782 5 discriminator 9 view .LVU334
 1081 0024 020055E3 		cmp	r5, #2
 1082 0028 1400000A 		beq	.L101
 1083              	.L83:
 782:../src/FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1084              		.loc 1 782 91 discriminator 9 view .LVU335
 785:../src/FreeRTOS/queue.c ****         }
 1085              		.loc 1 785 13 discriminator 9 view .LVU336
 1086 002c FEFFFFEB 		bl	xTaskGetSchedulerState
 1087              	.LVL110:
 1088 0030 000050E3 		cmp	r0, #0
 1089 0034 0200001A 		bne	.L84
 785:../src/FreeRTOS/queue.c ****         }
 1090              		.loc 1 785 13 is_stmt 0 discriminator 2 view .LVU337
 1091 0038 04309DE5 		ldr	r3, [sp, #4]
 1092 003c 000053E3 		cmp	r3, #0
 1093 0040 1600001A 		bne	.L102
 1094              	.L84:
 775:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1095              		.loc 1 775 1 discriminator 9 view .LVU338
 1096 0044 0060A0E3 		mov	r6, #0
 1097 0048 3D0000EA 		b	.L85
 1098              	.LVL111:
 1099              	.L99:
 780:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1100              		.loc 1 780 5 is_stmt 1 discriminator 1 view .LVU339
 1101 004c C31FA0E3 		mov	r1, #780
 1102              	.LVL112:
 780:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1103              		.loc 1 780 5 is_stmt 0 discriminator 1 view .LVU340
 1104 0050 000000E3 		movw	r0, #:lower16:.LC0
 1105              	.LVL113:
 780:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1106              		.loc 1 780 5 discriminator 1 view .LVU341
 1107 0054 000040E3 		movt	r0, #:upper16:.LC0
 1108 0058 FEFFFFEB 		bl	R_OS_AssertCalled
 1109              	.LVL114:
 780:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1110              		.loc 1 780 5 discriminator 1 view .LVU342
 1111 005c EEFFFFEA 		b	.L81
 1112              	.L100:
 781:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1113              		.loc 1 781 5 discriminator 2 view .LVU343
 1114 0060 403094E5 		ldr	r3, [r4, #64]
 1115 0064 000053E3 		cmp	r3, #0
 1116 0068 EDFFFF0A 		beq	.L82
 781:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1117              		.loc 1 781 5 is_stmt 1 view .LVU344
 1118 006c 0D1300E3 		movw	r1, #781
 1119 0070 000000E3 		movw	r0, #:lower16:.LC0
 1120 0074 000040E3 		movt	r0, #:upper16:.LC0
 1121 0078 FEFFFFEB 		bl	R_OS_AssertCalled
 1122              	.LVL115:
 1123 007c E8FFFFEA 		b	.L82
 1124              	.L101:
 782:../src/FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1125              		.loc 1 782 5 is_stmt 0 discriminator 2 view .LVU345
 1126 0080 3C3094E5 		ldr	r3, [r4, #60]
 1127 0084 010053E3 		cmp	r3, #1
 1128 0088 E7FFFF0A 		beq	.L83
 782:../src/FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1129              		.loc 1 782 5 is_stmt 1 view .LVU346
 1130 008c 0E1300E3 		movw	r1, #782
 1131 0090 000000E3 		movw	r0, #:lower16:.LC0
 1132 0094 000040E3 		movt	r0, #:upper16:.LC0
 1133 0098 FEFFFFEB 		bl	R_OS_AssertCalled
 1134              	.LVL116:
 1135 009c E2FFFFEA 		b	.L83
 1136              	.L102:
 785:../src/FreeRTOS/queue.c ****         }
 1137              		.loc 1 785 13 view .LVU347
 1138 00a0 111300E3 		movw	r1, #785
 1139 00a4 000000E3 		movw	r0, #:lower16:.LC0
 1140 00a8 000040E3 		movt	r0, #:upper16:.LC0
 1141 00ac FEFFFFEB 		bl	R_OS_AssertCalled
 1142              	.LVL117:
 1143 00b0 E3FFFFEA 		b	.L84
 1144              	.LVL118:
 1145              	.L86:
 802:../src/FreeRTOS/queue.c **** 
 1146              		.loc 1 802 43 view .LVU348
 866:../src/FreeRTOS/queue.c **** 
 1147              		.loc 1 866 25 view .LVU349
 866:../src/FreeRTOS/queue.c **** 
 1148              		.loc 1 866 42 is_stmt 0 view .LVU350
 1149 00b4 0520A0E1 		mov	r2, r5
 1150 00b8 0710A0E1 		mov	r1, r7
 1151 00bc 0400A0E1 		mov	r0, r4
 1152 00c0 FEFFFFEB 		bl	prvCopyDataToQueue
 1153              	.LVL119:
 870:../src/FreeRTOS/queue.c ****                         {
 1154              		.loc 1 870 25 is_stmt 1 view .LVU351
 870:../src/FreeRTOS/queue.c ****                         {
 1155              		.loc 1 870 29 is_stmt 0 view .LVU352
 1156 00c4 243094E5 		ldr	r3, [r4, #36]
 870:../src/FreeRTOS/queue.c ****                         {
 1157              		.loc 1 870 27 view .LVU353
 1158 00c8 000053E3 		cmp	r3, #0
 1159 00cc 0600001A 		bne	.L103
 885:../src/FreeRTOS/queue.c ****                         {
 1160              		.loc 1 885 30 is_stmt 1 view .LVU354
 885:../src/FreeRTOS/queue.c ****                         {
 1161              		.loc 1 885 32 is_stmt 0 view .LVU355
 1162 00d0 000050E3 		cmp	r0, #0
 1163 00d4 0000000A 		beq	.L89
 891:../src/FreeRTOS/queue.c ****                         }
 1164              		.loc 1 891 29 is_stmt 1 view .LVU356
 1165              		.syntax divided
 1166              	@ 891 "../src/FreeRTOS/queue.c" 1
 1167 00d8 000000EF 		SWI 0
 1168              	@ 0 "" 2
 891:../src/FreeRTOS/queue.c ****                         }
 1169              		.loc 1 891 61 view .LVU357
 1170              	.LVL120:
 1171              		.arm
 1172              		.syntax unified
 1173              	.L89:
 895:../src/FreeRTOS/queue.c ****                         }
 1174              		.loc 1 895 53 view .LVU358
 900:../src/FreeRTOS/queue.c ****                 return pdPASS;
 1175              		.loc 1 900 17 view .LVU359
 1176 00dc FEFFFFEB 		bl	vPortExitCritical
 1177              	.LVL121:
 900:../src/FreeRTOS/queue.c ****                 return pdPASS;
 1178              		.loc 1 900 36 view .LVU360
 901:../src/FreeRTOS/queue.c ****             }
 1179              		.loc 1 901 17 view .LVU361
 901:../src/FreeRTOS/queue.c ****             }
 1180              		.loc 1 901 24 is_stmt 0 view .LVU362
 1181 00e0 0100A0E3 		mov	r0, #1
 1182              	.L80:
 980:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 1183              		.loc 1 980 1 view .LVU363
 1184 00e4 14D08DE2 		add	sp, sp, #20
 1185              		.cfi_remember_state
 1186              		.cfi_def_cfa_offset 20
 1187              		@ sp needed
 1188 00e8 F080BDE8 		pop	{r4, r5, r6, r7, pc}
 1189              	.LVL122:
 1190              	.L103:
 1191              		.cfi_restore_state
 872:../src/FreeRTOS/queue.c ****                             {
 1192              		.loc 1 872 29 is_stmt 1 view .LVU364
 872:../src/FreeRTOS/queue.c ****                             {
 1193              		.loc 1 872 33 is_stmt 0 view .LVU365
 1194 00ec 240084E2 		add	r0, r4, #36
 1195              	.LVL123:
 872:../src/FreeRTOS/queue.c ****                             {
 1196              		.loc 1 872 33 view .LVU366
 1197 00f0 FEFFFFEB 		bl	xTaskRemoveFromEventList
 1198              	.LVL124:
 872:../src/FreeRTOS/queue.c ****                             {
 1199              		.loc 1 872 31 view .LVU367
 1200 00f4 000050E3 		cmp	r0, #0
 1201 00f8 F7FFFF0A 		beq	.L89
 878:../src/FreeRTOS/queue.c ****                             }
 1202              		.loc 1 878 33 is_stmt 1 view .LVU368
 1203              		.syntax divided
 1204              	@ 878 "../src/FreeRTOS/queue.c" 1
 1205 00fc 000000EF 		SWI 0
 1206              	@ 0 "" 2
 878:../src/FreeRTOS/queue.c ****                             }
 1207              		.loc 1 878 65 view .LVU369
 1208              		.arm
 1209              		.syntax unified
 1210 0100 F5FFFFEA 		b	.L89
 1211              	.L104:
 909:../src/FreeRTOS/queue.c **** 
 1212              		.loc 1 909 21 view .LVU370
 1213 0104 FEFFFFEB 		bl	vPortExitCritical
 1214              	.LVL125:
 909:../src/FreeRTOS/queue.c **** 
 1215              		.loc 1 909 40 view .LVU371
 913:../src/FreeRTOS/queue.c ****                     return errQUEUE_FULL;
 1216              		.loc 1 913 54 view .LVU372
 914:../src/FreeRTOS/queue.c ****                 }
 1217              		.loc 1 914 21 view .LVU373
 914:../src/FreeRTOS/queue.c ****                 }
 1218              		.loc 1 914 28 is_stmt 0 view .LVU374
 1219 0108 0000A0E3 		mov	r0, #0
 1220 010c F4FFFFEA 		b	.L80
 1221              	.L105:
 920:../src/FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 1222              		.loc 1 920 21 is_stmt 1 view .LVU375
 1223 0110 08008DE2 		add	r0, sp, #8
 1224 0114 FEFFFFEB 		bl	vTaskInternalSetTimeOutState
 1225              	.LVL126:
 921:../src/FreeRTOS/queue.c ****                 }
 1226              		.loc 1 921 21 view .LVU376
 921:../src/FreeRTOS/queue.c ****                 }
 1227              		.loc 1 921 35 is_stmt 0 view .LVU377
 1228 0118 0160A0E3 		mov	r6, #1
 1229 011c 140000EA 		b	.L92
 1230              	.LVL127:
 1231              	.L106:
 936:../src/FreeRTOS/queue.c **** 
 1232              		.loc 1 936 9 is_stmt 1 discriminator 1 view .LVU378
 1233 0120 0030A0E3 		mov	r3, #0
 1234 0124 4430C4E5 		strb	r3, [r4, #68]
 1235 0128 180000EA 		b	.L93
 1236              	.L107:
 936:../src/FreeRTOS/queue.c **** 
 1237              		.loc 1 936 9 discriminator 4 view .LVU379
 1238 012c 0030A0E3 		mov	r3, #0
 1239 0130 4530C4E5 		strb	r3, [r4, #69]
 1240 0134 190000EA 		b	.L94
 1241              	.L96:
 966:../src/FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
 1242              		.loc 1 966 17 view .LVU380
 1243 0138 0400A0E1 		mov	r0, r4
 1244 013c FEFFFFEB 		bl	prvUnlockQueue
 1245              	.LVL128:
 967:../src/FreeRTOS/queue.c ****             }
 1246              		.loc 1 967 17 view .LVU381
 967:../src/FreeRTOS/queue.c ****             }
 1247              		.loc 1 967 26 is_stmt 0 view .LVU382
 1248 0140 FEFFFFEB 		bl	xTaskResumeAll
 1249              	.LVL129:
 1250              	.L85:
 785:../src/FreeRTOS/queue.c ****         }
 1251              		.loc 1 785 114 is_stmt 1 discriminator 9 view .LVU383
 792:../src/FreeRTOS/queue.c ****     {
 1252              		.loc 1 792 5 discriminator 9 view .LVU384
 794:../src/FreeRTOS/queue.c ****         {
 1253              		.loc 1 794 9 discriminator 9 view .LVU385
 1254 0144 FEFFFFEB 		bl	vPortEnterCritical
 1255              	.LVL130:
 794:../src/FreeRTOS/queue.c ****         {
 1256              		.loc 1 794 29 discriminator 9 view .LVU386
 800:../src/FreeRTOS/queue.c ****             {
 1257              		.loc 1 800 13 discriminator 9 view .LVU387
 800:../src/FreeRTOS/queue.c ****             {
 1258              		.loc 1 800 26 is_stmt 0 discriminator 9 view .LVU388
 1259 0148 382094E5 		ldr	r2, [r4, #56]
 800:../src/FreeRTOS/queue.c ****             {
 1260              		.loc 1 800 55 discriminator 9 view .LVU389
 1261 014c 3C3094E5 		ldr	r3, [r4, #60]
 800:../src/FreeRTOS/queue.c ****             {
 1262              		.loc 1 800 15 discriminator 9 view .LVU390
 1263 0150 030052E1 		cmp	r2, r3
 1264 0154 D6FFFF3A 		bcc	.L86
 800:../src/FreeRTOS/queue.c ****             {
 1265              		.loc 1 800 68 discriminator 1 view .LVU391
 1266 0158 020055E3 		cmp	r5, #2
 1267 015c D4FFFF0A 		beq	.L86
 905:../src/FreeRTOS/queue.c ****                 {
 1268              		.loc 1 905 17 is_stmt 1 view .LVU392
 905:../src/FreeRTOS/queue.c ****                 {
 1269              		.loc 1 905 34 is_stmt 0 view .LVU393
 1270 0160 04309DE5 		ldr	r3, [sp, #4]
 905:../src/FreeRTOS/queue.c ****                 {
 1271              		.loc 1 905 19 view .LVU394
 1272 0164 000053E3 		cmp	r3, #0
 1273 0168 E5FFFF0A 		beq	.L104
 916:../src/FreeRTOS/queue.c ****                 {
 1274              		.loc 1 916 22 is_stmt 1 view .LVU395
 916:../src/FreeRTOS/queue.c ****                 {
 1275              		.loc 1 916 24 is_stmt 0 view .LVU396
 1276 016c 000056E3 		cmp	r6, #0
 1277 0170 E6FFFF0A 		beq	.L105
 1278              	.LVL131:
 1279              	.L92:
 926:../src/FreeRTOS/queue.c ****                 }
 1280              		.loc 1 926 45 is_stmt 1 view .LVU397
 930:../src/FreeRTOS/queue.c **** 
 1281              		.loc 1 930 9 view .LVU398
 1282 0174 FEFFFFEB 		bl	vPortExitCritical
 1283              	.LVL132:
 930:../src/FreeRTOS/queue.c **** 
 1284              		.loc 1 930 28 view .LVU399
 935:../src/FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 1285              		.loc 1 935 9 view .LVU400
 1286 0178 FEFFFFEB 		bl	vTaskSuspendAll
 1287              	.LVL133:
 936:../src/FreeRTOS/queue.c **** 
 1288              		.loc 1 936 9 view .LVU401
 1289 017c FEFFFFEB 		bl	vPortEnterCritical
 1290              	.LVL134:
 936:../src/FreeRTOS/queue.c **** 
 1291              		.loc 1 936 9 view .LVU402
 936:../src/FreeRTOS/queue.c **** 
 1292              		.loc 1 936 9 view .LVU403
 1293 0180 4420D4E5 		ldrb	r2, [r4, #68]	@ zero_extendqisi2
 1294 0184 7220AFE6 		sxtb	r2, r2
 1295 0188 010072E3 		cmn	r2, #1
 1296 018c E3FFFF0A 		beq	.L106
 1297              	.L93:
 936:../src/FreeRTOS/queue.c **** 
 1298              		.loc 1 936 9 discriminator 3 view .LVU404
 1299 0190 4520D4E5 		ldrb	r2, [r4, #69]	@ zero_extendqisi2
 1300 0194 7220AFE6 		sxtb	r2, r2
 1301 0198 010072E3 		cmn	r2, #1
 1302 019c E2FFFF0A 		beq	.L107
 1303              	.L94:
 936:../src/FreeRTOS/queue.c **** 
 1304              		.loc 1 936 9 discriminator 6 view .LVU405
 1305 01a0 FEFFFFEB 		bl	vPortExitCritical
 1306              	.LVL135:
 936:../src/FreeRTOS/queue.c **** 
 1307              		.loc 1 936 32 discriminator 6 view .LVU406
 939:../src/FreeRTOS/queue.c ****         {
 1308              		.loc 1 939 9 discriminator 6 view .LVU407
 939:../src/FreeRTOS/queue.c ****         {
 1309              		.loc 1 939 13 is_stmt 0 discriminator 6 view .LVU408
 1310 01a4 04108DE2 		add	r1, sp, #4
 1311 01a8 08008DE2 		add	r0, sp, #8
 1312 01ac FEFFFFEB 		bl	xTaskCheckForTimeOut
 1313              	.LVL136:
 939:../src/FreeRTOS/queue.c ****         {
 1314              		.loc 1 939 11 discriminator 6 view .LVU409
 1315 01b0 000050E3 		cmp	r0, #0
 1316 01b4 0D00001A 		bne	.L95
 941:../src/FreeRTOS/queue.c ****             {
 1317              		.loc 1 941 13 is_stmt 1 view .LVU410
 941:../src/FreeRTOS/queue.c ****             {
 1318              		.loc 1 941 17 is_stmt 0 view .LVU411
 1319 01b8 0400A0E1 		mov	r0, r4
 1320 01bc FEFFFFEB 		bl	prvIsQueueFull
 1321              	.LVL137:
 941:../src/FreeRTOS/queue.c ****             {
 1322              		.loc 1 941 15 view .LVU412
 1323 01c0 000050E3 		cmp	r0, #0
 1324 01c4 DBFFFF0A 		beq	.L96
 943:../src/FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1325              		.loc 1 943 55 is_stmt 1 view .LVU413
 944:../src/FreeRTOS/queue.c **** 
 1326              		.loc 1 944 17 view .LVU414
 1327 01c8 04109DE5 		ldr	r1, [sp, #4]
 1328 01cc 100084E2 		add	r0, r4, #16
 1329 01d0 FEFFFFEB 		bl	vTaskPlaceOnEventList
 1330              	.LVL138:
 951:../src/FreeRTOS/queue.c **** 
 1331              		.loc 1 951 17 view .LVU415
 1332 01d4 0400A0E1 		mov	r0, r4
 1333 01d8 FEFFFFEB 		bl	prvUnlockQueue
 1334              	.LVL139:
 958:../src/FreeRTOS/queue.c ****                 {
 1335              		.loc 1 958 17 view .LVU416
 958:../src/FreeRTOS/queue.c ****                 {
 1336              		.loc 1 958 21 is_stmt 0 view .LVU417
 1337 01dc FEFFFFEB 		bl	xTaskResumeAll
 1338              	.LVL140:
 958:../src/FreeRTOS/queue.c ****                 {
 1339              		.loc 1 958 19 view .LVU418
 1340 01e0 000050E3 		cmp	r0, #0
 1341 01e4 D6FFFF1A 		bne	.L85
 960:../src/FreeRTOS/queue.c ****                 }
 1342              		.loc 1 960 21 is_stmt 1 view .LVU419
 1343              		.syntax divided
 1344              	@ 960 "../src/FreeRTOS/queue.c" 1
 1345 01e8 000000EF 		SWI 0
 1346              	@ 0 "" 2
 1347              		.arm
 1348              		.syntax unified
 1349 01ec D4FFFFEA 		b	.L85
 1350              	.L95:
 973:../src/FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
 1351              		.loc 1 973 13 view .LVU420
 1352 01f0 0400A0E1 		mov	r0, r4
 1353 01f4 FEFFFFEB 		bl	prvUnlockQueue
 1354              	.LVL141:
 974:../src/FreeRTOS/queue.c **** 
 1355              		.loc 1 974 13 view .LVU421
 974:../src/FreeRTOS/queue.c **** 
 1356              		.loc 1 974 22 is_stmt 0 view .LVU422
 1357 01f8 FEFFFFEB 		bl	xTaskResumeAll
 1358              	.LVL142:
 976:../src/FreeRTOS/queue.c ****             return errQUEUE_FULL;
 1359              		.loc 1 976 46 is_stmt 1 view .LVU423
 977:../src/FreeRTOS/queue.c ****         }
 1360              		.loc 1 977 13 view .LVU424
 977:../src/FreeRTOS/queue.c ****         }
 1361              		.loc 1 977 20 is_stmt 0 view .LVU425
 1362 01fc 0000A0E3 		mov	r0, #0
 1363 0200 B7FFFFEA 		b	.L80
 1364              		.cfi_endproc
 1365              	.LFE10:
 1367              		.section	.text.prvInitialiseMutex,"ax",%progbits
 1368              		.align	2
 1369              		.syntax unified
 1370              		.arm
 1371              		.fpu neon
 1373              	prvInitialiseMutex:
 1374              	.LVL143:
 1375              	.LFB3:
 493:../src/FreeRTOS/queue.c ****         if( pxNewQueue != NULL )
 1376              		.loc 1 493 5 is_stmt 1 view -0
 1377              		.cfi_startproc
 1378              		@ args = 0, pretend = 0, frame = 0
 1379              		@ frame_needed = 0, uses_anonymous_args = 0
 494:../src/FreeRTOS/queue.c ****         {
 1380              		.loc 1 494 9 view .LVU427
 494:../src/FreeRTOS/queue.c ****         {
 1381              		.loc 1 494 11 is_stmt 0 view .LVU428
 1382 0000 000050E3 		cmp	r0, #0
 494:../src/FreeRTOS/queue.c ****         {
 1383              		.loc 1 494 11 view .LVU429
 1384 0004 1EFF2F01 		bxeq	lr
 493:../src/FreeRTOS/queue.c ****         if( pxNewQueue != NULL )
 1385              		.loc 1 493 5 view .LVU430
 1386 0008 10402DE9 		push	{r4, lr}
 1387              		.cfi_def_cfa_offset 8
 1388              		.cfi_offset 4, -8
 1389              		.cfi_offset 14, -4
 500:../src/FreeRTOS/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1390              		.loc 1 500 13 is_stmt 1 view .LVU431
 500:../src/FreeRTOS/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1391              		.loc 1 500 51 is_stmt 0 view .LVU432
 1392 000c 0010A0E3 		mov	r1, #0
 1393 0010 081080E5 		str	r1, [r0, #8]
 501:../src/FreeRTOS/queue.c **** 
 1394              		.loc 1 501 13 is_stmt 1 view .LVU433
 501:../src/FreeRTOS/queue.c **** 
 1395              		.loc 1 501 37 is_stmt 0 view .LVU434
 1396 0014 001080E5 		str	r1, [r0]
 504:../src/FreeRTOS/queue.c **** 
 1397              		.loc 1 504 13 is_stmt 1 view .LVU435
 504:../src/FreeRTOS/queue.c **** 
 1398              		.loc 1 504 59 is_stmt 0 view .LVU436
 1399 0018 0C1080E5 		str	r1, [r0, #12]
 506:../src/FreeRTOS/queue.c **** 
 1400              		.loc 1 506 44 is_stmt 1 view .LVU437
 509:../src/FreeRTOS/queue.c ****         }
 1401              		.loc 1 509 13 view .LVU438
 509:../src/FreeRTOS/queue.c ****         }
 1402              		.loc 1 509 22 is_stmt 0 view .LVU439
 1403 001c 0130A0E1 		mov	r3, r1
 1404 0020 0120A0E1 		mov	r2, r1
 1405 0024 FEFFFFEB 		bl	xQueueGenericSend
 1406              	.LVL144:
 513:../src/FreeRTOS/queue.c ****         }
 1407              		.loc 1 513 39 is_stmt 1 view .LVU440
 515:../src/FreeRTOS/queue.c **** 
 1408              		.loc 1 515 5 is_stmt 0 view .LVU441
 1409 0028 1080BDE8 		pop	{r4, pc}
 1410              		.cfi_endproc
 1411              	.LFE3:
 1413              		.section	.text.xQueueCreateMutex,"ax",%progbits
 1414              		.align	2
 1415              		.global	xQueueCreateMutex
 1416              		.syntax unified
 1417              		.arm
 1418              		.fpu neon
 1420              	xQueueCreateMutex:
 1421              	.LVL145:
 1422              	.LFB4:
 523:../src/FreeRTOS/queue.c ****         QueueHandle_t xNewQueue;
 1423              		.loc 1 523 5 is_stmt 1 view -0
 1424              		.cfi_startproc
 1425              		@ args = 0, pretend = 0, frame = 0
 1426              		@ frame_needed = 0, uses_anonymous_args = 0
 523:../src/FreeRTOS/queue.c ****         QueueHandle_t xNewQueue;
 1427              		.loc 1 523 5 is_stmt 0 view .LVU443
 1428 0000 10402DE9 		push	{r4, lr}
 1429              		.cfi_def_cfa_offset 8
 1430              		.cfi_offset 4, -8
 1431              		.cfi_offset 14, -4
 1432 0004 0020A0E1 		mov	r2, r0
 524:../src/FreeRTOS/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 1433              		.loc 1 524 9 is_stmt 1 view .LVU444
 525:../src/FreeRTOS/queue.c **** 
 1434              		.loc 1 525 9 view .LVU445
 1435              	.LVL146:
 527:../src/FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1436              		.loc 1 527 9 view .LVU446
 527:../src/FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1437              		.loc 1 527 21 is_stmt 0 view .LVU447
 1438 0008 0010A0E3 		mov	r1, #0
 1439 000c 0100A0E3 		mov	r0, #1
 1440              	.LVL147:
 527:../src/FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1441              		.loc 1 527 21 view .LVU448
 1442 0010 FEFFFFEB 		bl	xQueueGenericCreate
 1443              	.LVL148:
 1444 0014 0040A0E1 		mov	r4, r0
 1445              	.LVL149:
 528:../src/FreeRTOS/queue.c **** 
 1446              		.loc 1 528 9 is_stmt 1 view .LVU449
 1447 0018 FEFFFFEB 		bl	prvInitialiseMutex
 1448              	.LVL150:
 530:../src/FreeRTOS/queue.c ****     }
 1449              		.loc 1 530 9 view .LVU450
 531:../src/FreeRTOS/queue.c **** 
 1450              		.loc 1 531 5 is_stmt 0 view .LVU451
 1451 001c 0400A0E1 		mov	r0, r4
 1452 0020 1080BDE8 		pop	{r4, pc}
 1453              		.cfi_endproc
 1454              	.LFE4:
 1456              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 1457              		.align	2
 1458              		.global	xQueueGiveMutexRecursive
 1459              		.syntax unified
 1460              		.arm
 1461              		.fpu neon
 1463              	xQueueGiveMutexRecursive:
 1464              	.LVL151:
 1465              	.LFB7:
 617:../src/FreeRTOS/queue.c ****         BaseType_t xReturn;
 1466              		.loc 1 617 5 is_stmt 1 view -0
 1467              		.cfi_startproc
 1468              		@ args = 0, pretend = 0, frame = 0
 1469              		@ frame_needed = 0, uses_anonymous_args = 0
 617:../src/FreeRTOS/queue.c ****         BaseType_t xReturn;
 1470              		.loc 1 617 5 is_stmt 0 view .LVU453
 1471 0000 70402DE9 		push	{r4, r5, r6, lr}
 1472              		.cfi_def_cfa_offset 16
 1473              		.cfi_offset 4, -16
 1474              		.cfi_offset 5, -12
 1475              		.cfi_offset 6, -8
 1476              		.cfi_offset 14, -4
 618:../src/FreeRTOS/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 1477              		.loc 1 618 9 is_stmt 1 view .LVU454
 619:../src/FreeRTOS/queue.c **** 
 1478              		.loc 1 619 9 view .LVU455
 1479              	.LVL152:
 621:../src/FreeRTOS/queue.c **** 
 1480              		.loc 1 621 9 view .LVU456
 1481 0004 004050E2 		subs	r4, r0, #0
 1482 0008 0500000A 		beq	.L122
 1483              	.LVL153:
 1484              	.L117:
 621:../src/FreeRTOS/queue.c **** 
 1485              		.loc 1 621 32 discriminator 3 view .LVU457
 629:../src/FreeRTOS/queue.c ****         {
 1486              		.loc 1 629 9 discriminator 3 view .LVU458
 629:../src/FreeRTOS/queue.c ****         {
 1487              		.loc 1 629 34 is_stmt 0 discriminator 3 view .LVU459
 1488 000c 085094E5 		ldr	r5, [r4, #8]
 629:../src/FreeRTOS/queue.c ****         {
 1489              		.loc 1 629 51 discriminator 3 view .LVU460
 1490 0010 FEFFFFEB 		bl	xTaskGetCurrentTaskHandle
 1491              	.LVL154:
 629:../src/FreeRTOS/queue.c ****         {
 1492              		.loc 1 629 11 discriminator 3 view .LVU461
 1493 0014 000055E1 		cmp	r5, r0
 1494 0018 0600000A 		beq	.L123
 658:../src/FreeRTOS/queue.c **** 
 1495              		.loc 1 658 21 view .LVU462
 1496 001c 0000A0E3 		mov	r0, #0
 1497 0020 7080BDE8 		pop	{r4, r5, r6, pc}
 1498              	.LVL155:
 1499              	.L122:
 621:../src/FreeRTOS/queue.c **** 
 1500              		.loc 1 621 9 is_stmt 1 discriminator 1 view .LVU463
 1501 0024 6D1200E3 		movw	r1, #621
 1502 0028 000000E3 		movw	r0, #:lower16:.LC0
 1503              	.LVL156:
 621:../src/FreeRTOS/queue.c **** 
 1504              		.loc 1 621 9 is_stmt 0 discriminator 1 view .LVU464
 1505 002c 000040E3 		movt	r0, #:upper16:.LC0
 1506 0030 FEFFFFEB 		bl	R_OS_AssertCalled
 1507              	.LVL157:
 1508 0034 F4FFFFEA 		b	.L117
 1509              	.L123:
 631:../src/FreeRTOS/queue.c **** 
 1510              		.loc 1 631 49 is_stmt 1 view .LVU465
 638:../src/FreeRTOS/queue.c **** 
 1511              		.loc 1 638 13 view .LVU466
 638:../src/FreeRTOS/queue.c **** 
 1512              		.loc 1 638 36 is_stmt 0 view .LVU467
 1513 0038 0C3094E5 		ldr	r3, [r4, #12]
 638:../src/FreeRTOS/queue.c **** 
 1514              		.loc 1 638 59 view .LVU468
 1515 003c 013043E2 		sub	r3, r3, #1
 1516 0040 0C3084E5 		str	r3, [r4, #12]
 641:../src/FreeRTOS/queue.c ****             {
 1517              		.loc 1 641 13 is_stmt 1 view .LVU469
 641:../src/FreeRTOS/queue.c ****             {
 1518              		.loc 1 641 15 is_stmt 0 view .LVU470
 1519 0044 000053E3 		cmp	r3, #0
 1520 0048 0100000A 		beq	.L124
 652:../src/FreeRTOS/queue.c ****         }
 1521              		.loc 1 652 21 view .LVU471
 1522 004c 0100A0E3 		mov	r0, #1
 1523              	.LVL158:
 660:../src/FreeRTOS/queue.c ****         }
 1524              		.loc 1 660 56 is_stmt 1 view .LVU472
 663:../src/FreeRTOS/queue.c ****     }
 1525              		.loc 1 663 9 view .LVU473
 664:../src/FreeRTOS/queue.c **** 
 1526              		.loc 1 664 5 is_stmt 0 view .LVU474
 1527 0050 7080BDE8 		pop	{r4, r5, r6, pc}
 1528              	.LVL159:
 1529              	.L124:
 645:../src/FreeRTOS/queue.c ****             }
 1530              		.loc 1 645 17 is_stmt 1 view .LVU475
 645:../src/FreeRTOS/queue.c ****             }
 1531              		.loc 1 645 26 is_stmt 0 view .LVU476
 1532 0054 0320A0E1 		mov	r2, r3
 1533 0058 0310A0E1 		mov	r1, r3
 1534 005c 0400A0E1 		mov	r0, r4
 1535 0060 FEFFFFEB 		bl	xQueueGenericSend
 1536              	.LVL160:
 652:../src/FreeRTOS/queue.c ****         }
 1537              		.loc 1 652 21 view .LVU477
 1538 0064 0100A0E3 		mov	r0, #1
 1539 0068 7080BDE8 		pop	{r4, r5, r6, pc}
 1540              		.cfi_endproc
 1541              	.LFE7:
 1543              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 1544              		.align	2
 1545              		.global	xQueueGenericSendFromISR
 1546              		.syntax unified
 1547              		.arm
 1548              		.fpu neon
 1550              	xQueueGenericSendFromISR:
 1551              	.LVL161:
 1552              	.LFB11:
 987:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 1553              		.loc 1 987 1 is_stmt 1 view -0
 1554              		.cfi_startproc
 1555              		@ args = 0, pretend = 0, frame = 0
 1556              		@ frame_needed = 0, uses_anonymous_args = 0
 987:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 1557              		.loc 1 987 1 is_stmt 0 view .LVU479
 1558 0000 F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1559              		.cfi_def_cfa_offset 32
 1560              		.cfi_offset 4, -32
 1561              		.cfi_offset 5, -28
 1562              		.cfi_offset 6, -24
 1563              		.cfi_offset 7, -20
 1564              		.cfi_offset 8, -16
 1565              		.cfi_offset 9, -12
 1566              		.cfi_offset 10, -8
 1567              		.cfi_offset 14, -4
 1568 0004 0160A0E1 		mov	r6, r1
 1569 0008 0290A0E1 		mov	r9, r2
 1570 000c 0350A0E1 		mov	r5, r3
 988:../src/FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 1571              		.loc 1 988 5 is_stmt 1 view .LVU480
 989:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 1572              		.loc 1 989 5 view .LVU481
 990:../src/FreeRTOS/queue.c **** 
 1573              		.loc 1 990 5 view .LVU482
 1574              	.LVL162:
 992:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1575              		.loc 1 992 5 view .LVU483
 1576 0010 004050E2 		subs	r4, r0, #0
 1577 0014 1100000A 		beq	.L138
 1578              	.LVL163:
 1579              	.L126:
 992:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1580              		.loc 1 992 28 discriminator 3 view .LVU484
 993:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1581              		.loc 1 993 5 discriminator 3 view .LVU485
 1582 0018 000056E3 		cmp	r6, #0
 1583 001c 1400000A 		beq	.L139
 1584              	.L127:
 993:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1585              		.loc 1 993 100 discriminator 9 view .LVU486
 994:../src/FreeRTOS/queue.c **** 
 1586              		.loc 1 994 5 discriminator 9 view .LVU487
 1587 0020 020055E3 		cmp	r5, #2
 1588 0024 1A00000A 		beq	.L140
 1589              	.L128:
 994:../src/FreeRTOS/queue.c **** 
 1590              		.loc 1 994 91 discriminator 9 view .LVU488
1010:../src/FreeRTOS/queue.c **** 
 1591              		.loc 1 1010 5 discriminator 9 view .LVU489
 1592 0028 FEFFFFEB 		bl	vPortValidateInterruptPriority
 1593              	.LVL164:
1017:../src/FreeRTOS/queue.c ****     {
 1594              		.loc 1 1017 5 discriminator 9 view .LVU490
1017:../src/FreeRTOS/queue.c ****     {
 1595              		.loc 1 1017 30 is_stmt 0 discriminator 9 view .LVU491
 1596 002c FEFFFFEB 		bl	ulPortSetInterruptMask
 1597              	.LVL165:
 1598 0030 0080A0E1 		mov	r8, r0
 1599              	.LVL166:
1019:../src/FreeRTOS/queue.c ****         {
 1600              		.loc 1 1019 9 is_stmt 1 discriminator 9 view .LVU492
1019:../src/FreeRTOS/queue.c ****         {
 1601              		.loc 1 1019 22 is_stmt 0 discriminator 9 view .LVU493
 1602 0034 382094E5 		ldr	r2, [r4, #56]
1019:../src/FreeRTOS/queue.c ****         {
 1603              		.loc 1 1019 51 discriminator 9 view .LVU494
 1604 0038 3C3094E5 		ldr	r3, [r4, #60]
1019:../src/FreeRTOS/queue.c ****         {
 1605              		.loc 1 1019 11 discriminator 9 view .LVU495
 1606 003c 030052E1 		cmp	r2, r3
 1607 0040 1B00003A 		bcc	.L129
1019:../src/FreeRTOS/queue.c ****         {
 1608              		.loc 1 1019 64 discriminator 1 view .LVU496
 1609 0044 020055E3 		cmp	r5, #2
 1610 0048 1900000A 		beq	.L129
1141:../src/FreeRTOS/queue.c ****         }
 1611              		.loc 1 1141 21 view .LVU497
 1612 004c 0040A0E3 		mov	r4, #0
 1613              	.LVL167:
 1614              	.L130:
1144:../src/FreeRTOS/queue.c **** 
 1615              		.loc 1 1144 5 is_stmt 1 view .LVU498
 1616 0050 0800A0E1 		mov	r0, r8
 1617 0054 FEFFFFEB 		bl	vPortClearInterruptMask
 1618              	.LVL168:
1146:../src/FreeRTOS/queue.c **** }
 1619              		.loc 1 1146 5 view .LVU499
1147:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 1620              		.loc 1 1147 1 is_stmt 0 view .LVU500
 1621 0058 0400A0E1 		mov	r0, r4
 1622 005c F087BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1623              	.LVL169:
 1624              	.L138:
 992:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1625              		.loc 1 992 5 is_stmt 1 discriminator 1 view .LVU501
 1626 0060 3E1EA0E3 		mov	r1, #992
 1627              	.LVL170:
 992:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1628              		.loc 1 992 5 is_stmt 0 discriminator 1 view .LVU502
 1629 0064 000000E3 		movw	r0, #:lower16:.LC0
 1630              	.LVL171:
 992:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1631              		.loc 1 992 5 discriminator 1 view .LVU503
 1632 0068 000040E3 		movt	r0, #:upper16:.LC0
 1633 006c FEFFFFEB 		bl	R_OS_AssertCalled
 1634              	.LVL172:
 992:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1635              		.loc 1 992 5 discriminator 1 view .LVU504
 1636 0070 E8FFFFEA 		b	.L126
 1637              	.L139:
 993:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1638              		.loc 1 993 5 discriminator 2 view .LVU505
 1639 0074 403094E5 		ldr	r3, [r4, #64]
 1640 0078 000053E3 		cmp	r3, #0
 1641 007c E7FFFF0A 		beq	.L127
 993:../src/FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1642              		.loc 1 993 5 is_stmt 1 view .LVU506
 1643 0080 E11300E3 		movw	r1, #993
 1644 0084 000000E3 		movw	r0, #:lower16:.LC0
 1645 0088 000040E3 		movt	r0, #:upper16:.LC0
 1646 008c FEFFFFEB 		bl	R_OS_AssertCalled
 1647              	.LVL173:
 1648 0090 E2FFFFEA 		b	.L127
 1649              	.L140:
 994:../src/FreeRTOS/queue.c **** 
 1650              		.loc 1 994 5 is_stmt 0 discriminator 2 view .LVU507
 1651 0094 3C3094E5 		ldr	r3, [r4, #60]
 1652 0098 010053E3 		cmp	r3, #1
 1653 009c E1FFFF0A 		beq	.L128
 994:../src/FreeRTOS/queue.c **** 
 1654              		.loc 1 994 5 is_stmt 1 view .LVU508
 1655 00a0 E21300E3 		movw	r1, #994
 1656 00a4 000000E3 		movw	r0, #:lower16:.LC0
 1657 00a8 000040E3 		movt	r0, #:upper16:.LC0
 1658 00ac FEFFFFEB 		bl	R_OS_AssertCalled
 1659              	.LVL174:
 1660 00b0 DCFFFFEA 		b	.L128
 1661              	.LVL175:
 1662              	.L129:
 1663              	.LBB4:
1021:../src/FreeRTOS/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1664              		.loc 1 1021 13 view .LVU509
1021:../src/FreeRTOS/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1665              		.loc 1 1021 26 is_stmt 0 view .LVU510
 1666 00b4 4570D4E5 		ldrb	r7, [r4, #69]	@ zero_extendqisi2
 1667 00b8 7770AFE6 		sxtb	r7, r7
 1668              	.LVL176:
1022:../src/FreeRTOS/queue.c **** 
 1669              		.loc 1 1022 13 is_stmt 1 view .LVU511
1022:../src/FreeRTOS/queue.c **** 
 1670              		.loc 1 1022 31 is_stmt 0 view .LVU512
 1671 00bc 383094E5 		ldr	r3, [r4, #56]
1024:../src/FreeRTOS/queue.c **** 
 1672              		.loc 1 1024 48 is_stmt 1 view .LVU513
1031:../src/FreeRTOS/queue.c **** 
 1673              		.loc 1 1031 13 view .LVU514
1031:../src/FreeRTOS/queue.c **** 
 1674              		.loc 1 1031 22 is_stmt 0 view .LVU515
 1675 00c0 0520A0E1 		mov	r2, r5
 1676 00c4 0610A0E1 		mov	r1, r6
 1677 00c8 0400A0E1 		mov	r0, r4
 1678              	.LVL177:
1031:../src/FreeRTOS/queue.c **** 
 1679              		.loc 1 1031 22 view .LVU516
 1680 00cc FEFFFFEB 		bl	prvCopyDataToQueue
 1681              	.LVL178:
1035:../src/FreeRTOS/queue.c ****             {
 1682              		.loc 1 1035 13 is_stmt 1 view .LVU517
1035:../src/FreeRTOS/queue.c ****             {
 1683              		.loc 1 1035 15 is_stmt 0 view .LVU518
 1684 00d0 010077E3 		cmn	r7, #1
 1685 00d4 0600000A 		beq	.L141
1131:../src/FreeRTOS/queue.c **** 
 1686              		.loc 1 1131 17 is_stmt 1 view .LVU519
 1687 00d8 7F0057E3 		cmp	r7, #127
 1688 00dc 1100000A 		beq	.L142
 1689              	.L132:
1131:../src/FreeRTOS/queue.c **** 
 1690              		.loc 1 1131 57 discriminator 3 view .LVU520
1133:../src/FreeRTOS/queue.c ****             }
 1691              		.loc 1 1133 17 discriminator 3 view .LVU521
1133:../src/FreeRTOS/queue.c ****             }
 1692              		.loc 1 1133 57 is_stmt 0 discriminator 3 view .LVU522
 1693 00e0 017087E2 		add	r7, r7, #1
 1694              	.LVL179:
1133:../src/FreeRTOS/queue.c ****             }
 1695              		.loc 1 1133 36 discriminator 3 view .LVU523
 1696 00e4 7770AFE6 		sxtb	r7, r7
 1697              	.LVL180:
1133:../src/FreeRTOS/queue.c ****             }
 1698              		.loc 1 1133 34 discriminator 3 view .LVU524
 1699 00e8 4570C4E5 		strb	r7, [r4, #69]
1136:../src/FreeRTOS/queue.c ****         }
 1700              		.loc 1 1136 21 discriminator 3 view .LVU525
 1701 00ec 0140A0E3 		mov	r4, #1
 1702              	.LVL181:
1136:../src/FreeRTOS/queue.c ****         }
 1703              		.loc 1 1136 21 discriminator 3 view .LVU526
 1704 00f0 D6FFFFEA 		b	.L130
 1705              	.LVL182:
 1706              	.L141:
1097:../src/FreeRTOS/queue.c ****                         {
 1707              		.loc 1 1097 25 is_stmt 1 view .LVU527
1097:../src/FreeRTOS/queue.c ****                         {
 1708              		.loc 1 1097 29 is_stmt 0 view .LVU528
 1709 00f4 243094E5 		ldr	r3, [r4, #36]
1097:../src/FreeRTOS/queue.c ****                         {
 1710              		.loc 1 1097 27 view .LVU529
 1711 00f8 000053E3 		cmp	r3, #0
1136:../src/FreeRTOS/queue.c ****         }
 1712              		.loc 1 1136 21 view .LVU530
 1713 00fc 0140A003 		moveq	r4, #1
 1714              	.LVL183:
1136:../src/FreeRTOS/queue.c ****         }
 1715              		.loc 1 1136 21 view .LVU531
 1716 0100 D2FFFF0A 		beq	.L130
 1717              	.LVL184:
 1718              	.L143:
1099:../src/FreeRTOS/queue.c ****                             {
 1719              		.loc 1 1099 29 is_stmt 1 view .LVU532
1099:../src/FreeRTOS/queue.c ****                             {
 1720              		.loc 1 1099 33 is_stmt 0 view .LVU533
 1721 0104 240084E2 		add	r0, r4, #36
 1722 0108 FEFFFFEB 		bl	xTaskRemoveFromEventList
 1723              	.LVL185:
1099:../src/FreeRTOS/queue.c ****                             {
 1724              		.loc 1 1099 31 view .LVU534
 1725 010c 000050E3 		cmp	r0, #0
 1726 0110 0900000A 		beq	.L135
1103:../src/FreeRTOS/queue.c ****                                 {
 1727              		.loc 1 1103 33 is_stmt 1 view .LVU535
1103:../src/FreeRTOS/queue.c ****                                 {
 1728              		.loc 1 1103 35 is_stmt 0 view .LVU536
 1729 0114 000059E3 		cmp	r9, #0
 1730 0118 0900000A 		beq	.L136
1105:../src/FreeRTOS/queue.c ****                                 }
 1731              		.loc 1 1105 37 is_stmt 1 view .LVU537
1105:../src/FreeRTOS/queue.c ****                                 }
 1732              		.loc 1 1105 64 is_stmt 0 view .LVU538
 1733 011c 0140A0E3 		mov	r4, #1
 1734              	.LVL186:
1105:../src/FreeRTOS/queue.c ****                                 }
 1735              		.loc 1 1105 64 view .LVU539
 1736 0120 004089E5 		str	r4, [r9]
 1737 0124 C9FFFFEA 		b	.L130
 1738              	.LVL187:
 1739              	.L142:
1131:../src/FreeRTOS/queue.c **** 
 1740              		.loc 1 1131 17 is_stmt 1 discriminator 1 view .LVU540
 1741 0128 6B1400E3 		movw	r1, #1131
 1742 012c 000000E3 		movw	r0, #:lower16:.LC0
 1743 0130 000040E3 		movt	r0, #:upper16:.LC0
 1744 0134 FEFFFFEB 		bl	R_OS_AssertCalled
 1745              	.LVL188:
 1746 0138 E8FFFFEA 		b	.L132
 1747              	.L135:
1136:../src/FreeRTOS/queue.c ****         }
 1748              		.loc 1 1136 21 is_stmt 0 view .LVU541
 1749 013c 0140A0E3 		mov	r4, #1
 1750              	.LVL189:
1136:../src/FreeRTOS/queue.c ****         }
 1751              		.loc 1 1136 21 view .LVU542
 1752 0140 C2FFFFEA 		b	.L130
 1753              	.LVL190:
 1754              	.L136:
1136:../src/FreeRTOS/queue.c ****         }
 1755              		.loc 1 1136 21 view .LVU543
 1756 0144 0140A0E3 		mov	r4, #1
 1757              	.LVL191:
1136:../src/FreeRTOS/queue.c ****         }
 1758              		.loc 1 1136 21 view .LVU544
 1759 0148 C0FFFFEA 		b	.L130
 1760              	.LBE4:
 1761              		.cfi_endproc
 1762              	.LFE11:
 1764              		.section	.text.xQueueGiveFromISR,"ax",%progbits
 1765              		.align	2
 1766              		.global	xQueueGiveFromISR
 1767              		.syntax unified
 1768              		.arm
 1769              		.fpu neon
 1771              	xQueueGiveFromISR:
 1772              	.LVL192:
 1773              	.LFB12:
1152:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 1774              		.loc 1 1152 1 is_stmt 1 view -0
 1775              		.cfi_startproc
 1776              		@ args = 0, pretend = 0, frame = 0
 1777              		@ frame_needed = 0, uses_anonymous_args = 0
1152:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 1778              		.loc 1 1152 1 is_stmt 0 view .LVU546
 1779 0000 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 1780              		.cfi_def_cfa_offset 24
 1781              		.cfi_offset 4, -24
 1782              		.cfi_offset 5, -20
 1783              		.cfi_offset 6, -16
 1784              		.cfi_offset 7, -12
 1785              		.cfi_offset 8, -8
 1786              		.cfi_offset 14, -4
 1787 0004 0170A0E1 		mov	r7, r1
1153:../src/FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 1788              		.loc 1 1153 5 is_stmt 1 view .LVU547
1154:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 1789              		.loc 1 1154 5 view .LVU548
1155:../src/FreeRTOS/queue.c **** 
 1790              		.loc 1 1155 5 view .LVU549
 1791              	.LVL193:
1163:../src/FreeRTOS/queue.c **** 
 1792              		.loc 1 1163 5 view .LVU550
 1793 0008 004050E2 		subs	r4, r0, #0
 1794 000c 1900000A 		beq	.L156
 1795              	.LVL194:
 1796              	.L145:
1163:../src/FreeRTOS/queue.c **** 
 1797              		.loc 1 1163 28 discriminator 3 view .LVU551
1167:../src/FreeRTOS/queue.c **** 
 1798              		.loc 1 1167 5 discriminator 3 view .LVU552
 1799 0010 403094E5 		ldr	r3, [r4, #64]
 1800 0014 000053E3 		cmp	r3, #0
 1801 0018 1B00001A 		bne	.L157
 1802              	.L146:
1167:../src/FreeRTOS/queue.c **** 
 1803              		.loc 1 1167 45 discriminator 3 view .LVU553
1172:../src/FreeRTOS/queue.c **** 
 1804              		.loc 1 1172 5 discriminator 3 view .LVU554
 1805 001c 003094E5 		ldr	r3, [r4]
 1806 0020 000053E3 		cmp	r3, #0
 1807 0024 1D00000A 		beq	.L158
 1808              	.L147:
1172:../src/FreeRTOS/queue.c **** 
 1809              		.loc 1 1172 123 discriminator 9 view .LVU555
1188:../src/FreeRTOS/queue.c **** 
 1810              		.loc 1 1188 5 discriminator 9 view .LVU556
 1811 0028 FEFFFFEB 		bl	vPortValidateInterruptPriority
 1812              	.LVL195:
1190:../src/FreeRTOS/queue.c ****     {
 1813              		.loc 1 1190 5 discriminator 9 view .LVU557
1190:../src/FreeRTOS/queue.c ****     {
 1814              		.loc 1 1190 30 is_stmt 0 discriminator 9 view .LVU558
 1815 002c FEFFFFEB 		bl	ulPortSetInterruptMask
 1816              	.LVL196:
 1817 0030 0050A0E1 		mov	r5, r0
 1818              	.LVL197:
 1819              	.LBB5:
1192:../src/FreeRTOS/queue.c **** 
 1820              		.loc 1 1192 9 is_stmt 1 discriminator 9 view .LVU559
1192:../src/FreeRTOS/queue.c **** 
 1821              		.loc 1 1192 27 is_stmt 0 discriminator 9 view .LVU560
 1822 0034 383094E5 		ldr	r3, [r4, #56]
 1823              	.LVL198:
1197:../src/FreeRTOS/queue.c ****         {
 1824              		.loc 1 1197 9 is_stmt 1 discriminator 9 view .LVU561
1197:../src/FreeRTOS/queue.c ****         {
 1825              		.loc 1 1197 40 is_stmt 0 discriminator 9 view .LVU562
 1826 0038 3C2094E5 		ldr	r2, [r4, #60]
1197:../src/FreeRTOS/queue.c ****         {
 1827              		.loc 1 1197 11 discriminator 9 view .LVU563
 1828 003c 030052E1 		cmp	r2, r3
 1829 0040 3000009A 		bls	.L151
 1830              	.LBB6:
1199:../src/FreeRTOS/queue.c **** 
 1831              		.loc 1 1199 13 is_stmt 1 view .LVU564
1199:../src/FreeRTOS/queue.c **** 
 1832              		.loc 1 1199 26 is_stmt 0 view .LVU565
 1833 0044 4560D4E5 		ldrb	r6, [r4, #69]	@ zero_extendqisi2
 1834 0048 7660AFE6 		sxtb	r6, r6
 1835              	.LVL199:
1201:../src/FreeRTOS/queue.c **** 
 1836              		.loc 1 1201 48 is_stmt 1 view .LVU566
1209:../src/FreeRTOS/queue.c **** 
 1837              		.loc 1 1209 13 view .LVU567
1209:../src/FreeRTOS/queue.c **** 
 1838              		.loc 1 1209 60 is_stmt 0 view .LVU568
 1839 004c 013083E2 		add	r3, r3, #1
 1840              	.LVL200:
1209:../src/FreeRTOS/queue.c **** 
 1841              		.loc 1 1209 40 view .LVU569
 1842 0050 383084E5 		str	r3, [r4, #56]
1213:../src/FreeRTOS/queue.c ****             {
 1843              		.loc 1 1213 13 is_stmt 1 view .LVU570
1213:../src/FreeRTOS/queue.c ****             {
 1844              		.loc 1 1213 15 is_stmt 0 view .LVU571
 1845 0054 010076E3 		cmn	r6, #1
 1846 0058 1800000A 		beq	.L159
1299:../src/FreeRTOS/queue.c **** 
 1847              		.loc 1 1299 17 is_stmt 1 view .LVU572
 1848 005c 7F0056E3 		cmp	r6, #127
 1849 0060 2300000A 		beq	.L160
 1850              	.LVL201:
 1851              	.L150:
1299:../src/FreeRTOS/queue.c **** 
 1852              		.loc 1 1299 57 discriminator 3 view .LVU573
1301:../src/FreeRTOS/queue.c ****             }
 1853              		.loc 1 1301 17 discriminator 3 view .LVU574
1301:../src/FreeRTOS/queue.c ****             }
 1854              		.loc 1 1301 57 is_stmt 0 discriminator 3 view .LVU575
 1855 0064 016086E2 		add	r6, r6, #1
 1856              	.LVL202:
1301:../src/FreeRTOS/queue.c ****             }
 1857              		.loc 1 1301 36 discriminator 3 view .LVU576
 1858 0068 7660AFE6 		sxtb	r6, r6
 1859              	.LVL203:
1301:../src/FreeRTOS/queue.c ****             }
 1860              		.loc 1 1301 34 discriminator 3 view .LVU577
 1861 006c 4560C4E5 		strb	r6, [r4, #69]
1304:../src/FreeRTOS/queue.c ****         }
 1862              		.loc 1 1304 21 discriminator 3 view .LVU578
 1863 0070 0140A0E3 		mov	r4, #1
 1864              	.LVL204:
1304:../src/FreeRTOS/queue.c ****         }
 1865              		.loc 1 1304 21 discriminator 3 view .LVU579
 1866 0074 240000EA 		b	.L148
 1867              	.LVL205:
 1868              	.L156:
1304:../src/FreeRTOS/queue.c ****         }
 1869              		.loc 1 1304 21 discriminator 3 view .LVU580
 1870              	.LBE6:
 1871              	.LBE5:
1163:../src/FreeRTOS/queue.c **** 
 1872              		.loc 1 1163 5 is_stmt 1 discriminator 1 view .LVU581
 1873 0078 8B1400E3 		movw	r1, #1163
 1874              	.LVL206:
1163:../src/FreeRTOS/queue.c **** 
 1875              		.loc 1 1163 5 is_stmt 0 discriminator 1 view .LVU582
 1876 007c 000000E3 		movw	r0, #:lower16:.LC0
 1877              	.LVL207:
1163:../src/FreeRTOS/queue.c **** 
 1878              		.loc 1 1163 5 discriminator 1 view .LVU583
 1879 0080 000040E3 		movt	r0, #:upper16:.LC0
 1880 0084 FEFFFFEB 		bl	R_OS_AssertCalled
 1881              	.LVL208:
 1882 0088 E0FFFFEA 		b	.L145
 1883              	.L157:
1167:../src/FreeRTOS/queue.c **** 
 1884              		.loc 1 1167 5 is_stmt 1 discriminator 1 view .LVU584
 1885 008c 8F1400E3 		movw	r1, #1167
 1886 0090 000000E3 		movw	r0, #:lower16:.LC0
 1887 0094 000040E3 		movt	r0, #:upper16:.LC0
 1888 0098 FEFFFFEB 		bl	R_OS_AssertCalled
 1889              	.LVL209:
 1890 009c DEFFFFEA 		b	.L146
 1891              	.L158:
1172:../src/FreeRTOS/queue.c **** 
 1892              		.loc 1 1172 5 is_stmt 0 discriminator 2 view .LVU585
 1893 00a0 083094E5 		ldr	r3, [r4, #8]
 1894 00a4 000053E3 		cmp	r3, #0
 1895 00a8 DEFFFF0A 		beq	.L147
1172:../src/FreeRTOS/queue.c **** 
 1896              		.loc 1 1172 5 is_stmt 1 view .LVU586
 1897 00ac 941400E3 		movw	r1, #1172
 1898 00b0 000000E3 		movw	r0, #:lower16:.LC0
 1899 00b4 000040E3 		movt	r0, #:upper16:.LC0
 1900 00b8 FEFFFFEB 		bl	R_OS_AssertCalled
 1901              	.LVL210:
 1902 00bc D9FFFFEA 		b	.L147
 1903              	.LVL211:
 1904              	.L159:
 1905              	.LBB9:
 1906              	.LBB7:
1268:../src/FreeRTOS/queue.c ****                         {
 1907              		.loc 1 1268 25 view .LVU587
1268:../src/FreeRTOS/queue.c ****                         {
 1908              		.loc 1 1268 29 is_stmt 0 view .LVU588
 1909 00c0 243094E5 		ldr	r3, [r4, #36]
 1910              	.LVL212:
1268:../src/FreeRTOS/queue.c ****                         {
 1911              		.loc 1 1268 27 view .LVU589
 1912 00c4 000053E3 		cmp	r3, #0
1304:../src/FreeRTOS/queue.c ****         }
 1913              		.loc 1 1304 21 view .LVU590
 1914 00c8 0140A003 		moveq	r4, #1
 1915              	.LVL213:
1304:../src/FreeRTOS/queue.c ****         }
 1916              		.loc 1 1304 21 view .LVU591
 1917 00cc 0E00000A 		beq	.L148
 1918              	.LVL214:
 1919              	.L161:
1270:../src/FreeRTOS/queue.c ****                             {
 1920              		.loc 1 1270 29 is_stmt 1 view .LVU592
1270:../src/FreeRTOS/queue.c ****                             {
 1921              		.loc 1 1270 33 is_stmt 0 view .LVU593
 1922 00d0 240084E2 		add	r0, r4, #36
 1923              	.LVL215:
1270:../src/FreeRTOS/queue.c ****                             {
 1924              		.loc 1 1270 33 view .LVU594
 1925 00d4 FEFFFFEB 		bl	xTaskRemoveFromEventList
 1926              	.LVL216:
1270:../src/FreeRTOS/queue.c ****                             {
 1927              		.loc 1 1270 31 view .LVU595
 1928 00d8 000050E3 		cmp	r0, #0
 1929 00dc 0E00000A 		beq	.L153
1274:../src/FreeRTOS/queue.c ****                                 {
 1930              		.loc 1 1274 33 is_stmt 1 view .LVU596
1274:../src/FreeRTOS/queue.c ****                                 {
 1931              		.loc 1 1274 35 is_stmt 0 view .LVU597
 1932 00e0 000057E3 		cmp	r7, #0
 1933 00e4 0E00000A 		beq	.L154
1276:../src/FreeRTOS/queue.c ****                                 }
 1934              		.loc 1 1276 37 is_stmt 1 view .LVU598
1276:../src/FreeRTOS/queue.c ****                                 }
 1935              		.loc 1 1276 64 is_stmt 0 view .LVU599
 1936 00e8 0140A0E3 		mov	r4, #1
 1937              	.LVL217:
1276:../src/FreeRTOS/queue.c ****                                 }
 1938              		.loc 1 1276 64 view .LVU600
 1939 00ec 004087E5 		str	r4, [r7]
 1940 00f0 050000EA 		b	.L148
 1941              	.LVL218:
 1942              	.L160:
1299:../src/FreeRTOS/queue.c **** 
 1943              		.loc 1 1299 17 is_stmt 1 discriminator 1 view .LVU601
 1944 00f4 131500E3 		movw	r1, #1299
 1945 00f8 000000E3 		movw	r0, #:lower16:.LC0
 1946              	.LVL219:
1299:../src/FreeRTOS/queue.c **** 
 1947              		.loc 1 1299 17 is_stmt 0 discriminator 1 view .LVU602
 1948 00fc 000040E3 		movt	r0, #:upper16:.LC0
 1949 0100 FEFFFFEB 		bl	R_OS_AssertCalled
 1950              	.LVL220:
1299:../src/FreeRTOS/queue.c **** 
 1951              		.loc 1 1299 17 discriminator 1 view .LVU603
 1952 0104 D6FFFFEA 		b	.L150
 1953              	.LVL221:
 1954              	.L151:
1299:../src/FreeRTOS/queue.c **** 
 1955              		.loc 1 1299 17 discriminator 1 view .LVU604
 1956              	.LBE7:
1309:../src/FreeRTOS/queue.c ****         }
 1957              		.loc 1 1309 21 view .LVU605
 1958 0108 0040A0E3 		mov	r4, #0
 1959              	.LVL222:
 1960              	.L148:
1309:../src/FreeRTOS/queue.c ****         }
 1961              		.loc 1 1309 21 view .LVU606
 1962              	.LBE9:
1312:../src/FreeRTOS/queue.c **** 
 1963              		.loc 1 1312 5 is_stmt 1 view .LVU607
 1964 010c 0500A0E1 		mov	r0, r5
 1965 0110 FEFFFFEB 		bl	vPortClearInterruptMask
 1966              	.LVL223:
1314:../src/FreeRTOS/queue.c **** }
 1967              		.loc 1 1314 5 view .LVU608
1315:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 1968              		.loc 1 1315 1 is_stmt 0 view .LVU609
 1969 0114 0400A0E1 		mov	r0, r4
 1970 0118 F081BDE8 		pop	{r4, r5, r6, r7, r8, pc}
 1971              	.LVL224:
 1972              	.L153:
 1973              	.LBB10:
 1974              	.LBB8:
1304:../src/FreeRTOS/queue.c ****         }
 1975              		.loc 1 1304 21 view .LVU610
 1976 011c 0140A0E3 		mov	r4, #1
 1977              	.LVL225:
1304:../src/FreeRTOS/queue.c ****         }
 1978              		.loc 1 1304 21 view .LVU611
 1979 0120 F9FFFFEA 		b	.L148
 1980              	.LVL226:
 1981              	.L154:
1304:../src/FreeRTOS/queue.c ****         }
 1982              		.loc 1 1304 21 view .LVU612
 1983 0124 0140A0E3 		mov	r4, #1
 1984              	.LVL227:
1304:../src/FreeRTOS/queue.c ****         }
 1985              		.loc 1 1304 21 view .LVU613
 1986 0128 F7FFFFEA 		b	.L148
 1987              	.LBE8:
 1988              	.LBE10:
 1989              		.cfi_endproc
 1990              	.LFE12:
 1992              		.section	.text.xQueueReceive,"ax",%progbits
 1993              		.align	2
 1994              		.global	xQueueReceive
 1995              		.syntax unified
 1996              		.arm
 1997              		.fpu neon
 1999              	xQueueReceive:
 2000              	.LVL228:
 2001              	.LFB13:
1321:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2002              		.loc 1 1321 1 is_stmt 1 view -0
 2003              		.cfi_startproc
 2004              		@ args = 0, pretend = 0, frame = 16
 2005              		@ frame_needed = 0, uses_anonymous_args = 0
1321:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2006              		.loc 1 1321 1 is_stmt 0 view .LVU615
 2007 0000 F0402DE9 		push	{r4, r5, r6, r7, lr}
 2008              		.cfi_def_cfa_offset 20
 2009              		.cfi_offset 4, -20
 2010              		.cfi_offset 5, -16
 2011              		.cfi_offset 6, -12
 2012              		.cfi_offset 7, -8
 2013              		.cfi_offset 14, -4
 2014 0004 14D04DE2 		sub	sp, sp, #20
 2015              		.cfi_def_cfa_offset 40
 2016 0008 0170A0E1 		mov	r7, r1
 2017 000c 04208DE5 		str	r2, [sp, #4]
1322:../src/FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 2018              		.loc 1 1322 5 is_stmt 1 view .LVU616
 2019              	.LVL229:
1323:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2020              		.loc 1 1323 5 view .LVU617
1324:../src/FreeRTOS/queue.c **** 
 2021              		.loc 1 1324 5 view .LVU618
1327:../src/FreeRTOS/queue.c **** 
 2022              		.loc 1 1327 5 view .LVU619
 2023 0010 004050E2 		subs	r4, r0, #0
 2024 0014 0900000A 		beq	.L178
 2025              	.LVL230:
 2026              	.L163:
1327:../src/FreeRTOS/queue.c **** 
 2027              		.loc 1 1327 32 discriminator 3 view .LVU620
1331:../src/FreeRTOS/queue.c **** 
 2028              		.loc 1 1331 5 discriminator 3 view .LVU621
 2029 0018 000057E3 		cmp	r7, #0
 2030 001c 0C00000A 		beq	.L179
 2031              	.L164:
1331:../src/FreeRTOS/queue.c **** 
 2032              		.loc 1 1331 103 discriminator 9 view .LVU622
1336:../src/FreeRTOS/queue.c ****         }
 2033              		.loc 1 1336 13 discriminator 9 view .LVU623
 2034 0020 FEFFFFEB 		bl	xTaskGetSchedulerState
 2035              	.LVL231:
 2036 0024 000050E3 		cmp	r0, #0
 2037 0028 0200001A 		bne	.L165
1336:../src/FreeRTOS/queue.c ****         }
 2038              		.loc 1 1336 13 is_stmt 0 discriminator 2 view .LVU624
 2039 002c 04309DE5 		ldr	r3, [sp, #4]
 2040 0030 000053E3 		cmp	r3, #0
 2041 0034 0E00001A 		bne	.L180
 2042              	.L165:
1321:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2043              		.loc 1 1321 1 discriminator 9 view .LVU625
 2044 0038 0060A0E3 		mov	r6, #0
 2045 003c 3B0000EA 		b	.L166
 2046              	.LVL232:
 2047              	.L178:
1327:../src/FreeRTOS/queue.c **** 
 2048              		.loc 1 1327 5 is_stmt 1 discriminator 1 view .LVU626
 2049 0040 2F1500E3 		movw	r1, #1327
 2050              	.LVL233:
1327:../src/FreeRTOS/queue.c **** 
 2051              		.loc 1 1327 5 is_stmt 0 discriminator 1 view .LVU627
 2052 0044 000000E3 		movw	r0, #:lower16:.LC0
 2053              	.LVL234:
1327:../src/FreeRTOS/queue.c **** 
 2054              		.loc 1 1327 5 discriminator 1 view .LVU628
 2055 0048 000040E3 		movt	r0, #:upper16:.LC0
 2056 004c FEFFFFEB 		bl	R_OS_AssertCalled
 2057              	.LVL235:
1327:../src/FreeRTOS/queue.c **** 
 2058              		.loc 1 1327 5 discriminator 1 view .LVU629
 2059 0050 F0FFFFEA 		b	.L163
 2060              	.L179:
1331:../src/FreeRTOS/queue.c **** 
 2061              		.loc 1 1331 5 discriminator 2 view .LVU630
 2062 0054 403094E5 		ldr	r3, [r4, #64]
 2063 0058 000053E3 		cmp	r3, #0
 2064 005c EFFFFF0A 		beq	.L164
1331:../src/FreeRTOS/queue.c **** 
 2065              		.loc 1 1331 5 is_stmt 1 view .LVU631
 2066 0060 331500E3 		movw	r1, #1331
 2067 0064 000000E3 		movw	r0, #:lower16:.LC0
 2068 0068 000040E3 		movt	r0, #:upper16:.LC0
 2069 006c FEFFFFEB 		bl	R_OS_AssertCalled
 2070              	.LVL236:
 2071 0070 EAFFFFEA 		b	.L164
 2072              	.L180:
1336:../src/FreeRTOS/queue.c ****         }
 2073              		.loc 1 1336 13 view .LVU632
 2074 0074 381500E3 		movw	r1, #1336
 2075 0078 000000E3 		movw	r0, #:lower16:.LC0
 2076 007c 000040E3 		movt	r0, #:upper16:.LC0
 2077 0080 FEFFFFEB 		bl	R_OS_AssertCalled
 2078              	.LVL237:
 2079 0084 EBFFFFEA 		b	.L165
 2080              	.LVL238:
 2081              	.L183:
 2082              	.LBB11:
1354:../src/FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
 2083              		.loc 1 1354 17 view .LVU633
 2084 0088 0710A0E1 		mov	r1, r7
 2085 008c 0400A0E1 		mov	r0, r4
 2086 0090 FEFFFFEB 		bl	prvCopyDataFromQueue
 2087              	.LVL239:
1355:../src/FreeRTOS/queue.c ****                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2088              		.loc 1 1355 46 view .LVU634
1356:../src/FreeRTOS/queue.c **** 
 2089              		.loc 1 1356 17 view .LVU635
1356:../src/FreeRTOS/queue.c **** 
 2090              		.loc 1 1356 64 is_stmt 0 view .LVU636
 2091 0094 015045E2 		sub	r5, r5, #1
 2092              	.LVL240:
1356:../src/FreeRTOS/queue.c **** 
 2093              		.loc 1 1356 44 view .LVU637
 2094 0098 385084E5 		str	r5, [r4, #56]
1361:../src/FreeRTOS/queue.c ****                 {
 2095              		.loc 1 1361 17 is_stmt 1 view .LVU638
1361:../src/FreeRTOS/queue.c ****                 {
 2096              		.loc 1 1361 21 is_stmt 0 view .LVU639
 2097 009c 103094E5 		ldr	r3, [r4, #16]
1361:../src/FreeRTOS/queue.c ****                 {
 2098              		.loc 1 1361 19 view .LVU640
 2099 00a0 000053E3 		cmp	r3, #0
 2100 00a4 0300001A 		bne	.L181
 2101              	.L168:
1374:../src/FreeRTOS/queue.c ****                 }
 2102              		.loc 1 1374 45 is_stmt 1 view .LVU641
1377:../src/FreeRTOS/queue.c ****                 return pdPASS;
 2103              		.loc 1 1377 17 view .LVU642
 2104 00a8 FEFFFFEB 		bl	vPortExitCritical
 2105              	.LVL241:
1377:../src/FreeRTOS/queue.c ****                 return pdPASS;
 2106              		.loc 1 1377 36 view .LVU643
1378:../src/FreeRTOS/queue.c ****             }
 2107              		.loc 1 1378 17 view .LVU644
1378:../src/FreeRTOS/queue.c ****             }
 2108              		.loc 1 1378 24 is_stmt 0 view .LVU645
 2109 00ac 0100A0E3 		mov	r0, #1
 2110              	.LVL242:
 2111              	.L162:
1378:../src/FreeRTOS/queue.c ****             }
 2112              		.loc 1 1378 24 view .LVU646
 2113              	.LBE11:
1458:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2114              		.loc 1 1458 1 view .LVU647
 2115 00b0 14D08DE2 		add	sp, sp, #20
 2116              		.cfi_remember_state
 2117              		.cfi_def_cfa_offset 20
 2118              		@ sp needed
 2119 00b4 F080BDE8 		pop	{r4, r5, r6, r7, pc}
 2120              	.LVL243:
 2121              	.L181:
 2122              		.cfi_restore_state
 2123              	.LBB12:
1363:../src/FreeRTOS/queue.c ****                     {
 2124              		.loc 1 1363 21 is_stmt 1 view .LVU648
1363:../src/FreeRTOS/queue.c ****                     {
 2125              		.loc 1 1363 25 is_stmt 0 view .LVU649
 2126 00b8 100084E2 		add	r0, r4, #16
 2127 00bc FEFFFFEB 		bl	xTaskRemoveFromEventList
 2128              	.LVL244:
1363:../src/FreeRTOS/queue.c ****                     {
 2129              		.loc 1 1363 23 view .LVU650
 2130 00c0 000050E3 		cmp	r0, #0
 2131 00c4 F7FFFF0A 		beq	.L168
1365:../src/FreeRTOS/queue.c ****                     }
 2132              		.loc 1 1365 25 is_stmt 1 view .LVU651
 2133              		.syntax divided
 2134              	@ 1365 "../src/FreeRTOS/queue.c" 1
 2135 00c8 000000EF 		SWI 0
 2136              	@ 0 "" 2
1365:../src/FreeRTOS/queue.c ****                     }
 2137              		.loc 1 1365 57 view .LVU652
 2138              		.arm
 2139              		.syntax unified
 2140 00cc F5FFFFEA 		b	.L168
 2141              	.LVL245:
 2142              	.L184:
1386:../src/FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
 2143              		.loc 1 1386 21 view .LVU653
 2144 00d0 FEFFFFEB 		bl	vPortExitCritical
 2145              	.LVL246:
1386:../src/FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
 2146              		.loc 1 1386 40 view .LVU654
1387:../src/FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
 2147              		.loc 1 1387 57 view .LVU655
1388:../src/FreeRTOS/queue.c ****                 }
 2148              		.loc 1 1388 21 view .LVU656
1388:../src/FreeRTOS/queue.c ****                 }
 2149              		.loc 1 1388 28 is_stmt 0 view .LVU657
 2150 00d4 0000A0E3 		mov	r0, #0
 2151 00d8 F4FFFFEA 		b	.L162
 2152              	.L185:
1394:../src/FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 2153              		.loc 1 1394 21 is_stmt 1 view .LVU658
 2154 00dc 08008DE2 		add	r0, sp, #8
 2155 00e0 FEFFFFEB 		bl	vTaskInternalSetTimeOutState
 2156              	.LVL247:
1395:../src/FreeRTOS/queue.c ****                 }
 2157              		.loc 1 1395 21 view .LVU659
1395:../src/FreeRTOS/queue.c ****                 }
 2158              		.loc 1 1395 35 is_stmt 0 view .LVU660
 2159 00e4 0160A0E3 		mov	r6, #1
 2160 00e8 190000EA 		b	.L171
 2161              	.LVL248:
 2162              	.L186:
1395:../src/FreeRTOS/queue.c ****                 }
 2163              		.loc 1 1395 35 view .LVU661
 2164              	.LBE12:
1410:../src/FreeRTOS/queue.c **** 
 2165              		.loc 1 1410 9 is_stmt 1 discriminator 1 view .LVU662
 2166 00ec 0030A0E3 		mov	r3, #0
 2167 00f0 4430C4E5 		strb	r3, [r4, #68]
 2168 00f4 1D0000EA 		b	.L172
 2169              	.L187:
1410:../src/FreeRTOS/queue.c **** 
 2170              		.loc 1 1410 9 discriminator 4 view .LVU663
 2171 00f8 0030A0E3 		mov	r3, #0
 2172 00fc 4530C4E5 		strb	r3, [r4, #69]
 2173 0100 1E0000EA 		b	.L173
 2174              	.L175:
1436:../src/FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
 2175              		.loc 1 1436 17 view .LVU664
 2176 0104 0400A0E1 		mov	r0, r4
 2177 0108 FEFFFFEB 		bl	prvUnlockQueue
 2178              	.LVL249:
1437:../src/FreeRTOS/queue.c ****             }
 2179              		.loc 1 1437 17 view .LVU665
1437:../src/FreeRTOS/queue.c ****             }
 2180              		.loc 1 1437 26 is_stmt 0 view .LVU666
 2181 010c FEFFFFEB 		bl	xTaskResumeAll
 2182              	.LVL250:
 2183 0110 060000EA 		b	.L166
 2184              	.L174:
1444:../src/FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
 2185              		.loc 1 1444 13 is_stmt 1 view .LVU667
 2186 0114 0400A0E1 		mov	r0, r4
 2187 0118 FEFFFFEB 		bl	prvUnlockQueue
 2188              	.LVL251:
1445:../src/FreeRTOS/queue.c **** 
 2189              		.loc 1 1445 13 view .LVU668
1445:../src/FreeRTOS/queue.c **** 
 2190              		.loc 1 1445 22 is_stmt 0 view .LVU669
 2191 011c FEFFFFEB 		bl	xTaskResumeAll
 2192              	.LVL252:
1447:../src/FreeRTOS/queue.c ****             {
 2193              		.loc 1 1447 13 is_stmt 1 view .LVU670
1447:../src/FreeRTOS/queue.c ****             {
 2194              		.loc 1 1447 17 is_stmt 0 view .LVU671
 2195 0120 0400A0E1 		mov	r0, r4
 2196 0124 FEFFFFEB 		bl	prvIsQueueEmpty
 2197              	.LVL253:
1447:../src/FreeRTOS/queue.c ****             {
 2198              		.loc 1 1447 15 view .LVU672
 2199 0128 000050E3 		cmp	r0, #0
 2200 012c 2700001A 		bne	.L182
 2201              	.LVL254:
 2202              	.L166:
1336:../src/FreeRTOS/queue.c ****         }
 2203              		.loc 1 1336 114 is_stmt 1 discriminator 9 view .LVU673
1343:../src/FreeRTOS/queue.c ****     {
 2204              		.loc 1 1343 5 discriminator 9 view .LVU674
1345:../src/FreeRTOS/queue.c ****         {
 2205              		.loc 1 1345 9 discriminator 9 view .LVU675
 2206 0130 FEFFFFEB 		bl	vPortEnterCritical
 2207              	.LVL255:
1345:../src/FreeRTOS/queue.c ****         {
 2208              		.loc 1 1345 29 discriminator 9 view .LVU676
 2209              	.LBB13:
1347:../src/FreeRTOS/queue.c **** 
 2210              		.loc 1 1347 13 discriminator 9 view .LVU677
1347:../src/FreeRTOS/queue.c **** 
 2211              		.loc 1 1347 31 is_stmt 0 discriminator 9 view .LVU678
 2212 0134 385094E5 		ldr	r5, [r4, #56]
 2213              	.LVL256:
1351:../src/FreeRTOS/queue.c ****             {
 2214              		.loc 1 1351 13 is_stmt 1 discriminator 9 view .LVU679
1351:../src/FreeRTOS/queue.c ****             {
 2215              		.loc 1 1351 15 is_stmt 0 discriminator 9 view .LVU680
 2216 0138 000055E3 		cmp	r5, #0
 2217 013c D1FFFF1A 		bne	.L183
1382:../src/FreeRTOS/queue.c ****                 {
 2218              		.loc 1 1382 17 is_stmt 1 view .LVU681
1382:../src/FreeRTOS/queue.c ****                 {
 2219              		.loc 1 1382 34 is_stmt 0 view .LVU682
 2220 0140 04309DE5 		ldr	r3, [sp, #4]
1382:../src/FreeRTOS/queue.c ****                 {
 2221              		.loc 1 1382 19 view .LVU683
 2222 0144 000053E3 		cmp	r3, #0
 2223 0148 E0FFFF0A 		beq	.L184
1390:../src/FreeRTOS/queue.c ****                 {
 2224              		.loc 1 1390 22 is_stmt 1 view .LVU684
1390:../src/FreeRTOS/queue.c ****                 {
 2225              		.loc 1 1390 24 is_stmt 0 view .LVU685
 2226 014c 000056E3 		cmp	r6, #0
 2227 0150 E1FFFF0A 		beq	.L185
 2228              	.LVL257:
 2229              	.L171:
1400:../src/FreeRTOS/queue.c ****                 }
 2230              		.loc 1 1400 45 is_stmt 1 view .LVU686
 2231              	.LBE13:
1404:../src/FreeRTOS/queue.c **** 
 2232              		.loc 1 1404 9 view .LVU687
 2233 0154 FEFFFFEB 		bl	vPortExitCritical
 2234              	.LVL258:
1404:../src/FreeRTOS/queue.c **** 
 2235              		.loc 1 1404 28 view .LVU688
1409:../src/FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 2236              		.loc 1 1409 9 view .LVU689
 2237 0158 FEFFFFEB 		bl	vTaskSuspendAll
 2238              	.LVL259:
1410:../src/FreeRTOS/queue.c **** 
 2239              		.loc 1 1410 9 view .LVU690
 2240 015c FEFFFFEB 		bl	vPortEnterCritical
 2241              	.LVL260:
1410:../src/FreeRTOS/queue.c **** 
 2242              		.loc 1 1410 9 view .LVU691
1410:../src/FreeRTOS/queue.c **** 
 2243              		.loc 1 1410 9 view .LVU692
 2244 0160 4430D4E5 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 2245 0164 7330AFE6 		sxtb	r3, r3
 2246 0168 010073E3 		cmn	r3, #1
 2247 016c DEFFFF0A 		beq	.L186
 2248              	.L172:
1410:../src/FreeRTOS/queue.c **** 
 2249              		.loc 1 1410 9 discriminator 3 view .LVU693
 2250 0170 4530D4E5 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 2251 0174 7330AFE6 		sxtb	r3, r3
 2252 0178 010073E3 		cmn	r3, #1
 2253 017c DDFFFF0A 		beq	.L187
 2254              	.L173:
1410:../src/FreeRTOS/queue.c **** 
 2255              		.loc 1 1410 9 discriminator 6 view .LVU694
 2256 0180 FEFFFFEB 		bl	vPortExitCritical
 2257              	.LVL261:
1410:../src/FreeRTOS/queue.c **** 
 2258              		.loc 1 1410 32 discriminator 6 view .LVU695
1413:../src/FreeRTOS/queue.c ****         {
 2259              		.loc 1 1413 9 discriminator 6 view .LVU696
1413:../src/FreeRTOS/queue.c ****         {
 2260              		.loc 1 1413 13 is_stmt 0 discriminator 6 view .LVU697
 2261 0184 04108DE2 		add	r1, sp, #4
 2262 0188 08008DE2 		add	r0, sp, #8
 2263 018c FEFFFFEB 		bl	xTaskCheckForTimeOut
 2264              	.LVL262:
1413:../src/FreeRTOS/queue.c ****         {
 2265              		.loc 1 1413 11 discriminator 6 view .LVU698
 2266 0190 000050E3 		cmp	r0, #0
 2267 0194 DEFFFF1A 		bne	.L174
1417:../src/FreeRTOS/queue.c ****             {
 2268              		.loc 1 1417 13 is_stmt 1 view .LVU699
1417:../src/FreeRTOS/queue.c ****             {
 2269              		.loc 1 1417 17 is_stmt 0 view .LVU700
 2270 0198 0400A0E1 		mov	r0, r4
 2271 019c FEFFFFEB 		bl	prvIsQueueEmpty
 2272              	.LVL263:
1417:../src/FreeRTOS/queue.c ****             {
 2273              		.loc 1 1417 15 view .LVU701
 2274 01a0 000050E3 		cmp	r0, #0
 2275 01a4 D6FFFF0A 		beq	.L175
1419:../src/FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2276              		.loc 1 1419 58 is_stmt 1 view .LVU702
1420:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
 2277              		.loc 1 1420 17 view .LVU703
 2278 01a8 04109DE5 		ldr	r1, [sp, #4]
 2279 01ac 240084E2 		add	r0, r4, #36
 2280 01b0 FEFFFFEB 		bl	vTaskPlaceOnEventList
 2281              	.LVL264:
1421:../src/FreeRTOS/queue.c **** 
 2282              		.loc 1 1421 17 view .LVU704
 2283 01b4 0400A0E1 		mov	r0, r4
 2284 01b8 FEFFFFEB 		bl	prvUnlockQueue
 2285              	.LVL265:
1423:../src/FreeRTOS/queue.c ****                 {
 2286              		.loc 1 1423 17 view .LVU705
1423:../src/FreeRTOS/queue.c ****                 {
 2287              		.loc 1 1423 21 is_stmt 0 view .LVU706
 2288 01bc FEFFFFEB 		bl	xTaskResumeAll
 2289              	.LVL266:
1423:../src/FreeRTOS/queue.c ****                 {
 2290              		.loc 1 1423 19 view .LVU707
 2291 01c0 000050E3 		cmp	r0, #0
 2292 01c4 D9FFFF1A 		bne	.L166
1425:../src/FreeRTOS/queue.c ****                 }
 2293              		.loc 1 1425 21 is_stmt 1 view .LVU708
 2294              		.syntax divided
 2295              	@ 1425 "../src/FreeRTOS/queue.c" 1
 2296 01c8 000000EF 		SWI 0
 2297              	@ 0 "" 2
1425:../src/FreeRTOS/queue.c ****                 }
 2298              		.loc 1 1425 43 view .LVU709
 2299              		.arm
 2300              		.syntax unified
 2301 01cc D7FFFFEA 		b	.L166
 2302              	.L182:
1450:../src/FreeRTOS/queue.c ****             }
 2303              		.loc 1 1450 24 is_stmt 0 view .LVU710
 2304 01d0 0000A0E3 		mov	r0, #0
 2305 01d4 B5FFFFEA 		b	.L162
 2306              		.cfi_endproc
 2307              	.LFE13:
 2309              		.section	.text.xQueueSemaphoreTake,"ax",%progbits
 2310              		.align	2
 2311              		.global	xQueueSemaphoreTake
 2312              		.syntax unified
 2313              		.arm
 2314              		.fpu neon
 2316              	xQueueSemaphoreTake:
 2317              	.LVL267:
 2318              	.LFB14:
1463:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2319              		.loc 1 1463 1 is_stmt 1 view -0
 2320              		.cfi_startproc
 2321              		@ args = 0, pretend = 0, frame = 16
 2322              		@ frame_needed = 0, uses_anonymous_args = 0
1463:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2323              		.loc 1 1463 1 is_stmt 0 view .LVU712
 2324 0000 70402DE9 		push	{r4, r5, r6, lr}
 2325              		.cfi_def_cfa_offset 16
 2326              		.cfi_offset 4, -16
 2327              		.cfi_offset 5, -12
 2328              		.cfi_offset 6, -8
 2329              		.cfi_offset 14, -4
 2330 0004 10D04DE2 		sub	sp, sp, #16
 2331              		.cfi_def_cfa_offset 32
 2332 0008 04108DE5 		str	r1, [sp, #4]
1464:../src/FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 2333              		.loc 1 1464 5 is_stmt 1 view .LVU713
 2334              	.LVL268:
1465:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2335              		.loc 1 1465 5 view .LVU714
1466:../src/FreeRTOS/queue.c **** 
 2336              		.loc 1 1466 5 view .LVU715
1469:../src/FreeRTOS/queue.c ****     #endif
 2337              		.loc 1 1469 9 view .LVU716
1473:../src/FreeRTOS/queue.c **** 
 2338              		.loc 1 1473 5 view .LVU717
 2339 000c 004050E2 		subs	r4, r0, #0
 2340 0010 0B00000A 		beq	.L208
 2341              	.LVL269:
 2342              	.L189:
1473:../src/FreeRTOS/queue.c **** 
 2343              		.loc 1 1473 32 discriminator 3 view .LVU718
1477:../src/FreeRTOS/queue.c **** 
 2344              		.loc 1 1477 5 discriminator 3 view .LVU719
 2345 0014 403094E5 		ldr	r3, [r4, #64]
 2346 0018 000053E3 		cmp	r3, #0
 2347 001c 0D00001A 		bne	.L209
 2348              	.L190:
1477:../src/FreeRTOS/queue.c **** 
 2349              		.loc 1 1477 45 discriminator 3 view .LVU720
1482:../src/FreeRTOS/queue.c ****         }
 2350              		.loc 1 1482 13 discriminator 3 view .LVU721
 2351 0020 FEFFFFEB 		bl	xTaskGetSchedulerState
 2352              	.LVL270:
 2353 0024 000050E3 		cmp	r0, #0
 2354 0028 0200001A 		bne	.L191
1482:../src/FreeRTOS/queue.c ****         }
 2355              		.loc 1 1482 13 is_stmt 0 discriminator 2 view .LVU722
 2356 002c 04309DE5 		ldr	r3, [sp, #4]
 2357 0030 000053E3 		cmp	r3, #0
 2358 0034 0C00001A 		bne	.L210
 2359              	.L191:
1463:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2360              		.loc 1 1463 1 discriminator 9 view .LVU723
 2361 0038 0060A0E3 		mov	r6, #0
 2362 003c 0650A0E1 		mov	r5, r6
 2363 0040 480000EA 		b	.L192
 2364              	.LVL271:
 2365              	.L208:
1473:../src/FreeRTOS/queue.c **** 
 2366              		.loc 1 1473 5 is_stmt 1 discriminator 1 view .LVU724
 2367 0044 C11500E3 		movw	r1, #1473
 2368              	.LVL272:
1473:../src/FreeRTOS/queue.c **** 
 2369              		.loc 1 1473 5 is_stmt 0 discriminator 1 view .LVU725
 2370 0048 000000E3 		movw	r0, #:lower16:.LC0
 2371              	.LVL273:
1473:../src/FreeRTOS/queue.c **** 
 2372              		.loc 1 1473 5 discriminator 1 view .LVU726
 2373 004c 000040E3 		movt	r0, #:upper16:.LC0
 2374 0050 FEFFFFEB 		bl	R_OS_AssertCalled
 2375              	.LVL274:
1473:../src/FreeRTOS/queue.c **** 
 2376              		.loc 1 1473 5 discriminator 1 view .LVU727
 2377 0054 EEFFFFEA 		b	.L189
 2378              	.L209:
1477:../src/FreeRTOS/queue.c **** 
 2379              		.loc 1 1477 5 is_stmt 1 discriminator 1 view .LVU728
 2380 0058 C51500E3 		movw	r1, #1477
 2381 005c 000000E3 		movw	r0, #:lower16:.LC0
 2382 0060 000040E3 		movt	r0, #:upper16:.LC0
 2383 0064 FEFFFFEB 		bl	R_OS_AssertCalled
 2384              	.LVL275:
 2385 0068 ECFFFFEA 		b	.L190
 2386              	.L210:
1482:../src/FreeRTOS/queue.c ****         }
 2387              		.loc 1 1482 13 view .LVU729
 2388 006c CA1500E3 		movw	r1, #1482
 2389 0070 000000E3 		movw	r0, #:lower16:.LC0
 2390 0074 000040E3 		movt	r0, #:upper16:.LC0
 2391 0078 FEFFFFEB 		bl	R_OS_AssertCalled
 2392              	.LVL276:
 2393 007c EDFFFFEA 		b	.L191
 2394              	.LVL277:
 2395              	.L215:
 2396              	.LBB14:
1501:../src/FreeRTOS/queue.c **** 
 2397              		.loc 1 1501 46 view .LVU730
1505:../src/FreeRTOS/queue.c **** 
 2398              		.loc 1 1505 17 view .LVU731
1505:../src/FreeRTOS/queue.c **** 
 2399              		.loc 1 1505 63 is_stmt 0 view .LVU732
 2400 0080 013043E2 		sub	r3, r3, #1
 2401              	.LVL278:
1505:../src/FreeRTOS/queue.c **** 
 2402              		.loc 1 1505 44 view .LVU733
 2403 0084 383084E5 		str	r3, [r4, #56]
1509:../src/FreeRTOS/queue.c ****                         {
 2404              		.loc 1 1509 25 is_stmt 1 view .LVU734
1509:../src/FreeRTOS/queue.c ****                         {
 2405              		.loc 1 1509 36 is_stmt 0 view .LVU735
 2406 0088 003094E5 		ldr	r3, [r4]
 2407              	.LVL279:
1509:../src/FreeRTOS/queue.c ****                         {
 2408              		.loc 1 1509 27 view .LVU736
 2409 008c 000053E3 		cmp	r3, #0
 2410 0090 0600000A 		beq	.L211
 2411              	.LVL280:
 2412              	.L194:
1517:../src/FreeRTOS/queue.c ****                         }
 2413              		.loc 1 1517 53 is_stmt 1 view .LVU737
1524:../src/FreeRTOS/queue.c ****                 {
 2414              		.loc 1 1524 17 view .LVU738
1524:../src/FreeRTOS/queue.c ****                 {
 2415              		.loc 1 1524 21 is_stmt 0 view .LVU739
 2416 0094 103094E5 		ldr	r3, [r4, #16]
1524:../src/FreeRTOS/queue.c ****                 {
 2417              		.loc 1 1524 19 view .LVU740
 2418 0098 000053E3 		cmp	r3, #0
 2419 009c 0600001A 		bne	.L212
 2420              	.L195:
1537:../src/FreeRTOS/queue.c ****                 }
 2421              		.loc 1 1537 45 is_stmt 1 view .LVU741
1540:../src/FreeRTOS/queue.c ****                 return pdPASS;
 2422              		.loc 1 1540 17 view .LVU742
 2423 00a0 FEFFFFEB 		bl	vPortExitCritical
 2424              	.LVL281:
1540:../src/FreeRTOS/queue.c ****                 return pdPASS;
 2425              		.loc 1 1540 36 view .LVU743
1541:../src/FreeRTOS/queue.c ****             }
 2426              		.loc 1 1541 17 view .LVU744
1541:../src/FreeRTOS/queue.c ****             }
 2427              		.loc 1 1541 24 is_stmt 0 view .LVU745
 2428 00a4 0100A0E3 		mov	r0, #1
 2429              	.L188:
1541:../src/FreeRTOS/queue.c ****             }
 2430              		.loc 1 1541 24 view .LVU746
 2431              	.LBE14:
1677:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2432              		.loc 1 1677 1 view .LVU747
 2433 00a8 10D08DE2 		add	sp, sp, #16
 2434              		.cfi_remember_state
 2435              		.cfi_def_cfa_offset 16
 2436              		@ sp needed
 2437 00ac 7080BDE8 		pop	{r4, r5, r6, pc}
 2438              	.LVL282:
 2439              	.L211:
 2440              		.cfi_restore_state
 2441              	.LBB15:
1513:../src/FreeRTOS/queue.c ****                         }
 2442              		.loc 1 1513 29 is_stmt 1 view .LVU748
1513:../src/FreeRTOS/queue.c ****                         }
 2443              		.loc 1 1513 66 is_stmt 0 view .LVU749
 2444 00b0 FEFFFFEB 		bl	pvTaskIncrementMutexHeldCount
 2445              	.LVL283:
1513:../src/FreeRTOS/queue.c ****                         }
 2446              		.loc 1 1513 64 view .LVU750
 2447 00b4 080084E5 		str	r0, [r4, #8]
 2448 00b8 F5FFFFEA 		b	.L194
 2449              	.L212:
1526:../src/FreeRTOS/queue.c ****                     {
 2450              		.loc 1 1526 21 is_stmt 1 view .LVU751
1526:../src/FreeRTOS/queue.c ****                     {
 2451              		.loc 1 1526 25 is_stmt 0 view .LVU752
 2452 00bc 100084E2 		add	r0, r4, #16
 2453 00c0 FEFFFFEB 		bl	xTaskRemoveFromEventList
 2454              	.LVL284:
1526:../src/FreeRTOS/queue.c ****                     {
 2455              		.loc 1 1526 23 view .LVU753
 2456 00c4 000050E3 		cmp	r0, #0
 2457 00c8 F4FFFF0A 		beq	.L195
1528:../src/FreeRTOS/queue.c ****                     }
 2458              		.loc 1 1528 25 is_stmt 1 view .LVU754
 2459              		.syntax divided
 2460              	@ 1528 "../src/FreeRTOS/queue.c" 1
 2461 00cc 000000EF 		SWI 0
 2462              	@ 0 "" 2
1528:../src/FreeRTOS/queue.c ****                     }
 2463              		.loc 1 1528 57 view .LVU755
 2464              		.arm
 2465              		.syntax unified
 2466 00d0 F2FFFFEA 		b	.L195
 2467              	.L216:
1552:../src/FreeRTOS/queue.c ****                         }
 2468              		.loc 1 1552 29 view .LVU756
 2469 00d4 000056E3 		cmp	r6, #0
 2470 00d8 0200001A 		bne	.L213
 2471              	.L198:
1552:../src/FreeRTOS/queue.c ****                         }
 2472              		.loc 1 1552 76 discriminator 3 view .LVU757
1558:../src/FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
 2473              		.loc 1 1558 21 discriminator 3 view .LVU758
 2474 00dc FEFFFFEB 		bl	vPortExitCritical
 2475              	.LVL285:
1558:../src/FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
 2476              		.loc 1 1558 40 discriminator 3 view .LVU759
1559:../src/FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
 2477              		.loc 1 1559 57 discriminator 3 view .LVU760
1560:../src/FreeRTOS/queue.c ****                 }
 2478              		.loc 1 1560 21 discriminator 3 view .LVU761
1560:../src/FreeRTOS/queue.c ****                 }
 2479              		.loc 1 1560 28 is_stmt 0 discriminator 3 view .LVU762
 2480 00e0 0000A0E3 		mov	r0, #0
 2481 00e4 EFFFFFEA 		b	.L188
 2482              	.L213:
1552:../src/FreeRTOS/queue.c ****                         }
 2483              		.loc 1 1552 29 is_stmt 1 discriminator 1 view .LVU763
 2484 00e8 611EA0E3 		mov	r1, #1552
 2485 00ec 000000E3 		movw	r0, #:lower16:.LC0
 2486 00f0 000040E3 		movt	r0, #:upper16:.LC0
 2487 00f4 FEFFFFEB 		bl	R_OS_AssertCalled
 2488              	.LVL286:
 2489 00f8 F7FFFFEA 		b	.L198
 2490              	.L217:
1566:../src/FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 2491              		.loc 1 1566 21 view .LVU764
 2492 00fc 08008DE2 		add	r0, sp, #8
 2493 0100 FEFFFFEB 		bl	vTaskInternalSetTimeOutState
 2494              	.LVL287:
1567:../src/FreeRTOS/queue.c ****                 }
 2495              		.loc 1 1567 21 view .LVU765
1567:../src/FreeRTOS/queue.c ****                 }
 2496              		.loc 1 1567 35 is_stmt 0 view .LVU766
 2497 0104 0150A0E3 		mov	r5, #1
 2498 0108 1F0000EA 		b	.L199
 2499              	.LVL288:
 2500              	.L218:
1567:../src/FreeRTOS/queue.c ****                 }
 2501              		.loc 1 1567 35 view .LVU767
 2502              	.LBE15:
1582:../src/FreeRTOS/queue.c **** 
 2503              		.loc 1 1582 9 is_stmt 1 discriminator 1 view .LVU768
 2504 010c 0030A0E3 		mov	r3, #0
 2505 0110 4430C4E5 		strb	r3, [r4, #68]
 2506 0114 230000EA 		b	.L200
 2507              	.L219:
1582:../src/FreeRTOS/queue.c **** 
 2508              		.loc 1 1582 9 discriminator 4 view .LVU769
 2509 0118 0030A0E3 		mov	r3, #0
 2510 011c 4530C4E5 		strb	r3, [r4, #69]
 2511 0120 240000EA 		b	.L201
 2512              	.L220:
1599:../src/FreeRTOS/queue.c ****                             {
 2513              		.loc 1 1599 29 view .LVU770
 2514 0124 FEFFFFEB 		bl	vPortEnterCritical
 2515              	.LVL289:
1599:../src/FreeRTOS/queue.c ****                             {
 2516              		.loc 1 1599 49 view .LVU771
1601:../src/FreeRTOS/queue.c ****                             }
 2517              		.loc 1 1601 33 view .LVU772
1601:../src/FreeRTOS/queue.c ****                             }
 2518              		.loc 1 1601 56 is_stmt 0 view .LVU773
 2519 0128 080094E5 		ldr	r0, [r4, #8]
 2520 012c FEFFFFEB 		bl	xTaskPriorityInherit
 2521              	.LVL290:
 2522 0130 0060A0E1 		mov	r6, r0
 2523              	.LVL291:
1603:../src/FreeRTOS/queue.c ****                         }
 2524              		.loc 1 1603 29 is_stmt 1 view .LVU774
 2525 0134 FEFFFFEB 		bl	vPortExitCritical
 2526              	.LVL292:
1603:../src/FreeRTOS/queue.c ****                         }
 2527              		.loc 1 1603 48 view .LVU775
 2528 0138 2B0000EA 		b	.L204
 2529              	.L203:
1628:../src/FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
 2530              		.loc 1 1628 17 view .LVU776
 2531 013c 0400A0E1 		mov	r0, r4
 2532 0140 FEFFFFEB 		bl	prvUnlockQueue
 2533              	.LVL293:
1629:../src/FreeRTOS/queue.c ****             }
 2534              		.loc 1 1629 17 view .LVU777
1629:../src/FreeRTOS/queue.c ****             }
 2535              		.loc 1 1629 26 is_stmt 0 view .LVU778
 2536 0144 FEFFFFEB 		bl	xTaskResumeAll
 2537              	.LVL294:
 2538 0148 060000EA 		b	.L192
 2539              	.L202:
1635:../src/FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
 2540              		.loc 1 1635 13 is_stmt 1 view .LVU779
 2541 014c 0400A0E1 		mov	r0, r4
 2542 0150 FEFFFFEB 		bl	prvUnlockQueue
 2543              	.LVL295:
1636:../src/FreeRTOS/queue.c **** 
 2544              		.loc 1 1636 13 view .LVU780
1636:../src/FreeRTOS/queue.c **** 
 2545              		.loc 1 1636 22 is_stmt 0 view .LVU781
 2546 0154 FEFFFFEB 		bl	xTaskResumeAll
 2547              	.LVL296:
1642:../src/FreeRTOS/queue.c ****             {
 2548              		.loc 1 1642 13 is_stmt 1 view .LVU782
1642:../src/FreeRTOS/queue.c ****             {
 2549              		.loc 1 1642 17 is_stmt 0 view .LVU783
 2550 0158 0400A0E1 		mov	r0, r4
 2551 015c FEFFFFEB 		bl	prvIsQueueEmpty
 2552              	.LVL297:
1642:../src/FreeRTOS/queue.c ****             {
 2553              		.loc 1 1642 15 view .LVU784
 2554 0160 000050E3 		cmp	r0, #0
 2555 0164 2A00001A 		bne	.L214
 2556              	.LVL298:
 2557              	.L192:
1482:../src/FreeRTOS/queue.c ****         }
 2558              		.loc 1 1482 114 is_stmt 1 discriminator 9 view .LVU785
1489:../src/FreeRTOS/queue.c ****     {
 2559              		.loc 1 1489 5 discriminator 9 view .LVU786
1491:../src/FreeRTOS/queue.c ****         {
 2560              		.loc 1 1491 9 discriminator 9 view .LVU787
 2561 0168 FEFFFFEB 		bl	vPortEnterCritical
 2562              	.LVL299:
1491:../src/FreeRTOS/queue.c ****         {
 2563              		.loc 1 1491 29 discriminator 9 view .LVU788
 2564              	.LBB16:
1495:../src/FreeRTOS/queue.c **** 
 2565              		.loc 1 1495 13 discriminator 9 view .LVU789
1495:../src/FreeRTOS/queue.c **** 
 2566              		.loc 1 1495 31 is_stmt 0 discriminator 9 view .LVU790
 2567 016c 383094E5 		ldr	r3, [r4, #56]
 2568              	.LVL300:
1499:../src/FreeRTOS/queue.c ****             {
 2569              		.loc 1 1499 13 is_stmt 1 discriminator 9 view .LVU791
1499:../src/FreeRTOS/queue.c ****             {
 2570              		.loc 1 1499 15 is_stmt 0 discriminator 9 view .LVU792
 2571 0170 000053E3 		cmp	r3, #0
 2572 0174 C1FFFF1A 		bne	.L215
1545:../src/FreeRTOS/queue.c ****                 {
 2573              		.loc 1 1545 17 is_stmt 1 view .LVU793
1545:../src/FreeRTOS/queue.c ****                 {
 2574              		.loc 1 1545 34 is_stmt 0 view .LVU794
 2575 0178 04309DE5 		ldr	r3, [sp, #4]
 2576              	.LVL301:
1545:../src/FreeRTOS/queue.c ****                 {
 2577              		.loc 1 1545 19 view .LVU795
 2578 017c 000053E3 		cmp	r3, #0
 2579 0180 D3FFFF0A 		beq	.L216
1562:../src/FreeRTOS/queue.c ****                 {
 2580              		.loc 1 1562 22 is_stmt 1 view .LVU796
1562:../src/FreeRTOS/queue.c ****                 {
 2581              		.loc 1 1562 24 is_stmt 0 view .LVU797
 2582 0184 000055E3 		cmp	r5, #0
 2583 0188 DBFFFF0A 		beq	.L217
 2584              	.LVL302:
 2585              	.L199:
1572:../src/FreeRTOS/queue.c ****                 }
 2586              		.loc 1 1572 45 is_stmt 1 view .LVU798
 2587              	.LBE16:
1576:../src/FreeRTOS/queue.c **** 
 2588              		.loc 1 1576 9 view .LVU799
 2589 018c FEFFFFEB 		bl	vPortExitCritical
 2590              	.LVL303:
1576:../src/FreeRTOS/queue.c **** 
 2591              		.loc 1 1576 28 view .LVU800
1581:../src/FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 2592              		.loc 1 1581 9 view .LVU801
 2593 0190 FEFFFFEB 		bl	vTaskSuspendAll
 2594              	.LVL304:
1582:../src/FreeRTOS/queue.c **** 
 2595              		.loc 1 1582 9 view .LVU802
 2596 0194 FEFFFFEB 		bl	vPortEnterCritical
 2597              	.LVL305:
1582:../src/FreeRTOS/queue.c **** 
 2598              		.loc 1 1582 9 view .LVU803
1582:../src/FreeRTOS/queue.c **** 
 2599              		.loc 1 1582 9 view .LVU804
 2600 0198 4430D4E5 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 2601 019c 7330AFE6 		sxtb	r3, r3
 2602 01a0 010073E3 		cmn	r3, #1
 2603 01a4 D8FFFF0A 		beq	.L218
 2604              	.L200:
1582:../src/FreeRTOS/queue.c **** 
 2605              		.loc 1 1582 9 discriminator 3 view .LVU805
 2606 01a8 4530D4E5 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 2607 01ac 7330AFE6 		sxtb	r3, r3
 2608 01b0 010073E3 		cmn	r3, #1
 2609 01b4 D7FFFF0A 		beq	.L219
 2610              	.L201:
1582:../src/FreeRTOS/queue.c **** 
 2611              		.loc 1 1582 9 discriminator 6 view .LVU806
 2612 01b8 FEFFFFEB 		bl	vPortExitCritical
 2613              	.LVL306:
1582:../src/FreeRTOS/queue.c **** 
 2614              		.loc 1 1582 32 discriminator 6 view .LVU807
1585:../src/FreeRTOS/queue.c ****         {
 2615              		.loc 1 1585 9 discriminator 6 view .LVU808
1585:../src/FreeRTOS/queue.c ****         {
 2616              		.loc 1 1585 13 is_stmt 0 discriminator 6 view .LVU809
 2617 01bc 04108DE2 		add	r1, sp, #4
 2618 01c0 08008DE2 		add	r0, sp, #8
 2619 01c4 FEFFFFEB 		bl	xTaskCheckForTimeOut
 2620              	.LVL307:
1585:../src/FreeRTOS/queue.c ****         {
 2621              		.loc 1 1585 11 discriminator 6 view .LVU810
 2622 01c8 000050E3 		cmp	r0, #0
 2623 01cc DEFFFF1A 		bne	.L202
1591:../src/FreeRTOS/queue.c ****             {
 2624              		.loc 1 1591 13 is_stmt 1 view .LVU811
1591:../src/FreeRTOS/queue.c ****             {
 2625              		.loc 1 1591 17 is_stmt 0 view .LVU812
 2626 01d0 0400A0E1 		mov	r0, r4
 2627 01d4 FEFFFFEB 		bl	prvIsQueueEmpty
 2628              	.LVL308:
1591:../src/FreeRTOS/queue.c ****             {
 2629              		.loc 1 1591 15 view .LVU813
 2630 01d8 000050E3 		cmp	r0, #0
 2631 01dc D6FFFF0A 		beq	.L203
1593:../src/FreeRTOS/queue.c **** 
 2632              		.loc 1 1593 58 is_stmt 1 view .LVU814
1597:../src/FreeRTOS/queue.c ****                         {
 2633              		.loc 1 1597 25 view .LVU815
1597:../src/FreeRTOS/queue.c ****                         {
 2634              		.loc 1 1597 36 is_stmt 0 view .LVU816
 2635 01e0 003094E5 		ldr	r3, [r4]
1597:../src/FreeRTOS/queue.c ****                         {
 2636              		.loc 1 1597 27 view .LVU817
 2637 01e4 000053E3 		cmp	r3, #0
 2638 01e8 CDFFFF0A 		beq	.L220
 2639              	.L204:
1607:../src/FreeRTOS/queue.c ****                         }
 2640              		.loc 1 1607 53 is_stmt 1 view .LVU818
1612:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
 2641              		.loc 1 1612 17 view .LVU819
 2642 01ec 04109DE5 		ldr	r1, [sp, #4]
 2643 01f0 240084E2 		add	r0, r4, #36
 2644 01f4 FEFFFFEB 		bl	vTaskPlaceOnEventList
 2645              	.LVL309:
1613:../src/FreeRTOS/queue.c **** 
 2646              		.loc 1 1613 17 view .LVU820
 2647 01f8 0400A0E1 		mov	r0, r4
 2648 01fc FEFFFFEB 		bl	prvUnlockQueue
 2649              	.LVL310:
1615:../src/FreeRTOS/queue.c ****                 {
 2650              		.loc 1 1615 17 view .LVU821
1615:../src/FreeRTOS/queue.c ****                 {
 2651              		.loc 1 1615 21 is_stmt 0 view .LVU822
 2652 0200 FEFFFFEB 		bl	xTaskResumeAll
 2653              	.LVL311:
1615:../src/FreeRTOS/queue.c ****                 {
 2654              		.loc 1 1615 19 view .LVU823
 2655 0204 000050E3 		cmp	r0, #0
 2656 0208 D6FFFF1A 		bne	.L192
1617:../src/FreeRTOS/queue.c ****                 }
 2657              		.loc 1 1617 21 is_stmt 1 view .LVU824
 2658              		.syntax divided
 2659              	@ 1617 "../src/FreeRTOS/queue.c" 1
 2660 020c 000000EF 		SWI 0
 2661              	@ 0 "" 2
1617:../src/FreeRTOS/queue.c ****                 }
 2662              		.loc 1 1617 43 view .LVU825
 2663              		.arm
 2664              		.syntax unified
 2665 0210 D4FFFFEA 		b	.L192
 2666              	.L214:
1649:../src/FreeRTOS/queue.c ****                         {
 2667              		.loc 1 1649 25 view .LVU826
1649:../src/FreeRTOS/queue.c ****                         {
 2668              		.loc 1 1649 27 is_stmt 0 view .LVU827
 2669 0214 000056E3 		cmp	r6, #0
 2670 0218 0100001A 		bne	.L221
 2671              	.L206:
1663:../src/FreeRTOS/queue.c ****                         }
 2672              		.loc 1 1663 48 is_stmt 1 discriminator 1 view .LVU828
1668:../src/FreeRTOS/queue.c ****                 return errQUEUE_EMPTY;
 2673              		.loc 1 1668 53 discriminator 1 view .LVU829
1669:../src/FreeRTOS/queue.c ****             }
 2674              		.loc 1 1669 17 discriminator 1 view .LVU830
1669:../src/FreeRTOS/queue.c ****             }
 2675              		.loc 1 1669 24 is_stmt 0 discriminator 1 view .LVU831
 2676 021c 0000A0E3 		mov	r0, #0
 2677 0220 A0FFFFEA 		b	.L188
 2678              	.L221:
1651:../src/FreeRTOS/queue.c ****                             {
 2679              		.loc 1 1651 29 is_stmt 1 view .LVU832
 2680 0224 FEFFFFEB 		bl	vPortEnterCritical
 2681              	.LVL312:
1651:../src/FreeRTOS/queue.c ****                             {
 2682              		.loc 1 1651 49 view .LVU833
 2683              	.LBB17:
1653:../src/FreeRTOS/queue.c **** 
 2684              		.loc 1 1653 33 view .LVU834
1660:../src/FreeRTOS/queue.c ****                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHo
 2685              		.loc 1 1660 33 view .LVU835
1660:../src/FreeRTOS/queue.c ****                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHo
 2686              		.loc 1 1660 60 is_stmt 0 view .LVU836
 2687 0228 0400A0E1 		mov	r0, r4
 2688 022c FEFFFFEB 		bl	prvGetDisinheritPriorityAfterTimeout
 2689              	.LVL313:
 2690 0230 0010A0E1 		mov	r1, r0
 2691              	.LVL314:
1661:../src/FreeRTOS/queue.c ****                             }
 2692              		.loc 1 1661 33 is_stmt 1 view .LVU837
 2693 0234 080094E5 		ldr	r0, [r4, #8]
 2694              	.LVL315:
1661:../src/FreeRTOS/queue.c ****                             }
 2695              		.loc 1 1661 33 is_stmt 0 view .LVU838
 2696 0238 FEFFFFEB 		bl	vTaskPriorityDisinheritAfterTimeout
 2697              	.LVL316:
1661:../src/FreeRTOS/queue.c ****                             }
 2698              		.loc 1 1661 33 view .LVU839
 2699              	.LBE17:
1663:../src/FreeRTOS/queue.c ****                         }
 2700              		.loc 1 1663 29 is_stmt 1 view .LVU840
 2701 023c FEFFFFEB 		bl	vPortExitCritical
 2702              	.LVL317:
 2703 0240 F5FFFFEA 		b	.L206
 2704              		.cfi_endproc
 2705              	.LFE14:
 2707              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 2708              		.align	2
 2709              		.global	xQueueTakeMutexRecursive
 2710              		.syntax unified
 2711              		.arm
 2712              		.fpu neon
 2714              	xQueueTakeMutexRecursive:
 2715              	.LVL318:
 2716              	.LFB8:
 673:../src/FreeRTOS/queue.c ****         BaseType_t xReturn;
 2717              		.loc 1 673 5 view -0
 2718              		.cfi_startproc
 2719              		@ args = 0, pretend = 0, frame = 0
 2720              		@ frame_needed = 0, uses_anonymous_args = 0
 673:../src/FreeRTOS/queue.c ****         BaseType_t xReturn;
 2721              		.loc 1 673 5 is_stmt 0 view .LVU842
 2722 0000 70402DE9 		push	{r4, r5, r6, lr}
 2723              		.cfi_def_cfa_offset 16
 2724              		.cfi_offset 4, -16
 2725              		.cfi_offset 5, -12
 2726              		.cfi_offset 6, -8
 2727              		.cfi_offset 14, -4
 2728 0004 0150A0E1 		mov	r5, r1
 674:../src/FreeRTOS/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 2729              		.loc 1 674 9 is_stmt 1 view .LVU843
 675:../src/FreeRTOS/queue.c **** 
 2730              		.loc 1 675 9 view .LVU844
 2731              	.LVL319:
 677:../src/FreeRTOS/queue.c **** 
 2732              		.loc 1 677 9 view .LVU845
 2733 0008 004050E2 		subs	r4, r0, #0
 2734 000c 0C00000A 		beq	.L227
 2735              	.LVL320:
 2736              	.L223:
 677:../src/FreeRTOS/queue.c **** 
 2737              		.loc 1 677 32 discriminator 3 view .LVU846
 682:../src/FreeRTOS/queue.c **** 
 2738              		.loc 1 682 45 discriminator 3 view .LVU847
 684:../src/FreeRTOS/queue.c ****         {
 2739              		.loc 1 684 9 discriminator 3 view .LVU848
 684:../src/FreeRTOS/queue.c ****         {
 2740              		.loc 1 684 34 is_stmt 0 discriminator 3 view .LVU849
 2741 0010 086094E5 		ldr	r6, [r4, #8]
 684:../src/FreeRTOS/queue.c ****         {
 2742              		.loc 1 684 51 discriminator 3 view .LVU850
 2743 0014 FEFFFFEB 		bl	xTaskGetCurrentTaskHandle
 2744              	.LVL321:
 684:../src/FreeRTOS/queue.c ****         {
 2745              		.loc 1 684 11 discriminator 3 view .LVU851
 2746 0018 000056E1 		cmp	r6, r0
 2747 001c 0D00000A 		beq	.L228
 691:../src/FreeRTOS/queue.c **** 
 2748              		.loc 1 691 13 is_stmt 1 view .LVU852
 691:../src/FreeRTOS/queue.c **** 
 2749              		.loc 1 691 23 is_stmt 0 view .LVU853
 2750 0020 0510A0E1 		mov	r1, r5
 2751 0024 0400A0E1 		mov	r0, r4
 2752 0028 FEFFFFEB 		bl	xQueueSemaphoreTake
 2753              	.LVL322:
 696:../src/FreeRTOS/queue.c ****             {
 2754              		.loc 1 696 13 is_stmt 1 view .LVU854
 696:../src/FreeRTOS/queue.c ****             {
 2755              		.loc 1 696 15 is_stmt 0 view .LVU855
 2756 002c 000050E3 		cmp	r0, #0
 696:../src/FreeRTOS/queue.c ****             {
 2757              		.loc 1 696 15 view .LVU856
 2758 0030 7080BD08 		popeq	{r4, r5, r6, pc}
 698:../src/FreeRTOS/queue.c ****             }
 2759              		.loc 1 698 17 is_stmt 1 view .LVU857
 698:../src/FreeRTOS/queue.c ****             }
 2760              		.loc 1 698 40 is_stmt 0 view .LVU858
 2761 0034 0C3094E5 		ldr	r3, [r4, #12]
 698:../src/FreeRTOS/queue.c ****             }
 2762              		.loc 1 698 63 view .LVU859
 2763 0038 013083E2 		add	r3, r3, #1
 2764 003c 0C3084E5 		str	r3, [r4, #12]
 702:../src/FreeRTOS/queue.c ****             }
 2765              		.loc 1 702 60 is_stmt 1 view .LVU860
 706:../src/FreeRTOS/queue.c ****     }
 2766              		.loc 1 706 9 view .LVU861
 707:../src/FreeRTOS/queue.c **** 
 2767              		.loc 1 707 5 is_stmt 0 view .LVU862
 2768 0040 7080BDE8 		pop	{r4, r5, r6, pc}
 2769              	.LVL323:
 2770              	.L227:
 677:../src/FreeRTOS/queue.c **** 
 2771              		.loc 1 677 9 is_stmt 1 discriminator 1 view .LVU863
 2772 0044 A51200E3 		movw	r1, #677
 2773              	.LVL324:
 677:../src/FreeRTOS/queue.c **** 
 2774              		.loc 1 677 9 is_stmt 0 discriminator 1 view .LVU864
 2775 0048 000000E3 		movw	r0, #:lower16:.LC0
 2776              	.LVL325:
 677:../src/FreeRTOS/queue.c **** 
 2777              		.loc 1 677 9 discriminator 1 view .LVU865
 2778 004c 000040E3 		movt	r0, #:upper16:.LC0
 2779 0050 FEFFFFEB 		bl	R_OS_AssertCalled
 2780              	.LVL326:
 2781 0054 EDFFFFEA 		b	.L223
 2782              	.L228:
 686:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
 2783              		.loc 1 686 13 is_stmt 1 view .LVU866
 686:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
 2784              		.loc 1 686 36 is_stmt 0 view .LVU867
 2785 0058 0C3094E5 		ldr	r3, [r4, #12]
 686:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
 2786              		.loc 1 686 59 view .LVU868
 2787 005c 013083E2 		add	r3, r3, #1
 2788 0060 0C3084E5 		str	r3, [r4, #12]
 687:../src/FreeRTOS/queue.c ****         }
 2789              		.loc 1 687 13 is_stmt 1 view .LVU869
 2790              	.LVL327:
 687:../src/FreeRTOS/queue.c ****         }
 2791              		.loc 1 687 21 is_stmt 0 view .LVU870
 2792 0064 0100A0E3 		mov	r0, #1
 2793 0068 7080BDE8 		pop	{r4, r5, r6, pc}
 2794              		.cfi_endproc
 2795              	.LFE8:
 2797              		.section	.text.xQueuePeek,"ax",%progbits
 2798              		.align	2
 2799              		.global	xQueuePeek
 2800              		.syntax unified
 2801              		.arm
 2802              		.fpu neon
 2804              	xQueuePeek:
 2805              	.LVL328:
 2806              	.LFB15:
1683:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2807              		.loc 1 1683 1 is_stmt 1 view -0
 2808              		.cfi_startproc
 2809              		@ args = 0, pretend = 0, frame = 16
 2810              		@ frame_needed = 0, uses_anonymous_args = 0
1683:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2811              		.loc 1 1683 1 is_stmt 0 view .LVU872
 2812 0000 70402DE9 		push	{r4, r5, r6, lr}
 2813              		.cfi_def_cfa_offset 16
 2814              		.cfi_offset 4, -16
 2815              		.cfi_offset 5, -12
 2816              		.cfi_offset 6, -8
 2817              		.cfi_offset 14, -4
 2818 0004 10D04DE2 		sub	sp, sp, #16
 2819              		.cfi_def_cfa_offset 32
 2820 0008 0160A0E1 		mov	r6, r1
 2821 000c 04208DE5 		str	r2, [sp, #4]
1684:../src/FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 2822              		.loc 1 1684 5 is_stmt 1 view .LVU873
 2823              	.LVL329:
1685:../src/FreeRTOS/queue.c ****     int8_t * pcOriginalReadPosition;
 2824              		.loc 1 1685 5 view .LVU874
1686:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2825              		.loc 1 1686 5 view .LVU875
1687:../src/FreeRTOS/queue.c **** 
 2826              		.loc 1 1687 5 view .LVU876
1690:../src/FreeRTOS/queue.c **** 
 2827              		.loc 1 1690 5 view .LVU877
 2828 0010 004050E2 		subs	r4, r0, #0
 2829 0014 0900000A 		beq	.L245
 2830              	.LVL330:
 2831              	.L230:
1690:../src/FreeRTOS/queue.c **** 
 2832              		.loc 1 1690 32 discriminator 3 view .LVU878
1694:../src/FreeRTOS/queue.c **** 
 2833              		.loc 1 1694 5 discriminator 3 view .LVU879
 2834 0018 000056E3 		cmp	r6, #0
 2835 001c 0C00000A 		beq	.L246
 2836              	.L231:
1694:../src/FreeRTOS/queue.c **** 
 2837              		.loc 1 1694 103 discriminator 9 view .LVU880
1699:../src/FreeRTOS/queue.c ****         }
 2838              		.loc 1 1699 13 discriminator 9 view .LVU881
 2839 0020 FEFFFFEB 		bl	xTaskGetSchedulerState
 2840              	.LVL331:
 2841 0024 000050E3 		cmp	r0, #0
 2842 0028 0200001A 		bne	.L232
1699:../src/FreeRTOS/queue.c ****         }
 2843              		.loc 1 1699 13 is_stmt 0 discriminator 2 view .LVU882
 2844 002c 04309DE5 		ldr	r3, [sp, #4]
 2845 0030 000053E3 		cmp	r3, #0
 2846 0034 0E00001A 		bne	.L247
 2847              	.L232:
1683:../src/FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2848              		.loc 1 1683 1 discriminator 9 view .LVU883
 2849 0038 0050A0E3 		mov	r5, #0
 2850 003c 3B0000EA 		b	.L233
 2851              	.LVL332:
 2852              	.L245:
1690:../src/FreeRTOS/queue.c **** 
 2853              		.loc 1 1690 5 is_stmt 1 discriminator 1 view .LVU884
 2854 0040 9A1600E3 		movw	r1, #1690
 2855              	.LVL333:
1690:../src/FreeRTOS/queue.c **** 
 2856              		.loc 1 1690 5 is_stmt 0 discriminator 1 view .LVU885
 2857 0044 000000E3 		movw	r0, #:lower16:.LC0
 2858              	.LVL334:
1690:../src/FreeRTOS/queue.c **** 
 2859              		.loc 1 1690 5 discriminator 1 view .LVU886
 2860 0048 000040E3 		movt	r0, #:upper16:.LC0
 2861 004c FEFFFFEB 		bl	R_OS_AssertCalled
 2862              	.LVL335:
1690:../src/FreeRTOS/queue.c **** 
 2863              		.loc 1 1690 5 discriminator 1 view .LVU887
 2864 0050 F0FFFFEA 		b	.L230
 2865              	.L246:
1694:../src/FreeRTOS/queue.c **** 
 2866              		.loc 1 1694 5 discriminator 2 view .LVU888
 2867 0054 403094E5 		ldr	r3, [r4, #64]
 2868 0058 000053E3 		cmp	r3, #0
 2869 005c EFFFFF0A 		beq	.L231
1694:../src/FreeRTOS/queue.c **** 
 2870              		.loc 1 1694 5 is_stmt 1 view .LVU889
 2871 0060 9E1600E3 		movw	r1, #1694
 2872 0064 000000E3 		movw	r0, #:lower16:.LC0
 2873 0068 000040E3 		movt	r0, #:upper16:.LC0
 2874 006c FEFFFFEB 		bl	R_OS_AssertCalled
 2875              	.LVL336:
 2876 0070 EAFFFFEA 		b	.L231
 2877              	.L247:
1699:../src/FreeRTOS/queue.c ****         }
 2878              		.loc 1 1699 13 view .LVU890
 2879 0074 A31600E3 		movw	r1, #1699
 2880 0078 000000E3 		movw	r0, #:lower16:.LC0
 2881 007c 000040E3 		movt	r0, #:upper16:.LC0
 2882 0080 FEFFFFEB 		bl	R_OS_AssertCalled
 2883              	.LVL337:
 2884 0084 EBFFFFEA 		b	.L232
 2885              	.LVL338:
 2886              	.L250:
 2887              	.LBB18:
1719:../src/FreeRTOS/queue.c **** 
 2888              		.loc 1 1719 17 view .LVU891
1719:../src/FreeRTOS/queue.c **** 
 2889              		.loc 1 1719 40 is_stmt 0 view .LVU892
 2890 0088 0C5094E5 		ldr	r5, [r4, #12]
 2891              	.LVL339:
1721:../src/FreeRTOS/queue.c ****                 traceQUEUE_PEEK( pxQueue );
 2892              		.loc 1 1721 17 is_stmt 1 view .LVU893
 2893 008c 0610A0E1 		mov	r1, r6
 2894 0090 0400A0E1 		mov	r0, r4
 2895 0094 FEFFFFEB 		bl	prvCopyDataFromQueue
 2896              	.LVL340:
1722:../src/FreeRTOS/queue.c **** 
 2897              		.loc 1 1722 43 view .LVU894
1725:../src/FreeRTOS/queue.c **** 
 2898              		.loc 1 1725 17 view .LVU895
1725:../src/FreeRTOS/queue.c **** 
 2899              		.loc 1 1725 46 is_stmt 0 view .LVU896
 2900 0098 0C5084E5 		str	r5, [r4, #12]
1729:../src/FreeRTOS/queue.c ****                 {
 2901              		.loc 1 1729 17 is_stmt 1 view .LVU897
1729:../src/FreeRTOS/queue.c ****                 {
 2902              		.loc 1 1729 21 is_stmt 0 view .LVU898
 2903 009c 243094E5 		ldr	r3, [r4, #36]
1729:../src/FreeRTOS/queue.c ****                 {
 2904              		.loc 1 1729 19 view .LVU899
 2905 00a0 000053E3 		cmp	r3, #0
 2906 00a4 0300001A 		bne	.L248
 2907              	.L235:
1743:../src/FreeRTOS/queue.c ****                 }
 2908              		.loc 1 1743 45 is_stmt 1 view .LVU900
1746:../src/FreeRTOS/queue.c ****                 return pdPASS;
 2909              		.loc 1 1746 17 view .LVU901
 2910 00a8 FEFFFFEB 		bl	vPortExitCritical
 2911              	.LVL341:
1746:../src/FreeRTOS/queue.c ****                 return pdPASS;
 2912              		.loc 1 1746 36 view .LVU902
1747:../src/FreeRTOS/queue.c ****             }
 2913              		.loc 1 1747 17 view .LVU903
1747:../src/FreeRTOS/queue.c ****             }
 2914              		.loc 1 1747 24 is_stmt 0 view .LVU904
 2915 00ac 0100A0E3 		mov	r0, #1
 2916              	.LVL342:
 2917              	.L229:
1747:../src/FreeRTOS/queue.c ****             }
 2918              		.loc 1 1747 24 view .LVU905
 2919              	.LBE18:
1828:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2920              		.loc 1 1828 1 view .LVU906
 2921 00b0 10D08DE2 		add	sp, sp, #16
 2922              		.cfi_remember_state
 2923              		.cfi_def_cfa_offset 16
 2924              		@ sp needed
 2925 00b4 7080BDE8 		pop	{r4, r5, r6, pc}
 2926              	.LVL343:
 2927              	.L248:
 2928              		.cfi_restore_state
 2929              	.LBB19:
1731:../src/FreeRTOS/queue.c ****                     {
 2930              		.loc 1 1731 21 is_stmt 1 view .LVU907
1731:../src/FreeRTOS/queue.c ****                     {
 2931              		.loc 1 1731 25 is_stmt 0 view .LVU908
 2932 00b8 240084E2 		add	r0, r4, #36
 2933 00bc FEFFFFEB 		bl	xTaskRemoveFromEventList
 2934              	.LVL344:
1731:../src/FreeRTOS/queue.c ****                     {
 2935              		.loc 1 1731 23 view .LVU909
 2936 00c0 000050E3 		cmp	r0, #0
 2937 00c4 F7FFFF0A 		beq	.L235
1734:../src/FreeRTOS/queue.c ****                     }
 2938              		.loc 1 1734 25 is_stmt 1 view .LVU910
 2939              		.syntax divided
 2940              	@ 1734 "../src/FreeRTOS/queue.c" 1
 2941 00c8 000000EF 		SWI 0
 2942              	@ 0 "" 2
1734:../src/FreeRTOS/queue.c ****                     }
 2943              		.loc 1 1734 57 view .LVU911
 2944              		.arm
 2945              		.syntax unified
 2946 00cc F5FFFFEA 		b	.L235
 2947              	.LVL345:
 2948              	.L251:
1755:../src/FreeRTOS/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
 2949              		.loc 1 1755 21 view .LVU912
 2950 00d0 FEFFFFEB 		bl	vPortExitCritical
 2951              	.LVL346:
1755:../src/FreeRTOS/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
 2952              		.loc 1 1755 40 view .LVU913
1756:../src/FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
 2953              		.loc 1 1756 54 view .LVU914
1757:../src/FreeRTOS/queue.c ****                 }
 2954              		.loc 1 1757 21 view .LVU915
1757:../src/FreeRTOS/queue.c ****                 }
 2955              		.loc 1 1757 28 is_stmt 0 view .LVU916
 2956 00d4 0000A0E3 		mov	r0, #0
 2957 00d8 F4FFFFEA 		b	.L229
 2958              	.L252:
1764:../src/FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 2959              		.loc 1 1764 21 is_stmt 1 view .LVU917
 2960 00dc 08008DE2 		add	r0, sp, #8
 2961 00e0 FEFFFFEB 		bl	vTaskInternalSetTimeOutState
 2962              	.LVL347:
1765:../src/FreeRTOS/queue.c ****                 }
 2963              		.loc 1 1765 21 view .LVU918
1765:../src/FreeRTOS/queue.c ****                 }
 2964              		.loc 1 1765 35 is_stmt 0 view .LVU919
 2965 00e4 0150A0E3 		mov	r5, #1
 2966 00e8 190000EA 		b	.L238
 2967              	.LVL348:
 2968              	.L253:
1765:../src/FreeRTOS/queue.c ****                 }
 2969              		.loc 1 1765 35 view .LVU920
 2970              	.LBE19:
1780:../src/FreeRTOS/queue.c **** 
 2971              		.loc 1 1780 9 is_stmt 1 discriminator 1 view .LVU921
 2972 00ec 0030A0E3 		mov	r3, #0
 2973 00f0 4430C4E5 		strb	r3, [r4, #68]
 2974 00f4 1D0000EA 		b	.L239
 2975              	.L254:
1780:../src/FreeRTOS/queue.c **** 
 2976              		.loc 1 1780 9 discriminator 4 view .LVU922
 2977 00f8 0030A0E3 		mov	r3, #0
 2978 00fc 4530C4E5 		strb	r3, [r4, #69]
 2979 0100 1E0000EA 		b	.L240
 2980              	.L242:
1806:../src/FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
 2981              		.loc 1 1806 17 view .LVU923
 2982 0104 0400A0E1 		mov	r0, r4
 2983 0108 FEFFFFEB 		bl	prvUnlockQueue
 2984              	.LVL349:
1807:../src/FreeRTOS/queue.c ****             }
 2985              		.loc 1 1807 17 view .LVU924
1807:../src/FreeRTOS/queue.c ****             }
 2986              		.loc 1 1807 26 is_stmt 0 view .LVU925
 2987 010c FEFFFFEB 		bl	xTaskResumeAll
 2988              	.LVL350:
 2989 0110 060000EA 		b	.L233
 2990              	.L241:
1814:../src/FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
 2991              		.loc 1 1814 13 is_stmt 1 view .LVU926
 2992 0114 0400A0E1 		mov	r0, r4
 2993 0118 FEFFFFEB 		bl	prvUnlockQueue
 2994              	.LVL351:
1815:../src/FreeRTOS/queue.c **** 
 2995              		.loc 1 1815 13 view .LVU927
1815:../src/FreeRTOS/queue.c **** 
 2996              		.loc 1 1815 22 is_stmt 0 view .LVU928
 2997 011c FEFFFFEB 		bl	xTaskResumeAll
 2998              	.LVL352:
1817:../src/FreeRTOS/queue.c ****             {
 2999              		.loc 1 1817 13 is_stmt 1 view .LVU929
1817:../src/FreeRTOS/queue.c ****             {
 3000              		.loc 1 1817 17 is_stmt 0 view .LVU930
 3001 0120 0400A0E1 		mov	r0, r4
 3002 0124 FEFFFFEB 		bl	prvIsQueueEmpty
 3003              	.LVL353:
1817:../src/FreeRTOS/queue.c ****             {
 3004              		.loc 1 1817 15 view .LVU931
 3005 0128 000050E3 		cmp	r0, #0
 3006 012c 2700001A 		bne	.L249
 3007              	.LVL354:
 3008              	.L233:
1699:../src/FreeRTOS/queue.c ****         }
 3009              		.loc 1 1699 114 is_stmt 1 discriminator 9 view .LVU932
1706:../src/FreeRTOS/queue.c ****     {
 3010              		.loc 1 1706 5 discriminator 9 view .LVU933
1708:../src/FreeRTOS/queue.c ****         {
 3011              		.loc 1 1708 9 discriminator 9 view .LVU934
 3012 0130 FEFFFFEB 		bl	vPortEnterCritical
 3013              	.LVL355:
1708:../src/FreeRTOS/queue.c ****         {
 3014              		.loc 1 1708 29 discriminator 9 view .LVU935
 3015              	.LBB20:
1710:../src/FreeRTOS/queue.c **** 
 3016              		.loc 1 1710 13 discriminator 9 view .LVU936
1710:../src/FreeRTOS/queue.c **** 
 3017              		.loc 1 1710 31 is_stmt 0 discriminator 9 view .LVU937
 3018 0134 383094E5 		ldr	r3, [r4, #56]
 3019              	.LVL356:
1714:../src/FreeRTOS/queue.c ****             {
 3020              		.loc 1 1714 13 is_stmt 1 discriminator 9 view .LVU938
1714:../src/FreeRTOS/queue.c ****             {
 3021              		.loc 1 1714 15 is_stmt 0 discriminator 9 view .LVU939
 3022 0138 000053E3 		cmp	r3, #0
 3023 013c D1FFFF1A 		bne	.L250
1751:../src/FreeRTOS/queue.c ****                 {
 3024              		.loc 1 1751 17 is_stmt 1 view .LVU940
1751:../src/FreeRTOS/queue.c ****                 {
 3025              		.loc 1 1751 34 is_stmt 0 view .LVU941
 3026 0140 04309DE5 		ldr	r3, [sp, #4]
 3027              	.LVL357:
1751:../src/FreeRTOS/queue.c ****                 {
 3028              		.loc 1 1751 19 view .LVU942
 3029 0144 000053E3 		cmp	r3, #0
 3030 0148 E0FFFF0A 		beq	.L251
1759:../src/FreeRTOS/queue.c ****                 {
 3031              		.loc 1 1759 22 is_stmt 1 view .LVU943
1759:../src/FreeRTOS/queue.c ****                 {
 3032              		.loc 1 1759 24 is_stmt 0 view .LVU944
 3033 014c 000055E3 		cmp	r5, #0
 3034 0150 E1FFFF0A 		beq	.L252
 3035              	.LVL358:
 3036              	.L238:
1770:../src/FreeRTOS/queue.c ****                 }
 3037              		.loc 1 1770 45 is_stmt 1 view .LVU945
 3038              	.LBE20:
1774:../src/FreeRTOS/queue.c **** 
 3039              		.loc 1 1774 9 view .LVU946
 3040 0154 FEFFFFEB 		bl	vPortExitCritical
 3041              	.LVL359:
1774:../src/FreeRTOS/queue.c **** 
 3042              		.loc 1 1774 28 view .LVU947
1779:../src/FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 3043              		.loc 1 1779 9 view .LVU948
 3044 0158 FEFFFFEB 		bl	vTaskSuspendAll
 3045              	.LVL360:
1780:../src/FreeRTOS/queue.c **** 
 3046              		.loc 1 1780 9 view .LVU949
 3047 015c FEFFFFEB 		bl	vPortEnterCritical
 3048              	.LVL361:
1780:../src/FreeRTOS/queue.c **** 
 3049              		.loc 1 1780 9 view .LVU950
1780:../src/FreeRTOS/queue.c **** 
 3050              		.loc 1 1780 9 view .LVU951
 3051 0160 4430D4E5 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 3052 0164 7330AFE6 		sxtb	r3, r3
 3053 0168 010073E3 		cmn	r3, #1
 3054 016c DEFFFF0A 		beq	.L253
 3055              	.L239:
1780:../src/FreeRTOS/queue.c **** 
 3056              		.loc 1 1780 9 discriminator 3 view .LVU952
 3057 0170 4530D4E5 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 3058 0174 7330AFE6 		sxtb	r3, r3
 3059 0178 010073E3 		cmn	r3, #1
 3060 017c DDFFFF0A 		beq	.L254
 3061              	.L240:
1780:../src/FreeRTOS/queue.c **** 
 3062              		.loc 1 1780 9 discriminator 6 view .LVU953
 3063 0180 FEFFFFEB 		bl	vPortExitCritical
 3064              	.LVL362:
1780:../src/FreeRTOS/queue.c **** 
 3065              		.loc 1 1780 32 discriminator 6 view .LVU954
1783:../src/FreeRTOS/queue.c ****         {
 3066              		.loc 1 1783 9 discriminator 6 view .LVU955
1783:../src/FreeRTOS/queue.c ****         {
 3067              		.loc 1 1783 13 is_stmt 0 discriminator 6 view .LVU956
 3068 0184 04108DE2 		add	r1, sp, #4
 3069 0188 08008DE2 		add	r0, sp, #8
 3070 018c FEFFFFEB 		bl	xTaskCheckForTimeOut
 3071              	.LVL363:
1783:../src/FreeRTOS/queue.c ****         {
 3072              		.loc 1 1783 11 discriminator 6 view .LVU957
 3073 0190 000050E3 		cmp	r0, #0
 3074 0194 DEFFFF1A 		bne	.L241
1787:../src/FreeRTOS/queue.c ****             {
 3075              		.loc 1 1787 13 is_stmt 1 view .LVU958
1787:../src/FreeRTOS/queue.c ****             {
 3076              		.loc 1 1787 17 is_stmt 0 view .LVU959
 3077 0198 0400A0E1 		mov	r0, r4
 3078 019c FEFFFFEB 		bl	prvIsQueueEmpty
 3079              	.LVL364:
1787:../src/FreeRTOS/queue.c ****             {
 3080              		.loc 1 1787 15 view .LVU960
 3081 01a0 000050E3 		cmp	r0, #0
 3082 01a4 D6FFFF0A 		beq	.L242
1789:../src/FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 3083              		.loc 1 1789 55 is_stmt 1 view .LVU961
1790:../src/FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
 3084              		.loc 1 1790 17 view .LVU962
 3085 01a8 04109DE5 		ldr	r1, [sp, #4]
 3086 01ac 240084E2 		add	r0, r4, #36
 3087 01b0 FEFFFFEB 		bl	vTaskPlaceOnEventList
 3088              	.LVL365:
1791:../src/FreeRTOS/queue.c **** 
 3089              		.loc 1 1791 17 view .LVU963
 3090 01b4 0400A0E1 		mov	r0, r4
 3091 01b8 FEFFFFEB 		bl	prvUnlockQueue
 3092              	.LVL366:
1793:../src/FreeRTOS/queue.c ****                 {
 3093              		.loc 1 1793 17 view .LVU964
1793:../src/FreeRTOS/queue.c ****                 {
 3094              		.loc 1 1793 21 is_stmt 0 view .LVU965
 3095 01bc FEFFFFEB 		bl	xTaskResumeAll
 3096              	.LVL367:
1793:../src/FreeRTOS/queue.c ****                 {
 3097              		.loc 1 1793 19 view .LVU966
 3098 01c0 000050E3 		cmp	r0, #0
 3099 01c4 D9FFFF1A 		bne	.L233
1795:../src/FreeRTOS/queue.c ****                 }
 3100              		.loc 1 1795 21 is_stmt 1 view .LVU967
 3101              		.syntax divided
 3102              	@ 1795 "../src/FreeRTOS/queue.c" 1
 3103 01c8 000000EF 		SWI 0
 3104              	@ 0 "" 2
1795:../src/FreeRTOS/queue.c ****                 }
 3105              		.loc 1 1795 43 view .LVU968
 3106              		.arm
 3107              		.syntax unified
 3108 01cc D7FFFFEA 		b	.L233
 3109              	.L249:
1820:../src/FreeRTOS/queue.c ****             }
 3110              		.loc 1 1820 24 is_stmt 0 view .LVU969
 3111 01d0 0000A0E3 		mov	r0, #0
 3112 01d4 B5FFFFEA 		b	.L229
 3113              		.cfi_endproc
 3114              	.LFE15:
 3116              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 3117              		.align	2
 3118              		.global	xQueueReceiveFromISR
 3119              		.syntax unified
 3120              		.arm
 3121              		.fpu neon
 3123              	xQueueReceiveFromISR:
 3124              	.LVL368:
 3125              	.LFB16:
1834:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 3126              		.loc 1 1834 1 is_stmt 1 view -0
 3127              		.cfi_startproc
 3128              		@ args = 0, pretend = 0, frame = 0
 3129              		@ frame_needed = 0, uses_anonymous_args = 0
1834:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 3130              		.loc 1 1834 1 is_stmt 0 view .LVU971
 3131 0000 F0472DE9 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 3132              		.cfi_def_cfa_offset 32
 3133              		.cfi_offset 4, -32
 3134              		.cfi_offset 5, -28
 3135              		.cfi_offset 6, -24
 3136              		.cfi_offset 7, -20
 3137              		.cfi_offset 8, -16
 3138              		.cfi_offset 9, -12
 3139              		.cfi_offset 10, -8
 3140              		.cfi_offset 14, -4
 3141 0004 0150A0E1 		mov	r5, r1
 3142 0008 0270A0E1 		mov	r7, r2
1835:../src/FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 3143              		.loc 1 1835 5 is_stmt 1 view .LVU972
1836:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 3144              		.loc 1 1836 5 view .LVU973
1837:../src/FreeRTOS/queue.c **** 
 3145              		.loc 1 1837 5 view .LVU974
 3146              	.LVL369:
1839:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3147              		.loc 1 1839 5 view .LVU975
 3148 000c 004050E2 		subs	r4, r0, #0
 3149 0010 0C00000A 		beq	.L266
 3150              	.LVL370:
 3151              	.L256:
1839:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3152              		.loc 1 1839 28 discriminator 3 view .LVU976
1840:../src/FreeRTOS/queue.c **** 
 3153              		.loc 1 1840 5 discriminator 3 view .LVU977
 3154 0014 000055E3 		cmp	r5, #0
 3155 0018 0F00000A 		beq	.L267
 3156              	.L257:
1840:../src/FreeRTOS/queue.c **** 
 3157              		.loc 1 1840 95 discriminator 9 view .LVU978
1856:../src/FreeRTOS/queue.c **** 
 3158              		.loc 1 1856 5 discriminator 9 view .LVU979
 3159 001c FEFFFFEB 		bl	vPortValidateInterruptPriority
 3160              	.LVL371:
1858:../src/FreeRTOS/queue.c ****     {
 3161              		.loc 1 1858 5 discriminator 9 view .LVU980
1858:../src/FreeRTOS/queue.c ****     {
 3162              		.loc 1 1858 30 is_stmt 0 discriminator 9 view .LVU981
 3163 0020 FEFFFFEB 		bl	ulPortSetInterruptMask
 3164              	.LVL372:
 3165 0024 0060A0E1 		mov	r6, r0
 3166              	.LVL373:
 3167              	.LBB21:
1860:../src/FreeRTOS/queue.c **** 
 3168              		.loc 1 1860 9 is_stmt 1 discriminator 9 view .LVU982
1860:../src/FreeRTOS/queue.c **** 
 3169              		.loc 1 1860 27 is_stmt 0 discriminator 9 view .LVU983
 3170 0028 388094E5 		ldr	r8, [r4, #56]
 3171              	.LVL374:
1863:../src/FreeRTOS/queue.c ****         {
 3172              		.loc 1 1863 9 is_stmt 1 discriminator 9 view .LVU984
1863:../src/FreeRTOS/queue.c ****         {
 3173              		.loc 1 1863 11 is_stmt 0 discriminator 9 view .LVU985
 3174 002c 000058E3 		cmp	r8, #0
 3175 0030 1100001A 		bne	.L268
1916:../src/FreeRTOS/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 3176              		.loc 1 1916 21 view .LVU986
 3177 0034 0040A0E3 		mov	r4, #0
 3178              	.LVL375:
 3179              	.L258:
1917:../src/FreeRTOS/queue.c ****         }
 3180              		.loc 1 1917 58 is_stmt 1 view .LVU987
 3181              	.LBE21:
1920:../src/FreeRTOS/queue.c **** 
 3182              		.loc 1 1920 5 view .LVU988
 3183 0038 0600A0E1 		mov	r0, r6
 3184 003c FEFFFFEB 		bl	vPortClearInterruptMask
 3185              	.LVL376:
1922:../src/FreeRTOS/queue.c **** }
 3186              		.loc 1 1922 5 view .LVU989
1923:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 3187              		.loc 1 1923 1 is_stmt 0 view .LVU990
 3188 0040 0400A0E1 		mov	r0, r4
 3189 0044 F087BDE8 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 3190              	.LVL377:
 3191              	.L266:
1839:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3192              		.loc 1 1839 5 is_stmt 1 discriminator 1 view .LVU991
 3193 0048 2F1700E3 		movw	r1, #1839
 3194              	.LVL378:
1839:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3195              		.loc 1 1839 5 is_stmt 0 discriminator 1 view .LVU992
 3196 004c 000000E3 		movw	r0, #:lower16:.LC0
 3197              	.LVL379:
1839:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3198              		.loc 1 1839 5 discriminator 1 view .LVU993
 3199 0050 000040E3 		movt	r0, #:upper16:.LC0
 3200 0054 FEFFFFEB 		bl	R_OS_AssertCalled
 3201              	.LVL380:
1839:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3202              		.loc 1 1839 5 discriminator 1 view .LVU994
 3203 0058 EDFFFFEA 		b	.L256
 3204              	.L267:
1840:../src/FreeRTOS/queue.c **** 
 3205              		.loc 1 1840 5 discriminator 2 view .LVU995
 3206 005c 403094E5 		ldr	r3, [r4, #64]
 3207 0060 000053E3 		cmp	r3, #0
 3208 0064 ECFFFF0A 		beq	.L257
1840:../src/FreeRTOS/queue.c **** 
 3209              		.loc 1 1840 5 is_stmt 1 view .LVU996
 3210 0068 731EA0E3 		mov	r1, #1840
 3211 006c 000000E3 		movw	r0, #:lower16:.LC0
 3212 0070 000040E3 		movt	r0, #:upper16:.LC0
 3213 0074 FEFFFFEB 		bl	R_OS_AssertCalled
 3214              	.LVL381:
 3215 0078 E7FFFFEA 		b	.L257
 3216              	.LVL382:
 3217              	.L268:
 3218              	.LBB23:
 3219              	.LBB22:
1865:../src/FreeRTOS/queue.c **** 
 3220              		.loc 1 1865 13 view .LVU997
1865:../src/FreeRTOS/queue.c **** 
 3221              		.loc 1 1865 26 is_stmt 0 view .LVU998
 3222 007c 4490D4E5 		ldrb	r9, [r4, #68]	@ zero_extendqisi2
 3223 0080 7990AFE6 		sxtb	r9, r9
 3224              	.LVL383:
1867:../src/FreeRTOS/queue.c **** 
 3225              		.loc 1 1867 51 is_stmt 1 view .LVU999
1869:../src/FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 3226              		.loc 1 1869 13 view .LVU1000
 3227 0084 0510A0E1 		mov	r1, r5
 3228 0088 0400A0E1 		mov	r0, r4
 3229              	.LVL384:
1869:../src/FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 3230              		.loc 1 1869 13 is_stmt 0 view .LVU1001
 3231 008c FEFFFFEB 		bl	prvCopyDataFromQueue
 3232              	.LVL385:
1870:../src/FreeRTOS/queue.c **** 
 3233              		.loc 1 1870 13 is_stmt 1 view .LVU1002
1870:../src/FreeRTOS/queue.c **** 
 3234              		.loc 1 1870 60 is_stmt 0 view .LVU1003
 3235 0090 018048E2 		sub	r8, r8, #1
 3236              	.LVL386:
1870:../src/FreeRTOS/queue.c **** 
 3237              		.loc 1 1870 40 view .LVU1004
 3238 0094 388084E5 		str	r8, [r4, #56]
1876:../src/FreeRTOS/queue.c ****             {
 3239              		.loc 1 1876 13 is_stmt 1 view .LVU1005
1876:../src/FreeRTOS/queue.c ****             {
 3240              		.loc 1 1876 15 is_stmt 0 view .LVU1006
 3241 0098 010079E3 		cmn	r9, #1
 3242 009c 0600000A 		beq	.L269
1907:../src/FreeRTOS/queue.c **** 
 3243              		.loc 1 1907 17 is_stmt 1 view .LVU1007
 3244 00a0 7F0059E3 		cmp	r9, #127
 3245 00a4 1100000A 		beq	.L270
 3246              	.L260:
1907:../src/FreeRTOS/queue.c **** 
 3247              		.loc 1 1907 57 discriminator 3 view .LVU1008
1909:../src/FreeRTOS/queue.c ****             }
 3248              		.loc 1 1909 17 discriminator 3 view .LVU1009
1909:../src/FreeRTOS/queue.c ****             }
 3249              		.loc 1 1909 57 is_stmt 0 discriminator 3 view .LVU1010
 3250 00a8 019089E2 		add	r9, r9, #1
 3251              	.LVL387:
1909:../src/FreeRTOS/queue.c ****             }
 3252              		.loc 1 1909 36 discriminator 3 view .LVU1011
 3253 00ac 7990AFE6 		sxtb	r9, r9
 3254              	.LVL388:
1909:../src/FreeRTOS/queue.c ****             }
 3255              		.loc 1 1909 34 discriminator 3 view .LVU1012
 3256 00b0 4490C4E5 		strb	r9, [r4, #68]
1912:../src/FreeRTOS/queue.c ****         }
 3257              		.loc 1 1912 21 discriminator 3 view .LVU1013
 3258 00b4 0140A0E3 		mov	r4, #1
 3259              	.LVL389:
1912:../src/FreeRTOS/queue.c ****         }
 3260              		.loc 1 1912 21 discriminator 3 view .LVU1014
 3261 00b8 DEFFFFEA 		b	.L258
 3262              	.LVL390:
 3263              	.L269:
1878:../src/FreeRTOS/queue.c ****                 {
 3264              		.loc 1 1878 17 is_stmt 1 view .LVU1015
1878:../src/FreeRTOS/queue.c ****                 {
 3265              		.loc 1 1878 21 is_stmt 0 view .LVU1016
 3266 00bc 103094E5 		ldr	r3, [r4, #16]
1878:../src/FreeRTOS/queue.c ****                 {
 3267              		.loc 1 1878 19 view .LVU1017
 3268 00c0 000053E3 		cmp	r3, #0
1912:../src/FreeRTOS/queue.c ****         }
 3269              		.loc 1 1912 21 view .LVU1018
 3270 00c4 0140A003 		moveq	r4, #1
 3271              	.LVL391:
1912:../src/FreeRTOS/queue.c ****         }
 3272              		.loc 1 1912 21 view .LVU1019
 3273 00c8 DAFFFF0A 		beq	.L258
 3274              	.LVL392:
 3275              	.L271:
1880:../src/FreeRTOS/queue.c ****                     {
 3276              		.loc 1 1880 21 is_stmt 1 view .LVU1020
1880:../src/FreeRTOS/queue.c ****                     {
 3277              		.loc 1 1880 25 is_stmt 0 view .LVU1021
 3278 00cc 100084E2 		add	r0, r4, #16
 3279 00d0 FEFFFFEB 		bl	xTaskRemoveFromEventList
 3280              	.LVL393:
1880:../src/FreeRTOS/queue.c ****                     {
 3281              		.loc 1 1880 23 view .LVU1022
 3282 00d4 000050E3 		cmp	r0, #0
 3283 00d8 0900000A 		beq	.L263
1884:../src/FreeRTOS/queue.c ****                         {
 3284              		.loc 1 1884 25 is_stmt 1 view .LVU1023
1884:../src/FreeRTOS/queue.c ****                         {
 3285              		.loc 1 1884 27 is_stmt 0 view .LVU1024
 3286 00dc 000057E3 		cmp	r7, #0
 3287 00e0 0900000A 		beq	.L264
1886:../src/FreeRTOS/queue.c ****                         }
 3288              		.loc 1 1886 29 is_stmt 1 view .LVU1025
1886:../src/FreeRTOS/queue.c ****                         }
 3289              		.loc 1 1886 56 is_stmt 0 view .LVU1026
 3290 00e4 0140A0E3 		mov	r4, #1
 3291              	.LVL394:
1886:../src/FreeRTOS/queue.c ****                         }
 3292              		.loc 1 1886 56 view .LVU1027
 3293 00e8 004087E5 		str	r4, [r7]
 3294 00ec D1FFFFEA 		b	.L258
 3295              	.LVL395:
 3296              	.L270:
1907:../src/FreeRTOS/queue.c **** 
 3297              		.loc 1 1907 17 is_stmt 1 discriminator 1 view .LVU1028
 3298 00f0 731700E3 		movw	r1, #1907
 3299 00f4 000000E3 		movw	r0, #:lower16:.LC0
 3300 00f8 000040E3 		movt	r0, #:upper16:.LC0
 3301 00fc FEFFFFEB 		bl	R_OS_AssertCalled
 3302              	.LVL396:
 3303 0100 E8FFFFEA 		b	.L260
 3304              	.L263:
1912:../src/FreeRTOS/queue.c ****         }
 3305              		.loc 1 1912 21 is_stmt 0 view .LVU1029
 3306 0104 0140A0E3 		mov	r4, #1
 3307              	.LVL397:
1912:../src/FreeRTOS/queue.c ****         }
 3308              		.loc 1 1912 21 view .LVU1030
 3309 0108 CAFFFFEA 		b	.L258
 3310              	.LVL398:
 3311              	.L264:
1912:../src/FreeRTOS/queue.c ****         }
 3312              		.loc 1 1912 21 view .LVU1031
 3313 010c 0140A0E3 		mov	r4, #1
 3314              	.LVL399:
1912:../src/FreeRTOS/queue.c ****         }
 3315              		.loc 1 1912 21 view .LVU1032
 3316 0110 C8FFFFEA 		b	.L258
 3317              	.LBE22:
 3318              	.LBE23:
 3319              		.cfi_endproc
 3320              	.LFE16:
 3322              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 3323              		.align	2
 3324              		.global	xQueuePeekFromISR
 3325              		.syntax unified
 3326              		.arm
 3327              		.fpu neon
 3329              	xQueuePeekFromISR:
 3330              	.LVL400:
 3331              	.LFB17:
1928:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 3332              		.loc 1 1928 1 is_stmt 1 view -0
 3333              		.cfi_startproc
 3334              		@ args = 0, pretend = 0, frame = 0
 3335              		@ frame_needed = 0, uses_anonymous_args = 0
1928:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 3336              		.loc 1 1928 1 is_stmt 0 view .LVU1034
 3337 0000 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 3338              		.cfi_def_cfa_offset 24
 3339              		.cfi_offset 4, -24
 3340              		.cfi_offset 5, -20
 3341              		.cfi_offset 6, -16
 3342              		.cfi_offset 7, -12
 3343              		.cfi_offset 8, -8
 3344              		.cfi_offset 14, -4
 3345 0004 0150A0E1 		mov	r5, r1
1929:../src/FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 3346              		.loc 1 1929 5 is_stmt 1 view .LVU1035
1930:../src/FreeRTOS/queue.c ****     int8_t * pcOriginalReadPosition;
 3347              		.loc 1 1930 5 view .LVU1036
1931:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 3348              		.loc 1 1931 5 view .LVU1037
1932:../src/FreeRTOS/queue.c **** 
 3349              		.loc 1 1932 5 view .LVU1038
 3350              	.LVL401:
1934:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3351              		.loc 1 1934 5 view .LVU1039
 3352 0008 004050E2 		subs	r4, r0, #0
 3353 000c 0F00000A 		beq	.L279
 3354              	.LVL402:
 3355              	.L273:
1934:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3356              		.loc 1 1934 28 discriminator 3 view .LVU1040
1935:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3357              		.loc 1 1935 5 discriminator 3 view .LVU1041
 3358 0010 000055E3 		cmp	r5, #0
 3359 0014 1200000A 		beq	.L280
 3360              	.L274:
1935:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3361              		.loc 1 1935 95 discriminator 9 view .LVU1042
1936:../src/FreeRTOS/queue.c **** 
 3362              		.loc 1 1936 5 discriminator 9 view .LVU1043
 3363 0018 403094E5 		ldr	r3, [r4, #64]
 3364 001c 000053E3 		cmp	r3, #0
 3365 0020 1700000A 		beq	.L281
 3366              	.L275:
1936:../src/FreeRTOS/queue.c **** 
 3367              		.loc 1 1936 45 discriminator 3 view .LVU1044
1952:../src/FreeRTOS/queue.c **** 
 3368              		.loc 1 1952 5 discriminator 3 view .LVU1045
 3369 0024 FEFFFFEB 		bl	vPortValidateInterruptPriority
 3370              	.LVL403:
1954:../src/FreeRTOS/queue.c ****     {
 3371              		.loc 1 1954 5 discriminator 3 view .LVU1046
1954:../src/FreeRTOS/queue.c ****     {
 3372              		.loc 1 1954 30 is_stmt 0 discriminator 3 view .LVU1047
 3373 0028 FEFFFFEB 		bl	ulPortSetInterruptMask
 3374              	.LVL404:
 3375 002c 0060A0E1 		mov	r6, r0
 3376              	.LVL405:
1957:../src/FreeRTOS/queue.c ****         {
 3377              		.loc 1 1957 9 is_stmt 1 discriminator 3 view .LVU1048
1957:../src/FreeRTOS/queue.c ****         {
 3378              		.loc 1 1957 20 is_stmt 0 discriminator 3 view .LVU1049
 3379 0030 383094E5 		ldr	r3, [r4, #56]
1957:../src/FreeRTOS/queue.c ****         {
 3380              		.loc 1 1957 11 discriminator 3 view .LVU1050
 3381 0034 000053E3 		cmp	r3, #0
 3382 0038 1600001A 		bne	.L282
1971:../src/FreeRTOS/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 3383              		.loc 1 1971 21 view .LVU1051
 3384 003c 0040A0E3 		mov	r4, #0
 3385              	.LVL406:
 3386              	.L276:
1972:../src/FreeRTOS/queue.c ****         }
 3387              		.loc 1 1972 55 is_stmt 1 view .LVU1052
1975:../src/FreeRTOS/queue.c **** 
 3388              		.loc 1 1975 5 view .LVU1053
 3389 0040 0600A0E1 		mov	r0, r6
 3390 0044 FEFFFFEB 		bl	vPortClearInterruptMask
 3391              	.LVL407:
1977:../src/FreeRTOS/queue.c **** }
 3392              		.loc 1 1977 5 view .LVU1054
1978:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 3393              		.loc 1 1978 1 is_stmt 0 view .LVU1055
 3394 0048 0400A0E1 		mov	r0, r4
 3395 004c F081BDE8 		pop	{r4, r5, r6, r7, r8, pc}
 3396              	.LVL408:
 3397              	.L279:
1934:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3398              		.loc 1 1934 5 is_stmt 1 discriminator 1 view .LVU1056
 3399 0050 8E1700E3 		movw	r1, #1934
 3400              	.LVL409:
1934:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3401              		.loc 1 1934 5 is_stmt 0 discriminator 1 view .LVU1057
 3402 0054 000000E3 		movw	r0, #:lower16:.LC0
 3403              	.LVL410:
1934:../src/FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3404              		.loc 1 1934 5 discriminator 1 view .LVU1058
 3405 0058 000040E3 		movt	r0, #:upper16:.LC0
 3406 005c FEFFFFEB 		bl	R_OS_AssertCalled
 3407              	.LVL411:
 3408 0060 EAFFFFEA 		b	.L273
 3409              	.L280:
1935:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3410              		.loc 1 1935 5 discriminator 2 view .LVU1059
 3411 0064 403094E5 		ldr	r3, [r4, #64]
 3412 0068 000053E3 		cmp	r3, #0
 3413 006c E9FFFF0A 		beq	.L274
1935:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3414              		.loc 1 1935 5 is_stmt 1 view .LVU1060
 3415 0070 8F1700E3 		movw	r1, #1935
 3416 0074 000000E3 		movw	r0, #:lower16:.LC0
 3417 0078 000040E3 		movt	r0, #:upper16:.LC0
 3418 007c FEFFFFEB 		bl	R_OS_AssertCalled
 3419              	.LVL412:
 3420 0080 E4FFFFEA 		b	.L274
 3421              	.L281:
1936:../src/FreeRTOS/queue.c **** 
 3422              		.loc 1 1936 5 discriminator 1 view .LVU1061
 3423 0084 791EA0E3 		mov	r1, #1936
 3424 0088 000000E3 		movw	r0, #:lower16:.LC0
 3425 008c 000040E3 		movt	r0, #:upper16:.LC0
 3426 0090 FEFFFFEB 		bl	R_OS_AssertCalled
 3427              	.LVL413:
 3428 0094 E2FFFFEA 		b	.L275
 3429              	.LVL414:
 3430              	.L282:
1959:../src/FreeRTOS/queue.c **** 
 3431              		.loc 1 1959 48 view .LVU1062
1963:../src/FreeRTOS/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 3432              		.loc 1 1963 13 view .LVU1063
1963:../src/FreeRTOS/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 3433              		.loc 1 1963 36 is_stmt 0 view .LVU1064
 3434 0098 0C7094E5 		ldr	r7, [r4, #12]
 3435              	.LVL415:
1964:../src/FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 3436              		.loc 1 1964 13 is_stmt 1 view .LVU1065
 3437 009c 0510A0E1 		mov	r1, r5
 3438 00a0 0400A0E1 		mov	r0, r4
 3439              	.LVL416:
1964:../src/FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 3440              		.loc 1 1964 13 is_stmt 0 view .LVU1066
 3441 00a4 FEFFFFEB 		bl	prvCopyDataFromQueue
 3442              	.LVL417:
1965:../src/FreeRTOS/queue.c **** 
 3443              		.loc 1 1965 13 is_stmt 1 view .LVU1067
1965:../src/FreeRTOS/queue.c **** 
 3444              		.loc 1 1965 42 is_stmt 0 view .LVU1068
 3445 00a8 0C7084E5 		str	r7, [r4, #12]
1967:../src/FreeRTOS/queue.c ****         }
 3446              		.loc 1 1967 13 is_stmt 1 view .LVU1069
 3447              	.LVL418:
1967:../src/FreeRTOS/queue.c ****         }
 3448              		.loc 1 1967 21 is_stmt 0 view .LVU1070
 3449 00ac 0140A0E3 		mov	r4, #1
 3450              	.LVL419:
1967:../src/FreeRTOS/queue.c ****         }
 3451              		.loc 1 1967 21 view .LVU1071
 3452 00b0 E2FFFFEA 		b	.L276
 3453              		.cfi_endproc
 3454              	.LFE17:
 3456              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 3457              		.align	2
 3458              		.global	uxQueueMessagesWaiting
 3459              		.syntax unified
 3460              		.arm
 3461              		.fpu neon
 3463              	uxQueueMessagesWaiting:
 3464              	.LVL420:
 3465              	.LFB18:
1982:../src/FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 3466              		.loc 1 1982 1 is_stmt 1 view -0
 3467              		.cfi_startproc
 3468              		@ args = 0, pretend = 0, frame = 0
 3469              		@ frame_needed = 0, uses_anonymous_args = 0
1982:../src/FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 3470              		.loc 1 1982 1 is_stmt 0 view .LVU1073
 3471 0000 10402DE9 		push	{r4, lr}
 3472              		.cfi_def_cfa_offset 8
 3473              		.cfi_offset 4, -8
 3474              		.cfi_offset 14, -4
1983:../src/FreeRTOS/queue.c **** 
 3475              		.loc 1 1983 5 is_stmt 1 view .LVU1074
1985:../src/FreeRTOS/queue.c **** 
 3476              		.loc 1 1985 5 view .LVU1075
 3477 0004 004050E2 		subs	r4, r0, #0
 3478 0008 0400000A 		beq	.L286
 3479              	.LVL421:
 3480              	.L284:
1985:../src/FreeRTOS/queue.c **** 
 3481              		.loc 1 1985 27 discriminator 3 view .LVU1076
1987:../src/FreeRTOS/queue.c ****     {
 3482              		.loc 1 1987 5 discriminator 3 view .LVU1077
 3483 000c FEFFFFEB 		bl	vPortEnterCritical
 3484              	.LVL422:
1987:../src/FreeRTOS/queue.c ****     {
 3485              		.loc 1 1987 25 discriminator 3 view .LVU1078
1989:../src/FreeRTOS/queue.c ****     }
 3486              		.loc 1 1989 9 discriminator 3 view .LVU1079
1989:../src/FreeRTOS/queue.c ****     }
 3487              		.loc 1 1989 18 is_stmt 0 discriminator 3 view .LVU1080
 3488 0010 384094E5 		ldr	r4, [r4, #56]
 3489              	.LVL423:
1991:../src/FreeRTOS/queue.c **** 
 3490              		.loc 1 1991 5 is_stmt 1 discriminator 3 view .LVU1081
 3491 0014 FEFFFFEB 		bl	vPortExitCritical
 3492              	.LVL424:
1991:../src/FreeRTOS/queue.c **** 
 3493              		.loc 1 1991 24 discriminator 3 view .LVU1082
1993:../src/FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3494              		.loc 1 1993 5 discriminator 3 view .LVU1083
1994:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 3495              		.loc 1 1994 1 is_stmt 0 discriminator 3 view .LVU1084
 3496 0018 0400A0E1 		mov	r0, r4
 3497 001c 1080BDE8 		pop	{r4, pc}
 3498              	.LVL425:
 3499              	.L286:
1985:../src/FreeRTOS/queue.c **** 
 3500              		.loc 1 1985 5 is_stmt 1 discriminator 1 view .LVU1085
 3501 0020 C11700E3 		movw	r1, #1985
 3502 0024 000000E3 		movw	r0, #:lower16:.LC0
 3503              	.LVL426:
1985:../src/FreeRTOS/queue.c **** 
 3504              		.loc 1 1985 5 is_stmt 0 discriminator 1 view .LVU1086
 3505 0028 000040E3 		movt	r0, #:upper16:.LC0
 3506 002c FEFFFFEB 		bl	R_OS_AssertCalled
 3507              	.LVL427:
 3508 0030 F5FFFFEA 		b	.L284
 3509              		.cfi_endproc
 3510              	.LFE18:
 3512              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 3513              		.align	2
 3514              		.global	uxQueueSpacesAvailable
 3515              		.syntax unified
 3516              		.arm
 3517              		.fpu neon
 3519              	uxQueueSpacesAvailable:
 3520              	.LVL428:
 3521              	.LFB19:
1998:../src/FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 3522              		.loc 1 1998 1 is_stmt 1 view -0
 3523              		.cfi_startproc
 3524              		@ args = 0, pretend = 0, frame = 0
 3525              		@ frame_needed = 0, uses_anonymous_args = 0
1998:../src/FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 3526              		.loc 1 1998 1 is_stmt 0 view .LVU1088
 3527 0000 10402DE9 		push	{r4, lr}
 3528              		.cfi_def_cfa_offset 8
 3529              		.cfi_offset 4, -8
 3530              		.cfi_offset 14, -4
1999:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 3531              		.loc 1 1999 5 is_stmt 1 view .LVU1089
2000:../src/FreeRTOS/queue.c **** 
 3532              		.loc 1 2000 5 view .LVU1090
 3533              	.LVL429:
2002:../src/FreeRTOS/queue.c **** 
 3534              		.loc 1 2002 5 view .LVU1091
 3535 0004 004050E2 		subs	r4, r0, #0
 3536 0008 0600000A 		beq	.L290
 3537              	.LVL430:
 3538              	.L288:
2002:../src/FreeRTOS/queue.c **** 
 3539              		.loc 1 2002 28 discriminator 3 view .LVU1092
2004:../src/FreeRTOS/queue.c ****     {
 3540              		.loc 1 2004 5 discriminator 3 view .LVU1093
 3541 000c FEFFFFEB 		bl	vPortEnterCritical
 3542              	.LVL431:
2004:../src/FreeRTOS/queue.c ****     {
 3543              		.loc 1 2004 25 discriminator 3 view .LVU1094
2006:../src/FreeRTOS/queue.c ****     }
 3544              		.loc 1 2006 9 discriminator 3 view .LVU1095
2006:../src/FreeRTOS/queue.c ****     }
 3545              		.loc 1 2006 27 is_stmt 0 discriminator 3 view .LVU1096
 3546 0010 3C3094E5 		ldr	r3, [r4, #60]
2006:../src/FreeRTOS/queue.c ****     }
 3547              		.loc 1 2006 47 discriminator 3 view .LVU1097
 3548 0014 384094E5 		ldr	r4, [r4, #56]
 3549              	.LVL432:
2006:../src/FreeRTOS/queue.c ****     }
 3550              		.loc 1 2006 18 discriminator 3 view .LVU1098
 3551 0018 044043E0 		sub	r4, r3, r4
 3552              	.LVL433:
2008:../src/FreeRTOS/queue.c **** 
 3553              		.loc 1 2008 5 is_stmt 1 discriminator 3 view .LVU1099
 3554 001c FEFFFFEB 		bl	vPortExitCritical
 3555              	.LVL434:
2008:../src/FreeRTOS/queue.c **** 
 3556              		.loc 1 2008 24 discriminator 3 view .LVU1100
2010:../src/FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3557              		.loc 1 2010 5 discriminator 3 view .LVU1101
2011:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 3558              		.loc 1 2011 1 is_stmt 0 discriminator 3 view .LVU1102
 3559 0020 0400A0E1 		mov	r0, r4
 3560 0024 1080BDE8 		pop	{r4, pc}
 3561              	.LVL435:
 3562              	.L290:
2002:../src/FreeRTOS/queue.c **** 
 3563              		.loc 1 2002 5 is_stmt 1 discriminator 1 view .LVU1103
 3564 0028 D21700E3 		movw	r1, #2002
 3565 002c 000000E3 		movw	r0, #:lower16:.LC0
 3566              	.LVL436:
2002:../src/FreeRTOS/queue.c **** 
 3567              		.loc 1 2002 5 is_stmt 0 discriminator 1 view .LVU1104
 3568 0030 000040E3 		movt	r0, #:upper16:.LC0
 3569 0034 FEFFFFEB 		bl	R_OS_AssertCalled
 3570              	.LVL437:
 3571 0038 F3FFFFEA 		b	.L288
 3572              		.cfi_endproc
 3573              	.LFE19:
 3575              		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 3576              		.align	2
 3577              		.global	uxQueueMessagesWaitingFromISR
 3578              		.syntax unified
 3579              		.arm
 3580              		.fpu neon
 3582              	uxQueueMessagesWaitingFromISR:
 3583              	.LVL438:
 3584              	.LFB20:
2015:../src/FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 3585              		.loc 1 2015 1 is_stmt 1 view -0
 3586              		.cfi_startproc
 3587              		@ args = 0, pretend = 0, frame = 0
 3588              		@ frame_needed = 0, uses_anonymous_args = 0
2015:../src/FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 3589              		.loc 1 2015 1 is_stmt 0 view .LVU1106
 3590 0000 10402DE9 		push	{r4, lr}
 3591              		.cfi_def_cfa_offset 8
 3592              		.cfi_offset 4, -8
 3593              		.cfi_offset 14, -4
2016:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 3594              		.loc 1 2016 5 is_stmt 1 view .LVU1107
2017:../src/FreeRTOS/queue.c **** 
 3595              		.loc 1 2017 5 view .LVU1108
 3596              	.LVL439:
2019:../src/FreeRTOS/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3597              		.loc 1 2019 5 view .LVU1109
 3598 0004 004050E2 		subs	r4, r0, #0
 3599 0008 0100000A 		beq	.L294
 3600              	.LVL440:
 3601              	.L292:
2019:../src/FreeRTOS/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3602              		.loc 1 2019 28 discriminator 3 view .LVU1110
2020:../src/FreeRTOS/queue.c **** 
 3603              		.loc 1 2020 5 discriminator 3 view .LVU1111
2020:../src/FreeRTOS/queue.c **** 
 3604              		.loc 1 2020 14 is_stmt 0 discriminator 3 view .LVU1112
 3605 000c 380094E5 		ldr	r0, [r4, #56]
 3606              	.LVL441:
2022:../src/FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3607              		.loc 1 2022 5 is_stmt 1 discriminator 3 view .LVU1113
2023:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 3608              		.loc 1 2023 1 is_stmt 0 discriminator 3 view .LVU1114
 3609 0010 1080BDE8 		pop	{r4, pc}
 3610              	.LVL442:
 3611              	.L294:
2019:../src/FreeRTOS/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3612              		.loc 1 2019 5 is_stmt 1 discriminator 1 view .LVU1115
 3613 0014 E31700E3 		movw	r1, #2019
 3614 0018 000000E3 		movw	r0, #:lower16:.LC0
 3615              	.LVL443:
2019:../src/FreeRTOS/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3616              		.loc 1 2019 5 is_stmt 0 discriminator 1 view .LVU1116
 3617 001c 000040E3 		movt	r0, #:upper16:.LC0
 3618 0020 FEFFFFEB 		bl	R_OS_AssertCalled
 3619              	.LVL444:
 3620 0024 F8FFFFEA 		b	.L292
 3621              		.cfi_endproc
 3622              	.LFE20:
 3624              		.section	.text.uxQueueGetQueueNumber,"ax",%progbits
 3625              		.align	2
 3626              		.global	uxQueueGetQueueNumber
 3627              		.syntax unified
 3628              		.arm
 3629              		.fpu neon
 3631              	uxQueueGetQueueNumber:
 3632              	.LVL445:
 3633              	.LFB22:
2071:../src/FreeRTOS/queue.c ****         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 3634              		.loc 1 2071 5 is_stmt 1 view -0
 3635              		.cfi_startproc
 3636              		@ args = 0, pretend = 0, frame = 0
 3637              		@ frame_needed = 0, uses_anonymous_args = 0
 3638              		@ link register save eliminated.
2072:../src/FreeRTOS/queue.c ****     }
 3639              		.loc 1 2072 9 view .LVU1118
2073:../src/FreeRTOS/queue.c **** 
 3640              		.loc 1 2073 5 is_stmt 0 view .LVU1119
 3641 0000 480090E5 		ldr	r0, [r0, #72]
 3642              	.LVL446:
2073:../src/FreeRTOS/queue.c **** 
 3643              		.loc 1 2073 5 view .LVU1120
 3644 0004 1EFF2FE1 		bx	lr
 3645              		.cfi_endproc
 3646              	.LFE22:
 3648              		.section	.text.vQueueSetQueueNumber,"ax",%progbits
 3649              		.align	2
 3650              		.global	vQueueSetQueueNumber
 3651              		.syntax unified
 3652              		.arm
 3653              		.fpu neon
 3655              	vQueueSetQueueNumber:
 3656              	.LVL447:
 3657              	.LFB23:
2082:../src/FreeRTOS/queue.c ****         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 3658              		.loc 1 2082 5 is_stmt 1 view -0
 3659              		.cfi_startproc
 3660              		@ args = 0, pretend = 0, frame = 0
 3661              		@ frame_needed = 0, uses_anonymous_args = 0
 3662              		@ link register save eliminated.
2083:../src/FreeRTOS/queue.c ****     }
 3663              		.loc 1 2083 9 view .LVU1122
2083:../src/FreeRTOS/queue.c ****     }
 3664              		.loc 1 2083 49 is_stmt 0 view .LVU1123
 3665 0000 481080E5 		str	r1, [r0, #72]
2084:../src/FreeRTOS/queue.c **** 
 3666              		.loc 1 2084 5 view .LVU1124
 3667 0004 1EFF2FE1 		bx	lr
 3668              		.cfi_endproc
 3669              	.LFE23:
 3671              		.section	.text.ucQueueGetQueueType,"ax",%progbits
 3672              		.align	2
 3673              		.global	ucQueueGetQueueType
 3674              		.syntax unified
 3675              		.arm
 3676              		.fpu neon
 3678              	ucQueueGetQueueType:
 3679              	.LVL448:
 3680              	.LFB24:
2092:../src/FreeRTOS/queue.c ****         return ( ( Queue_t * ) xQueue )->ucQueueType;
 3681              		.loc 1 2092 5 is_stmt 1 view -0
 3682              		.cfi_startproc
 3683              		@ args = 0, pretend = 0, frame = 0
 3684              		@ frame_needed = 0, uses_anonymous_args = 0
 3685              		@ link register save eliminated.
2093:../src/FreeRTOS/queue.c ****     }
 3686              		.loc 1 2093 9 view .LVU1126
2094:../src/FreeRTOS/queue.c **** 
 3687              		.loc 1 2094 5 is_stmt 0 view .LVU1127
 3688 0000 4C00D0E5 		ldrb	r0, [r0, #76]	@ zero_extendqisi2
 3689              	.LVL449:
2094:../src/FreeRTOS/queue.c **** 
 3690              		.loc 1 2094 5 view .LVU1128
 3691 0004 1EFF2FE1 		bx	lr
 3692              		.cfi_endproc
 3693              	.LFE24:
 3695              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 3696              		.align	2
 3697              		.global	xQueueIsQueueEmptyFromISR
 3698              		.syntax unified
 3699              		.arm
 3700              		.fpu neon
 3702              	xQueueIsQueueEmptyFromISR:
 3703              	.LVL450:
 3704              	.LFB30:
2372:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 3705              		.loc 1 2372 1 is_stmt 1 view -0
 3706              		.cfi_startproc
 3707              		@ args = 0, pretend = 0, frame = 0
 3708              		@ frame_needed = 0, uses_anonymous_args = 0
2372:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 3709              		.loc 1 2372 1 is_stmt 0 view .LVU1130
 3710 0000 10402DE9 		push	{r4, lr}
 3711              		.cfi_def_cfa_offset 8
 3712              		.cfi_offset 4, -8
 3713              		.cfi_offset 14, -4
2373:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 3714              		.loc 1 2373 5 is_stmt 1 view .LVU1131
2374:../src/FreeRTOS/queue.c **** 
 3715              		.loc 1 2374 5 view .LVU1132
 3716              	.LVL451:
2376:../src/FreeRTOS/queue.c **** 
 3717              		.loc 1 2376 5 view .LVU1133
 3718 0004 004050E2 		subs	r4, r0, #0
 3719 0008 0400000A 		beq	.L303
 3720              	.LVL452:
 3721              	.L299:
2376:../src/FreeRTOS/queue.c **** 
 3722              		.loc 1 2376 28 discriminator 3 view .LVU1134
2378:../src/FreeRTOS/queue.c ****     {
 3723              		.loc 1 2378 5 discriminator 3 view .LVU1135
2378:../src/FreeRTOS/queue.c ****     {
 3724              		.loc 1 2378 16 is_stmt 0 discriminator 3 view .LVU1136
 3725 000c 383094E5 		ldr	r3, [r4, #56]
2378:../src/FreeRTOS/queue.c ****     {
 3726              		.loc 1 2378 7 discriminator 3 view .LVU1137
 3727 0010 000053E3 		cmp	r3, #0
 3728 0014 0600001A 		bne	.L301
2380:../src/FreeRTOS/queue.c ****     }
 3729              		.loc 1 2380 17 view .LVU1138
 3730 0018 0100A0E3 		mov	r0, #1
 3731 001c 1080BDE8 		pop	{r4, pc}
 3732              	.LVL453:
 3733              	.L303:
2376:../src/FreeRTOS/queue.c **** 
 3734              		.loc 1 2376 5 is_stmt 1 discriminator 1 view .LVU1139
 3735 0020 481900E3 		movw	r1, #2376
 3736 0024 000000E3 		movw	r0, #:lower16:.LC0
 3737              	.LVL454:
2376:../src/FreeRTOS/queue.c **** 
 3738              		.loc 1 2376 5 is_stmt 0 discriminator 1 view .LVU1140
 3739 0028 000040E3 		movt	r0, #:upper16:.LC0
 3740 002c FEFFFFEB 		bl	R_OS_AssertCalled
 3741              	.LVL455:
 3742 0030 F5FFFFEA 		b	.L299
 3743              	.L301:
2384:../src/FreeRTOS/queue.c ****     }
 3744              		.loc 1 2384 17 view .LVU1141
 3745 0034 0000A0E3 		mov	r0, #0
 3746              	.LVL456:
2387:../src/FreeRTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3747              		.loc 1 2387 5 is_stmt 1 view .LVU1142
2388:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 3748              		.loc 1 2388 1 is_stmt 0 view .LVU1143
 3749 0038 1080BDE8 		pop	{r4, pc}
 3750              		.cfi_endproc
 3751              	.LFE30:
 3753              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 3754              		.align	2
 3755              		.global	xQueueIsQueueFullFromISR
 3756              		.syntax unified
 3757              		.arm
 3758              		.fpu neon
 3760              	xQueueIsQueueFullFromISR:
 3761              	.LVL457:
 3762              	.LFB32:
2410:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2411:../src/FreeRTOS/queue.c **** 
2412:../src/FreeRTOS/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2413:../src/FreeRTOS/queue.c **** {
 3763              		.loc 1 2413 1 is_stmt 1 view -0
 3764              		.cfi_startproc
 3765              		@ args = 0, pretend = 0, frame = 0
 3766              		@ frame_needed = 0, uses_anonymous_args = 0
 3767              		.loc 1 2413 1 is_stmt 0 view .LVU1145
 3768 0000 10402DE9 		push	{r4, lr}
 3769              		.cfi_def_cfa_offset 8
 3770              		.cfi_offset 4, -8
 3771              		.cfi_offset 14, -4
2414:../src/FreeRTOS/queue.c ****     BaseType_t xReturn;
 3772              		.loc 1 2414 5 is_stmt 1 view .LVU1146
2415:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 3773              		.loc 1 2415 5 view .LVU1147
 3774              	.LVL458:
2416:../src/FreeRTOS/queue.c **** 
2417:../src/FreeRTOS/queue.c ****     configASSERT( pxQueue );
 3775              		.loc 1 2417 5 view .LVU1148
 3776 0004 004050E2 		subs	r4, r0, #0
 3777 0008 0500000A 		beq	.L309
 3778              	.LVL459:
 3779              	.L305:
 3780              		.loc 1 2417 28 discriminator 3 view .LVU1149
2418:../src/FreeRTOS/queue.c **** 
2419:../src/FreeRTOS/queue.c ****     if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 3781              		.loc 1 2419 5 discriminator 3 view .LVU1150
 3782              		.loc 1 2419 16 is_stmt 0 discriminator 3 view .LVU1151
 3783 000c 382094E5 		ldr	r2, [r4, #56]
 3784              		.loc 1 2419 46 discriminator 3 view .LVU1152
 3785 0010 3C3094E5 		ldr	r3, [r4, #60]
 3786              		.loc 1 2419 7 discriminator 3 view .LVU1153
 3787 0014 030052E1 		cmp	r2, r3
 3788 0018 0600000A 		beq	.L310
2420:../src/FreeRTOS/queue.c ****     {
2421:../src/FreeRTOS/queue.c ****         xReturn = pdTRUE;
2422:../src/FreeRTOS/queue.c ****     }
2423:../src/FreeRTOS/queue.c ****     else
2424:../src/FreeRTOS/queue.c ****     {
2425:../src/FreeRTOS/queue.c ****         xReturn = pdFALSE;
 3789              		.loc 1 2425 17 view .LVU1154
 3790 001c 0000A0E3 		mov	r0, #0
 3791              	.LVL460:
2426:../src/FreeRTOS/queue.c ****     }
2427:../src/FreeRTOS/queue.c **** 
2428:../src/FreeRTOS/queue.c ****     return xReturn;
 3792              		.loc 1 2428 5 is_stmt 1 view .LVU1155
2429:../src/FreeRTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3793              		.loc 1 2429 1 is_stmt 0 view .LVU1156
 3794 0020 1080BDE8 		pop	{r4, pc}
 3795              	.LVL461:
 3796              	.L309:
2417:../src/FreeRTOS/queue.c **** 
 3797              		.loc 1 2417 5 is_stmt 1 discriminator 1 view .LVU1157
 3798 0024 711900E3 		movw	r1, #2417
 3799 0028 000000E3 		movw	r0, #:lower16:.LC0
 3800              	.LVL462:
2417:../src/FreeRTOS/queue.c **** 
 3801              		.loc 1 2417 5 is_stmt 0 discriminator 1 view .LVU1158
 3802 002c 000040E3 		movt	r0, #:upper16:.LC0
 3803 0030 FEFFFFEB 		bl	R_OS_AssertCalled
 3804              	.LVL463:
 3805 0034 F4FFFFEA 		b	.L305
 3806              	.L310:
2421:../src/FreeRTOS/queue.c ****     }
 3807              		.loc 1 2421 17 view .LVU1159
 3808 0038 0100A0E3 		mov	r0, #1
 3809 003c 1080BDE8 		pop	{r4, pc}
 3810              		.cfi_endproc
 3811              	.LFE32:
 3813              		.section	.text.vQueueAddToRegistry,"ax",%progbits
 3814              		.align	2
 3815              		.global	vQueueAddToRegistry
 3816              		.syntax unified
 3817              		.arm
 3818              		.fpu neon
 3820              	vQueueAddToRegistry:
 3821              	.LVL464:
 3822              	.LFB33:
2430:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2431:../src/FreeRTOS/queue.c **** 
2432:../src/FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2433:../src/FreeRTOS/queue.c **** 
2434:../src/FreeRTOS/queue.c ****     BaseType_t xQueueCRSend( QueueHandle_t xQueue,
2435:../src/FreeRTOS/queue.c ****                              const void * pvItemToQueue,
2436:../src/FreeRTOS/queue.c ****                              TickType_t xTicksToWait )
2437:../src/FreeRTOS/queue.c ****     {
2438:../src/FreeRTOS/queue.c ****         BaseType_t xReturn;
2439:../src/FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
2440:../src/FreeRTOS/queue.c **** 
2441:../src/FreeRTOS/queue.c ****         /* If the queue is already full we may have to block.  A critical section
2442:../src/FreeRTOS/queue.c ****          * is required to prevent an interrupt removing something from the queue
2443:../src/FreeRTOS/queue.c ****          * between the check to see if the queue is full and blocking on the queue. */
2444:../src/FreeRTOS/queue.c ****         portDISABLE_INTERRUPTS();
2445:../src/FreeRTOS/queue.c ****         {
2446:../src/FreeRTOS/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
2447:../src/FreeRTOS/queue.c ****             {
2448:../src/FreeRTOS/queue.c ****                 /* The queue is full - do we want to block or just leave without
2449:../src/FreeRTOS/queue.c ****                  * posting? */
2450:../src/FreeRTOS/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2451:../src/FreeRTOS/queue.c ****                 {
2452:../src/FreeRTOS/queue.c ****                     /* As this is called from a coroutine we cannot block directly, but
2453:../src/FreeRTOS/queue.c ****                      * return indicating that we need to block. */
2454:../src/FreeRTOS/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2455:../src/FreeRTOS/queue.c ****                     portENABLE_INTERRUPTS();
2456:../src/FreeRTOS/queue.c ****                     return errQUEUE_BLOCKED;
2457:../src/FreeRTOS/queue.c ****                 }
2458:../src/FreeRTOS/queue.c ****                 else
2459:../src/FreeRTOS/queue.c ****                 {
2460:../src/FreeRTOS/queue.c ****                     portENABLE_INTERRUPTS();
2461:../src/FreeRTOS/queue.c ****                     return errQUEUE_FULL;
2462:../src/FreeRTOS/queue.c ****                 }
2463:../src/FreeRTOS/queue.c ****             }
2464:../src/FreeRTOS/queue.c ****         }
2465:../src/FreeRTOS/queue.c ****         portENABLE_INTERRUPTS();
2466:../src/FreeRTOS/queue.c **** 
2467:../src/FreeRTOS/queue.c ****         portDISABLE_INTERRUPTS();
2468:../src/FreeRTOS/queue.c ****         {
2469:../src/FreeRTOS/queue.c ****             if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2470:../src/FreeRTOS/queue.c ****             {
2471:../src/FreeRTOS/queue.c ****                 /* There is room in the queue, copy the data into the queue. */
2472:../src/FreeRTOS/queue.c ****                 prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2473:../src/FreeRTOS/queue.c ****                 xReturn = pdPASS;
2474:../src/FreeRTOS/queue.c **** 
2475:../src/FreeRTOS/queue.c ****                 /* Were any co-routines waiting for data to become available? */
2476:../src/FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2477:../src/FreeRTOS/queue.c ****                 {
2478:../src/FreeRTOS/queue.c ****                     /* In this instance the co-routine could be placed directly
2479:../src/FreeRTOS/queue.c ****                      * into the ready list as we are within a critical section.
2480:../src/FreeRTOS/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2481:../src/FreeRTOS/queue.c ****                      * the event were caused from within an interrupt. */
2482:../src/FreeRTOS/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2483:../src/FreeRTOS/queue.c ****                     {
2484:../src/FreeRTOS/queue.c ****                         /* The co-routine waiting has a higher priority so record
2485:../src/FreeRTOS/queue.c ****                          * that a yield might be appropriate. */
2486:../src/FreeRTOS/queue.c ****                         xReturn = errQUEUE_YIELD;
2487:../src/FreeRTOS/queue.c ****                     }
2488:../src/FreeRTOS/queue.c ****                     else
2489:../src/FreeRTOS/queue.c ****                     {
2490:../src/FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2491:../src/FreeRTOS/queue.c ****                     }
2492:../src/FreeRTOS/queue.c ****                 }
2493:../src/FreeRTOS/queue.c ****                 else
2494:../src/FreeRTOS/queue.c ****                 {
2495:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2496:../src/FreeRTOS/queue.c ****                 }
2497:../src/FreeRTOS/queue.c ****             }
2498:../src/FreeRTOS/queue.c ****             else
2499:../src/FreeRTOS/queue.c ****             {
2500:../src/FreeRTOS/queue.c ****                 xReturn = errQUEUE_FULL;
2501:../src/FreeRTOS/queue.c ****             }
2502:../src/FreeRTOS/queue.c ****         }
2503:../src/FreeRTOS/queue.c ****         portENABLE_INTERRUPTS();
2504:../src/FreeRTOS/queue.c **** 
2505:../src/FreeRTOS/queue.c ****         return xReturn;
2506:../src/FreeRTOS/queue.c ****     }
2507:../src/FreeRTOS/queue.c **** 
2508:../src/FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2509:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2510:../src/FreeRTOS/queue.c **** 
2511:../src/FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2512:../src/FreeRTOS/queue.c **** 
2513:../src/FreeRTOS/queue.c ****     BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
2514:../src/FreeRTOS/queue.c ****                                 void * pvBuffer,
2515:../src/FreeRTOS/queue.c ****                                 TickType_t xTicksToWait )
2516:../src/FreeRTOS/queue.c ****     {
2517:../src/FreeRTOS/queue.c ****         BaseType_t xReturn;
2518:../src/FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
2519:../src/FreeRTOS/queue.c **** 
2520:../src/FreeRTOS/queue.c ****         /* If the queue is already empty we may have to block.  A critical section
2521:../src/FreeRTOS/queue.c ****          * is required to prevent an interrupt adding something to the queue
2522:../src/FreeRTOS/queue.c ****          * between the check to see if the queue is empty and blocking on the queue. */
2523:../src/FreeRTOS/queue.c ****         portDISABLE_INTERRUPTS();
2524:../src/FreeRTOS/queue.c ****         {
2525:../src/FreeRTOS/queue.c ****             if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2526:../src/FreeRTOS/queue.c ****             {
2527:../src/FreeRTOS/queue.c ****                 /* There are no messages in the queue, do we want to block or just
2528:../src/FreeRTOS/queue.c ****                  * leave with nothing? */
2529:../src/FreeRTOS/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2530:../src/FreeRTOS/queue.c ****                 {
2531:../src/FreeRTOS/queue.c ****                     /* As this is a co-routine we cannot block directly, but return
2532:../src/FreeRTOS/queue.c ****                      * indicating that we need to block. */
2533:../src/FreeRTOS/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) 
2534:../src/FreeRTOS/queue.c ****                     portENABLE_INTERRUPTS();
2535:../src/FreeRTOS/queue.c ****                     return errQUEUE_BLOCKED;
2536:../src/FreeRTOS/queue.c ****                 }
2537:../src/FreeRTOS/queue.c ****                 else
2538:../src/FreeRTOS/queue.c ****                 {
2539:../src/FreeRTOS/queue.c ****                     portENABLE_INTERRUPTS();
2540:../src/FreeRTOS/queue.c ****                     return errQUEUE_FULL;
2541:../src/FreeRTOS/queue.c ****                 }
2542:../src/FreeRTOS/queue.c ****             }
2543:../src/FreeRTOS/queue.c ****             else
2544:../src/FreeRTOS/queue.c ****             {
2545:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2546:../src/FreeRTOS/queue.c ****             }
2547:../src/FreeRTOS/queue.c ****         }
2548:../src/FreeRTOS/queue.c ****         portENABLE_INTERRUPTS();
2549:../src/FreeRTOS/queue.c **** 
2550:../src/FreeRTOS/queue.c ****         portDISABLE_INTERRUPTS();
2551:../src/FreeRTOS/queue.c ****         {
2552:../src/FreeRTOS/queue.c ****             if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2553:../src/FreeRTOS/queue.c ****             {
2554:../src/FreeRTOS/queue.c ****                 /* Data is available from the queue. */
2555:../src/FreeRTOS/queue.c ****                 pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2556:../src/FreeRTOS/queue.c **** 
2557:../src/FreeRTOS/queue.c ****                 if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2558:../src/FreeRTOS/queue.c ****                 {
2559:../src/FreeRTOS/queue.c ****                     pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2560:../src/FreeRTOS/queue.c ****                 }
2561:../src/FreeRTOS/queue.c ****                 else
2562:../src/FreeRTOS/queue.c ****                 {
2563:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2564:../src/FreeRTOS/queue.c ****                 }
2565:../src/FreeRTOS/queue.c **** 
2566:../src/FreeRTOS/queue.c ****                 --( pxQueue->uxMessagesWaiting );
2567:../src/FreeRTOS/queue.c ****                 ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( un
2568:../src/FreeRTOS/queue.c **** 
2569:../src/FreeRTOS/queue.c ****                 xReturn = pdPASS;
2570:../src/FreeRTOS/queue.c **** 
2571:../src/FreeRTOS/queue.c ****                 /* Were any co-routines waiting for space to become available? */
2572:../src/FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2573:../src/FreeRTOS/queue.c ****                 {
2574:../src/FreeRTOS/queue.c ****                     /* In this instance the co-routine could be placed directly
2575:../src/FreeRTOS/queue.c ****                      * into the ready list as we are within a critical section.
2576:../src/FreeRTOS/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2577:../src/FreeRTOS/queue.c ****                      * the event were caused from within an interrupt. */
2578:../src/FreeRTOS/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2579:../src/FreeRTOS/queue.c ****                     {
2580:../src/FreeRTOS/queue.c ****                         xReturn = errQUEUE_YIELD;
2581:../src/FreeRTOS/queue.c ****                     }
2582:../src/FreeRTOS/queue.c ****                     else
2583:../src/FreeRTOS/queue.c ****                     {
2584:../src/FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2585:../src/FreeRTOS/queue.c ****                     }
2586:../src/FreeRTOS/queue.c ****                 }
2587:../src/FreeRTOS/queue.c ****                 else
2588:../src/FreeRTOS/queue.c ****                 {
2589:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2590:../src/FreeRTOS/queue.c ****                 }
2591:../src/FreeRTOS/queue.c ****             }
2592:../src/FreeRTOS/queue.c ****             else
2593:../src/FreeRTOS/queue.c ****             {
2594:../src/FreeRTOS/queue.c ****                 xReturn = pdFAIL;
2595:../src/FreeRTOS/queue.c ****             }
2596:../src/FreeRTOS/queue.c ****         }
2597:../src/FreeRTOS/queue.c ****         portENABLE_INTERRUPTS();
2598:../src/FreeRTOS/queue.c **** 
2599:../src/FreeRTOS/queue.c ****         return xReturn;
2600:../src/FreeRTOS/queue.c ****     }
2601:../src/FreeRTOS/queue.c **** 
2602:../src/FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2603:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2604:../src/FreeRTOS/queue.c **** 
2605:../src/FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2606:../src/FreeRTOS/queue.c **** 
2607:../src/FreeRTOS/queue.c ****     BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
2608:../src/FreeRTOS/queue.c ****                                     const void * pvItemToQueue,
2609:../src/FreeRTOS/queue.c ****                                     BaseType_t xCoRoutinePreviouslyWoken )
2610:../src/FreeRTOS/queue.c ****     {
2611:../src/FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
2612:../src/FreeRTOS/queue.c **** 
2613:../src/FreeRTOS/queue.c ****         /* Cannot block within an ISR so if there is no space on the queue then
2614:../src/FreeRTOS/queue.c ****          * exit without doing anything. */
2615:../src/FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2616:../src/FreeRTOS/queue.c ****         {
2617:../src/FreeRTOS/queue.c ****             prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2618:../src/FreeRTOS/queue.c **** 
2619:../src/FreeRTOS/queue.c ****             /* We only want to wake one co-routine per ISR, so check that a
2620:../src/FreeRTOS/queue.c ****              * co-routine has not already been woken. */
2621:../src/FreeRTOS/queue.c ****             if( xCoRoutinePreviouslyWoken == pdFALSE )
2622:../src/FreeRTOS/queue.c ****             {
2623:../src/FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2624:../src/FreeRTOS/queue.c ****                 {
2625:../src/FreeRTOS/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2626:../src/FreeRTOS/queue.c ****                     {
2627:../src/FreeRTOS/queue.c ****                         return pdTRUE;
2628:../src/FreeRTOS/queue.c ****                     }
2629:../src/FreeRTOS/queue.c ****                     else
2630:../src/FreeRTOS/queue.c ****                     {
2631:../src/FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2632:../src/FreeRTOS/queue.c ****                     }
2633:../src/FreeRTOS/queue.c ****                 }
2634:../src/FreeRTOS/queue.c ****                 else
2635:../src/FreeRTOS/queue.c ****                 {
2636:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2637:../src/FreeRTOS/queue.c ****                 }
2638:../src/FreeRTOS/queue.c ****             }
2639:../src/FreeRTOS/queue.c ****             else
2640:../src/FreeRTOS/queue.c ****             {
2641:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2642:../src/FreeRTOS/queue.c ****             }
2643:../src/FreeRTOS/queue.c ****         }
2644:../src/FreeRTOS/queue.c ****         else
2645:../src/FreeRTOS/queue.c ****         {
2646:../src/FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2647:../src/FreeRTOS/queue.c ****         }
2648:../src/FreeRTOS/queue.c **** 
2649:../src/FreeRTOS/queue.c ****         return xCoRoutinePreviouslyWoken;
2650:../src/FreeRTOS/queue.c ****     }
2651:../src/FreeRTOS/queue.c **** 
2652:../src/FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2653:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2654:../src/FreeRTOS/queue.c **** 
2655:../src/FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2656:../src/FreeRTOS/queue.c **** 
2657:../src/FreeRTOS/queue.c ****     BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
2658:../src/FreeRTOS/queue.c ****                                        void * pvBuffer,
2659:../src/FreeRTOS/queue.c ****                                        BaseType_t * pxCoRoutineWoken )
2660:../src/FreeRTOS/queue.c ****     {
2661:../src/FreeRTOS/queue.c ****         BaseType_t xReturn;
2662:../src/FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
2663:../src/FreeRTOS/queue.c **** 
2664:../src/FreeRTOS/queue.c ****         /* We cannot block from an ISR, so check there is data available. If
2665:../src/FreeRTOS/queue.c ****          * not then just leave without doing anything. */
2666:../src/FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2667:../src/FreeRTOS/queue.c ****         {
2668:../src/FreeRTOS/queue.c ****             /* Copy the data from the queue. */
2669:../src/FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2670:../src/FreeRTOS/queue.c **** 
2671:../src/FreeRTOS/queue.c ****             if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2672:../src/FreeRTOS/queue.c ****             {
2673:../src/FreeRTOS/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2674:../src/FreeRTOS/queue.c ****             }
2675:../src/FreeRTOS/queue.c ****             else
2676:../src/FreeRTOS/queue.c ****             {
2677:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2678:../src/FreeRTOS/queue.c ****             }
2679:../src/FreeRTOS/queue.c **** 
2680:../src/FreeRTOS/queue.c ****             --( pxQueue->uxMessagesWaiting );
2681:../src/FreeRTOS/queue.c ****             ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsign
2682:../src/FreeRTOS/queue.c **** 
2683:../src/FreeRTOS/queue.c ****             if( ( *pxCoRoutineWoken ) == pdFALSE )
2684:../src/FreeRTOS/queue.c ****             {
2685:../src/FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2686:../src/FreeRTOS/queue.c ****                 {
2687:../src/FreeRTOS/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2688:../src/FreeRTOS/queue.c ****                     {
2689:../src/FreeRTOS/queue.c ****                         *pxCoRoutineWoken = pdTRUE;
2690:../src/FreeRTOS/queue.c ****                     }
2691:../src/FreeRTOS/queue.c ****                     else
2692:../src/FreeRTOS/queue.c ****                     {
2693:../src/FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2694:../src/FreeRTOS/queue.c ****                     }
2695:../src/FreeRTOS/queue.c ****                 }
2696:../src/FreeRTOS/queue.c ****                 else
2697:../src/FreeRTOS/queue.c ****                 {
2698:../src/FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2699:../src/FreeRTOS/queue.c ****                 }
2700:../src/FreeRTOS/queue.c ****             }
2701:../src/FreeRTOS/queue.c ****             else
2702:../src/FreeRTOS/queue.c ****             {
2703:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2704:../src/FreeRTOS/queue.c ****             }
2705:../src/FreeRTOS/queue.c **** 
2706:../src/FreeRTOS/queue.c ****             xReturn = pdPASS;
2707:../src/FreeRTOS/queue.c ****         }
2708:../src/FreeRTOS/queue.c ****         else
2709:../src/FreeRTOS/queue.c ****         {
2710:../src/FreeRTOS/queue.c ****             xReturn = pdFAIL;
2711:../src/FreeRTOS/queue.c ****         }
2712:../src/FreeRTOS/queue.c **** 
2713:../src/FreeRTOS/queue.c ****         return xReturn;
2714:../src/FreeRTOS/queue.c ****     }
2715:../src/FreeRTOS/queue.c **** 
2716:../src/FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2717:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2718:../src/FreeRTOS/queue.c **** 
2719:../src/FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2720:../src/FreeRTOS/queue.c **** 
2721:../src/FreeRTOS/queue.c ****     void vQueueAddToRegistry( QueueHandle_t xQueue,
2722:../src/FreeRTOS/queue.c ****                               const char * pcQueueName ) /*lint !e971 Unqualified char types are al
2723:../src/FreeRTOS/queue.c ****     {
 3823              		.loc 1 2723 5 is_stmt 1 view -0
 3824              		.cfi_startproc
 3825              		@ args = 0, pretend = 0, frame = 0
 3826              		@ frame_needed = 0, uses_anonymous_args = 0
 3827              		@ link register save eliminated.
2724:../src/FreeRTOS/queue.c ****         UBaseType_t ux;
 3828              		.loc 1 2724 9 view .LVU1161
2725:../src/FreeRTOS/queue.c **** 
2726:../src/FreeRTOS/queue.c ****         /* See if there is an empty space in the registry.  A NULL name denotes
2727:../src/FreeRTOS/queue.c ****          * a free slot. */
2728:../src/FreeRTOS/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3829              		.loc 1 2728 9 view .LVU1162
 3830              		.loc 1 2728 17 is_stmt 0 view .LVU1163
 3831 0000 0030A0E3 		mov	r3, #0
 3832              		.loc 1 2728 9 view .LVU1164
 3833 0004 000000EA 		b	.L312
 3834              	.LVL465:
 3835              	.L313:
2729:../src/FreeRTOS/queue.c ****         {
2730:../src/FreeRTOS/queue.c ****             if( xQueueRegistry[ ux ].pcQueueName == NULL )
2731:../src/FreeRTOS/queue.c ****             {
2732:../src/FreeRTOS/queue.c ****                 /* Store the information on this queue. */
2733:../src/FreeRTOS/queue.c ****                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
2734:../src/FreeRTOS/queue.c ****                 xQueueRegistry[ ux ].xHandle = xQueue;
2735:../src/FreeRTOS/queue.c **** 
2736:../src/FreeRTOS/queue.c ****                 traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2737:../src/FreeRTOS/queue.c ****                 break;
2738:../src/FreeRTOS/queue.c ****             }
2739:../src/FreeRTOS/queue.c ****             else
2740:../src/FreeRTOS/queue.c ****             {
2741:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 3836              		.loc 1 2741 41 is_stmt 1 discriminator 2 view .LVU1165
2728:../src/FreeRTOS/queue.c ****         {
 3837              		.loc 1 2728 87 discriminator 2 view .LVU1166
2728:../src/FreeRTOS/queue.c ****         {
 3838              		.loc 1 2728 89 is_stmt 0 discriminator 2 view .LVU1167
 3839 0008 013083E2 		add	r3, r3, #1
 3840              	.LVL466:
 3841              	.L312:
2728:../src/FreeRTOS/queue.c ****         {
 3842              		.loc 1 2728 39 is_stmt 1 discriminator 1 view .LVU1168
2728:../src/FreeRTOS/queue.c ****         {
 3843              		.loc 1 2728 9 is_stmt 0 discriminator 1 view .LVU1169
 3844 000c 070053E3 		cmp	r3, #7
 3845 0010 1EFF2F81 		bxhi	lr
2730:../src/FreeRTOS/queue.c ****             {
 3846              		.loc 1 2730 13 is_stmt 1 view .LVU1170
2730:../src/FreeRTOS/queue.c ****             {
 3847              		.loc 1 2730 37 is_stmt 0 view .LVU1171
 3848 0014 002000E3 		movw	r2, #:lower16:xQueueRegistry
 3849 0018 002040E3 		movt	r2, #:upper16:xQueueRegistry
 3850 001c 832192E7 		ldr	r2, [r2, r3, lsl #3]
2730:../src/FreeRTOS/queue.c ****             {
 3851              		.loc 1 2730 15 view .LVU1172
 3852 0020 000052E3 		cmp	r2, #0
 3853 0024 F7FFFF1A 		bne	.L313
2733:../src/FreeRTOS/queue.c ****                 xQueueRegistry[ ux ].xHandle = xQueue;
 3854              		.loc 1 2733 17 is_stmt 1 view .LVU1173
2733:../src/FreeRTOS/queue.c ****                 xQueueRegistry[ ux ].xHandle = xQueue;
 3855              		.loc 1 2733 50 is_stmt 0 view .LVU1174
 3856 0028 002000E3 		movw	r2, #:lower16:xQueueRegistry
 3857 002c 002040E3 		movt	r2, #:upper16:xQueueRegistry
 3858 0030 831182E7 		str	r1, [r2, r3, lsl #3]
2734:../src/FreeRTOS/queue.c **** 
 3859              		.loc 1 2734 17 is_stmt 1 view .LVU1175
2734:../src/FreeRTOS/queue.c **** 
 3860              		.loc 1 2734 46 is_stmt 0 view .LVU1176
 3861 0034 833182E0 		add	r3, r2, r3, lsl #3
 3862              	.LVL467:
2734:../src/FreeRTOS/queue.c **** 
 3863              		.loc 1 2734 46 view .LVU1177
 3864 0038 040083E5 		str	r0, [r3, #4]
2736:../src/FreeRTOS/queue.c ****                 break;
 3865              		.loc 1 2736 63 is_stmt 1 view .LVU1178
2737:../src/FreeRTOS/queue.c ****             }
 3866              		.loc 1 2737 17 view .LVU1179
 3867 003c 1EFF2FE1 		bx	lr
 3868              		.cfi_endproc
 3869              	.LFE33:
 3871              		.section	.text.pcQueueGetName,"ax",%progbits
 3872              		.align	2
 3873              		.global	pcQueueGetName
 3874              		.syntax unified
 3875              		.arm
 3876              		.fpu neon
 3878              	pcQueueGetName:
 3879              	.LVL468:
 3880              	.LFB34:
2742:../src/FreeRTOS/queue.c ****             }
2743:../src/FreeRTOS/queue.c ****         }
2744:../src/FreeRTOS/queue.c ****     }
2745:../src/FreeRTOS/queue.c **** 
2746:../src/FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2747:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2748:../src/FreeRTOS/queue.c **** 
2749:../src/FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2750:../src/FreeRTOS/queue.c **** 
2751:../src/FreeRTOS/queue.c ****     const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are all
2752:../src/FreeRTOS/queue.c ****     {
 3881              		.loc 1 2752 5 view -0
 3882              		.cfi_startproc
 3883              		@ args = 0, pretend = 0, frame = 0
 3884              		@ frame_needed = 0, uses_anonymous_args = 0
 3885              		@ link register save eliminated.
2753:../src/FreeRTOS/queue.c ****         UBaseType_t ux;
 3886              		.loc 1 2753 9 view .LVU1181
2754:../src/FreeRTOS/queue.c ****         const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings a
 3887              		.loc 1 2754 9 view .LVU1182
2755:../src/FreeRTOS/queue.c **** 
2756:../src/FreeRTOS/queue.c ****         /* Note there is nothing here to protect against another task adding or
2757:../src/FreeRTOS/queue.c ****          * removing entries from the registry while it is being searched. */
2758:../src/FreeRTOS/queue.c **** 
2759:../src/FreeRTOS/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3888              		.loc 1 2759 9 view .LVU1183
 3889              		.loc 1 2759 17 is_stmt 0 view .LVU1184
 3890 0000 0020A0E3 		mov	r2, #0
 3891              		.loc 1 2759 9 view .LVU1185
 3892 0004 000000EA 		b	.L317
 3893              	.LVL469:
 3894              	.L318:
2760:../src/FreeRTOS/queue.c ****         {
2761:../src/FreeRTOS/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
2762:../src/FreeRTOS/queue.c ****             {
2763:../src/FreeRTOS/queue.c ****                 pcReturn = xQueueRegistry[ ux ].pcQueueName;
2764:../src/FreeRTOS/queue.c ****                 break;
2765:../src/FreeRTOS/queue.c ****             }
2766:../src/FreeRTOS/queue.c ****             else
2767:../src/FreeRTOS/queue.c ****             {
2768:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 3895              		.loc 1 2768 41 is_stmt 1 discriminator 2 view .LVU1186
2759:../src/FreeRTOS/queue.c ****         {
 3896              		.loc 1 2759 87 discriminator 2 view .LVU1187
2759:../src/FreeRTOS/queue.c ****         {
 3897              		.loc 1 2759 89 is_stmt 0 discriminator 2 view .LVU1188
 3898 0008 012082E2 		add	r2, r2, #1
 3899              	.LVL470:
 3900              	.L317:
2759:../src/FreeRTOS/queue.c ****         {
 3901              		.loc 1 2759 39 is_stmt 1 discriminator 1 view .LVU1189
2759:../src/FreeRTOS/queue.c ****         {
 3902              		.loc 1 2759 9 is_stmt 0 discriminator 1 view .LVU1190
 3903 000c 070052E3 		cmp	r2, #7
 3904 0010 0900008A 		bhi	.L321
2761:../src/FreeRTOS/queue.c ****             {
 3905              		.loc 1 2761 13 is_stmt 1 view .LVU1191
2761:../src/FreeRTOS/queue.c ****             {
 3906              		.loc 1 2761 37 is_stmt 0 view .LVU1192
 3907 0014 003000E3 		movw	r3, #:lower16:xQueueRegistry
 3908 0018 003040E3 		movt	r3, #:upper16:xQueueRegistry
 3909 001c 823183E0 		add	r3, r3, r2, lsl #3
 3910 0020 043093E5 		ldr	r3, [r3, #4]
2761:../src/FreeRTOS/queue.c ****             {
 3911              		.loc 1 2761 15 view .LVU1193
 3912 0024 000053E1 		cmp	r3, r0
 3913 0028 F6FFFF1A 		bne	.L318
2763:../src/FreeRTOS/queue.c ****                 break;
 3914              		.loc 1 2763 17 is_stmt 1 view .LVU1194
2763:../src/FreeRTOS/queue.c ****                 break;
 3915              		.loc 1 2763 26 is_stmt 0 view .LVU1195
 3916 002c 003000E3 		movw	r3, #:lower16:xQueueRegistry
 3917 0030 003040E3 		movt	r3, #:upper16:xQueueRegistry
 3918 0034 820193E7 		ldr	r0, [r3, r2, lsl #3]
 3919              	.LVL471:
2764:../src/FreeRTOS/queue.c ****             }
 3920              		.loc 1 2764 17 is_stmt 1 view .LVU1196
 3921 0038 1EFF2FE1 		bx	lr
 3922              	.LVL472:
 3923              	.L321:
2754:../src/FreeRTOS/queue.c **** 
 3924              		.loc 1 2754 22 is_stmt 0 view .LVU1197
 3925 003c 0000A0E3 		mov	r0, #0
 3926              	.LVL473:
2769:../src/FreeRTOS/queue.c ****             }
2770:../src/FreeRTOS/queue.c ****         }
2771:../src/FreeRTOS/queue.c **** 
2772:../src/FreeRTOS/queue.c ****         return pcReturn;
 3927              		.loc 1 2772 9 is_stmt 1 view .LVU1198
2773:../src/FreeRTOS/queue.c ****     } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 3928              		.loc 1 2773 5 is_stmt 0 view .LVU1199
 3929 0040 1EFF2FE1 		bx	lr
 3930              		.cfi_endproc
 3931              	.LFE34:
 3933              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 3934              		.align	2
 3935              		.global	vQueueUnregisterQueue
 3936              		.syntax unified
 3937              		.arm
 3938              		.fpu neon
 3940              	vQueueUnregisterQueue:
 3941              	.LVL474:
 3942              	.LFB35:
2774:../src/FreeRTOS/queue.c **** 
2775:../src/FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2776:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2777:../src/FreeRTOS/queue.c **** 
2778:../src/FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2779:../src/FreeRTOS/queue.c **** 
2780:../src/FreeRTOS/queue.c ****     void vQueueUnregisterQueue( QueueHandle_t xQueue )
2781:../src/FreeRTOS/queue.c ****     {
 3943              		.loc 1 2781 5 is_stmt 1 view -0
 3944              		.cfi_startproc
 3945              		@ args = 0, pretend = 0, frame = 0
 3946              		@ frame_needed = 0, uses_anonymous_args = 0
 3947              		@ link register save eliminated.
2782:../src/FreeRTOS/queue.c ****         UBaseType_t ux;
 3948              		.loc 1 2782 9 view .LVU1201
2783:../src/FreeRTOS/queue.c **** 
2784:../src/FreeRTOS/queue.c ****         /* See if the handle of the queue being unregistered in actually in the
2785:../src/FreeRTOS/queue.c ****          * registry. */
2786:../src/FreeRTOS/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3949              		.loc 1 2786 9 view .LVU1202
 3950              		.loc 1 2786 17 is_stmt 0 view .LVU1203
 3951 0000 0020A0E3 		mov	r2, #0
 3952              		.loc 1 2786 9 view .LVU1204
 3953 0004 000000EA 		b	.L323
 3954              	.LVL475:
 3955              	.L324:
2787:../src/FreeRTOS/queue.c ****         {
2788:../src/FreeRTOS/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
2789:../src/FreeRTOS/queue.c ****             {
2790:../src/FreeRTOS/queue.c ****                 /* Set the name to NULL to show that this slot if free again. */
2791:../src/FreeRTOS/queue.c ****                 xQueueRegistry[ ux ].pcQueueName = NULL;
2792:../src/FreeRTOS/queue.c **** 
2793:../src/FreeRTOS/queue.c ****                 /* Set the handle to NULL to ensure the same queue handle cannot
2794:../src/FreeRTOS/queue.c ****                  * appear in the registry twice if it is added, removed, then
2795:../src/FreeRTOS/queue.c ****                  * added again. */
2796:../src/FreeRTOS/queue.c ****                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
2797:../src/FreeRTOS/queue.c ****                 break;
2798:../src/FreeRTOS/queue.c ****             }
2799:../src/FreeRTOS/queue.c ****             else
2800:../src/FreeRTOS/queue.c ****             {
2801:../src/FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 3956              		.loc 1 2801 41 is_stmt 1 discriminator 2 view .LVU1205
2786:../src/FreeRTOS/queue.c ****         {
 3957              		.loc 1 2786 87 discriminator 2 view .LVU1206
2786:../src/FreeRTOS/queue.c ****         {
 3958              		.loc 1 2786 89 is_stmt 0 discriminator 2 view .LVU1207
 3959 0008 012082E2 		add	r2, r2, #1
 3960              	.LVL476:
 3961              	.L323:
2786:../src/FreeRTOS/queue.c ****         {
 3962              		.loc 1 2786 39 is_stmt 1 discriminator 1 view .LVU1208
2786:../src/FreeRTOS/queue.c ****         {
 3963              		.loc 1 2786 9 is_stmt 0 discriminator 1 view .LVU1209
 3964 000c 070052E3 		cmp	r2, #7
 3965 0010 1EFF2F81 		bxhi	lr
2788:../src/FreeRTOS/queue.c ****             {
 3966              		.loc 1 2788 13 is_stmt 1 view .LVU1210
2788:../src/FreeRTOS/queue.c ****             {
 3967              		.loc 1 2788 37 is_stmt 0 view .LVU1211
 3968 0014 003000E3 		movw	r3, #:lower16:xQueueRegistry
 3969 0018 003040E3 		movt	r3, #:upper16:xQueueRegistry
 3970 001c 823183E0 		add	r3, r3, r2, lsl #3
 3971 0020 043093E5 		ldr	r3, [r3, #4]
2788:../src/FreeRTOS/queue.c ****             {
 3972              		.loc 1 2788 15 view .LVU1212
 3973 0024 000053E1 		cmp	r3, r0
 3974 0028 F6FFFF1A 		bne	.L324
2791:../src/FreeRTOS/queue.c **** 
 3975              		.loc 1 2791 17 is_stmt 1 view .LVU1213
2791:../src/FreeRTOS/queue.c **** 
 3976              		.loc 1 2791 50 is_stmt 0 view .LVU1214
 3977 002c 003000E3 		movw	r3, #:lower16:xQueueRegistry
 3978 0030 003040E3 		movt	r3, #:upper16:xQueueRegistry
 3979 0034 0010A0E3 		mov	r1, #0
 3980 0038 821183E7 		str	r1, [r3, r2, lsl #3]
2796:../src/FreeRTOS/queue.c ****                 break;
 3981              		.loc 1 2796 17 is_stmt 1 view .LVU1215
2796:../src/FreeRTOS/queue.c ****                 break;
 3982              		.loc 1 2796 46 is_stmt 0 view .LVU1216
 3983 003c 822183E0 		add	r2, r3, r2, lsl #3
 3984              	.LVL477:
2796:../src/FreeRTOS/queue.c ****                 break;
 3985              		.loc 1 2796 46 view .LVU1217
 3986 0040 041082E5 		str	r1, [r2, #4]
2797:../src/FreeRTOS/queue.c ****             }
 3987              		.loc 1 2797 17 is_stmt 1 view .LVU1218
 3988 0044 1EFF2FE1 		bx	lr
 3989              		.cfi_endproc
 3990              	.LFE35:
 3992              		.section	.text.vQueueDelete,"ax",%progbits
 3993              		.align	2
 3994              		.global	vQueueDelete
 3995              		.syntax unified
 3996              		.arm
 3997              		.fpu neon
 3999              	vQueueDelete:
 4000              	.LVL478:
 4001              	.LFB21:
2027:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 4002              		.loc 1 2027 1 view -0
 4003              		.cfi_startproc
 4004              		@ args = 0, pretend = 0, frame = 0
 4005              		@ frame_needed = 0, uses_anonymous_args = 0
2027:../src/FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 4006              		.loc 1 2027 1 is_stmt 0 view .LVU1220
 4007 0000 10402DE9 		push	{r4, lr}
 4008              		.cfi_def_cfa_offset 8
 4009              		.cfi_offset 4, -8
 4010              		.cfi_offset 14, -4
2028:../src/FreeRTOS/queue.c **** 
 4011              		.loc 1 2028 5 is_stmt 1 view .LVU1221
 4012              	.LVL479:
2030:../src/FreeRTOS/queue.c ****     traceQUEUE_DELETE( pxQueue );
 4013              		.loc 1 2030 5 view .LVU1222
 4014 0004 004050E2 		subs	r4, r0, #0
 4015 0008 0400000A 		beq	.L330
 4016              	.LVL480:
 4017              	.L328:
2030:../src/FreeRTOS/queue.c ****     traceQUEUE_DELETE( pxQueue );
 4018              		.loc 1 2030 28 discriminator 3 view .LVU1223
2031:../src/FreeRTOS/queue.c **** 
 4019              		.loc 1 2031 33 discriminator 3 view .LVU1224
2035:../src/FreeRTOS/queue.c ****         }
 4020              		.loc 1 2035 13 discriminator 3 view .LVU1225
 4021 000c 0400A0E1 		mov	r0, r4
 4022 0010 FEFFFFEB 		bl	vQueueUnregisterQueue
 4023              	.LVL481:
2043:../src/FreeRTOS/queue.c ****         }
 4024              		.loc 1 2043 13 discriminator 3 view .LVU1226
 4025 0014 0400A0E1 		mov	r0, r4
 4026 0018 FEFFFFEB 		bl	vPortFree
 4027              	.LVL482:
2065:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 4028              		.loc 1 2065 1 is_stmt 0 discriminator 3 view .LVU1227
 4029 001c 1080BDE8 		pop	{r4, pc}
 4030              	.LVL483:
 4031              	.L330:
2030:../src/FreeRTOS/queue.c ****     traceQUEUE_DELETE( pxQueue );
 4032              		.loc 1 2030 5 is_stmt 1 discriminator 1 view .LVU1228
 4033 0020 EE1700E3 		movw	r1, #2030
 4034 0024 000000E3 		movw	r0, #:lower16:.LC0
 4035              	.LVL484:
2030:../src/FreeRTOS/queue.c ****     traceQUEUE_DELETE( pxQueue );
 4036              		.loc 1 2030 5 is_stmt 0 discriminator 1 view .LVU1229
 4037 0028 000040E3 		movt	r0, #:upper16:.LC0
 4038 002c FEFFFFEB 		bl	R_OS_AssertCalled
 4039              	.LVL485:
 4040 0030 F5FFFFEA 		b	.L328
 4041              		.cfi_endproc
 4042              	.LFE21:
 4044              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 4045              		.align	2
 4046              		.global	vQueueWaitForMessageRestricted
 4047              		.syntax unified
 4048              		.arm
 4049              		.fpu neon
 4051              	vQueueWaitForMessageRestricted:
 4052              	.LVL486:
 4053              	.LFB36:
2802:../src/FreeRTOS/queue.c ****             }
2803:../src/FreeRTOS/queue.c ****         }
2804:../src/FreeRTOS/queue.c ****     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2805:../src/FreeRTOS/queue.c **** 
2806:../src/FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2807:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2808:../src/FreeRTOS/queue.c **** 
2809:../src/FreeRTOS/queue.c **** #if ( configUSE_TIMERS == 1 )
2810:../src/FreeRTOS/queue.c **** 
2811:../src/FreeRTOS/queue.c ****     void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
2812:../src/FreeRTOS/queue.c ****                                          TickType_t xTicksToWait,
2813:../src/FreeRTOS/queue.c ****                                          const BaseType_t xWaitIndefinitely )
2814:../src/FreeRTOS/queue.c ****     {
 4054              		.loc 1 2814 5 is_stmt 1 view -0
 4055              		.cfi_startproc
 4056              		@ args = 0, pretend = 0, frame = 0
 4057              		@ frame_needed = 0, uses_anonymous_args = 0
 4058              		.loc 1 2814 5 is_stmt 0 view .LVU1231
 4059 0000 70402DE9 		push	{r4, r5, r6, lr}
 4060              		.cfi_def_cfa_offset 16
 4061              		.cfi_offset 4, -16
 4062              		.cfi_offset 5, -12
 4063              		.cfi_offset 6, -8
 4064              		.cfi_offset 14, -4
 4065 0004 0040A0E1 		mov	r4, r0
 4066 0008 0150A0E1 		mov	r5, r1
 4067 000c 0260A0E1 		mov	r6, r2
2815:../src/FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
 4068              		.loc 1 2815 9 is_stmt 1 view .LVU1232
 4069              	.LVL487:
2816:../src/FreeRTOS/queue.c **** 
2817:../src/FreeRTOS/queue.c ****         /* This function should not be called by application code hence the
2818:../src/FreeRTOS/queue.c ****          * 'Restricted' in its name.  It is not part of the public API.  It is
2819:../src/FreeRTOS/queue.c ****          * designed for use by kernel code, and has special calling requirements.
2820:../src/FreeRTOS/queue.c ****          * It can result in vListInsert() being called on a list that can only
2821:../src/FreeRTOS/queue.c ****          * possibly ever have one item in it, so the list will be fast, but even
2822:../src/FreeRTOS/queue.c ****          * so it should be called with the scheduler locked and not from a critical
2823:../src/FreeRTOS/queue.c ****          * section. */
2824:../src/FreeRTOS/queue.c **** 
2825:../src/FreeRTOS/queue.c ****         /* Only do anything if there are no messages in the queue.  This function
2826:../src/FreeRTOS/queue.c ****          *  will not actually cause the task to block, just place it on a blocked
2827:../src/FreeRTOS/queue.c ****          *  list.  It will not block until the scheduler is unlocked - at which
2828:../src/FreeRTOS/queue.c ****          *  time a yield will be performed.  If an item is added to the queue while
2829:../src/FreeRTOS/queue.c ****          *  the queue is locked, and the calling task blocks on the queue, then the
2830:../src/FreeRTOS/queue.c ****          *  calling task will be immediately unblocked when the queue is unlocked. */
2831:../src/FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 4070              		.loc 1 2831 9 view .LVU1233
 4071 0010 FEFFFFEB 		bl	vPortEnterCritical
 4072              	.LVL488:
 4073              		.loc 1 2831 9 view .LVU1234
 4074              		.loc 1 2831 9 view .LVU1235
 4075 0014 4430D4E5 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 4076 0018 7330AFE6 		sxtb	r3, r3
 4077 001c 010073E3 		cmn	r3, #1
 4078 0020 0A00000A 		beq	.L336
 4079              	.L332:
 4080              		.loc 1 2831 9 discriminator 3 view .LVU1236
 4081 0024 4530D4E5 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 4082 0028 7330AFE6 		sxtb	r3, r3
 4083 002c 010073E3 		cmn	r3, #1
 4084 0030 0900000A 		beq	.L337
 4085              	.L333:
 4086              		.loc 1 2831 9 discriminator 6 view .LVU1237
 4087 0034 FEFFFFEB 		bl	vPortExitCritical
 4088              	.LVL489:
 4089              		.loc 1 2831 32 discriminator 6 view .LVU1238
2832:../src/FreeRTOS/queue.c **** 
2833:../src/FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 4090              		.loc 1 2833 9 discriminator 6 view .LVU1239
 4091              		.loc 1 2833 20 is_stmt 0 discriminator 6 view .LVU1240
 4092 0038 383094E5 		ldr	r3, [r4, #56]
 4093              		.loc 1 2833 11 discriminator 6 view .LVU1241
 4094 003c 000053E3 		cmp	r3, #0
 4095 0040 0800000A 		beq	.L338
 4096              	.L334:
2834:../src/FreeRTOS/queue.c ****         {
2835:../src/FreeRTOS/queue.c ****             /* There is nothing in the queue, block for the specified period. */
2836:../src/FreeRTOS/queue.c ****             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xW
2837:../src/FreeRTOS/queue.c ****         }
2838:../src/FreeRTOS/queue.c ****         else
2839:../src/FreeRTOS/queue.c ****         {
2840:../src/FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 4097              		.loc 1 2840 37 is_stmt 1 view .LVU1242
2841:../src/FreeRTOS/queue.c ****         }
2842:../src/FreeRTOS/queue.c **** 
2843:../src/FreeRTOS/queue.c ****         prvUnlockQueue( pxQueue );
 4098              		.loc 1 2843 9 view .LVU1243
 4099 0044 0400A0E1 		mov	r0, r4
 4100 0048 FEFFFFEB 		bl	prvUnlockQueue
 4101              	.LVL490:
2844:../src/FreeRTOS/queue.c ****     }
 4102              		.loc 1 2844 5 is_stmt 0 view .LVU1244
 4103 004c 7080BDE8 		pop	{r4, r5, r6, pc}
 4104              	.L336:
2831:../src/FreeRTOS/queue.c **** 
 4105              		.loc 1 2831 9 is_stmt 1 discriminator 1 view .LVU1245
 4106 0050 0030A0E3 		mov	r3, #0
 4107 0054 4430C4E5 		strb	r3, [r4, #68]
 4108 0058 F1FFFFEA 		b	.L332
 4109              	.L337:
2831:../src/FreeRTOS/queue.c **** 
 4110              		.loc 1 2831 9 discriminator 4 view .LVU1246
 4111 005c 0030A0E3 		mov	r3, #0
 4112 0060 4530C4E5 		strb	r3, [r4, #69]
 4113 0064 F2FFFFEA 		b	.L333
 4114              	.L338:
2836:../src/FreeRTOS/queue.c ****         }
 4115              		.loc 1 2836 13 view .LVU1247
 4116 0068 0620A0E1 		mov	r2, r6
 4117 006c 0510A0E1 		mov	r1, r5
 4118 0070 240084E2 		add	r0, r4, #36
 4119 0074 FEFFFFEB 		bl	vTaskPlaceOnEventListRestricted
 4120              	.LVL491:
 4121 0078 F1FFFFEA 		b	.L334
 4122              		.cfi_endproc
 4123              	.LFE36:
 4125              		.comm	xQueueRegistry,64,4
 4126              		.text
 4127              	.Letext0:
 4128              		.file 2 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\lib\\gcc\\arm-none
 4129              		.file 3 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 4130              		.file 4 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 4131              		.file 5 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 4132              		.file 6 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 4133              		.file 7 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 4134              		.file 8 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 4135              		.file 9 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 4136              		.file 10 "C:\\Users\\ryota\\e2_studio\\workspace\\rza2m_ssif_sample_freertos_gcc\\src\\FreeRTOS\\p
 4137              		.file 11 "C:\\Users\\ryota\\e2_studio\\workspace\\rza2m_ssif_sample_freertos_gcc\\src\\FreeRTOS\\i
 4138              		.file 12 "C:\\Users\\ryota\\e2_studio\\workspace\\rza2m_ssif_sample_freertos_gcc\\src\\FreeRTOS\\i
 4139              		.file 13 "C:\\Users\\ryota\\e2_studio\\workspace\\rza2m_ssif_sample_freertos_gcc\\src\\FreeRTOS\\i
 4140              		.file 14 "C:\\Users\\ryota\\e2_studio\\workspace\\rza2m_ssif_sample_freertos_gcc\\src\\config_file
 4141              		.file 15 "C:\\Users\\ryota\\e2_studio\\workspace\\rza2m_ssif_sample_freertos_gcc\\src\\FreeRTOS\\i
 4142              		.file 16 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:17     .text.prvGetDisinheritPriorityAfterTimeout:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:25     .text.prvGetDisinheritPriorityAfterTimeout:00000000 prvGetDisinheritPriorityAfterTimeout
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:60     .text.prvIsQueueFull:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:65     .text.prvIsQueueFull:00000000 prvIsQueueFull
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:114    .text.prvIsQueueEmpty:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:119    .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:166    .text.prvCopyDataToQueue:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:171    .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:328    .text.prvCopyDataFromQueue:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:333    .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:385    .text.prvUnlockQueue:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:390    .text.prvUnlockQueue:00000000 prvUnlockQueue
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:521    .rodata.xQueueGenericReset.str1.4:00000000 $d
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:522    .rodata.xQueueGenericReset.str1.4:00000000 .LC0
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:525    .text.xQueueGenericReset:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:531    .text.xQueueGenericReset:00000000 xQueueGenericReset
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:654    .text.prvInitialiseNewQueue:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:659    .text.prvInitialiseNewQueue:00000000 prvInitialiseNewQueue
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:718    .text.xQueueGenericCreate:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:724    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:846    .text.xQueueGetMutexHolder:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:852    .text.xQueueGetMutexHolder:00000000 xQueueGetMutexHolder
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:902    .text.xQueueGetMutexHolderFromISR:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:908    .text.xQueueGetMutexHolderFromISR:00000000 xQueueGetMutexHolderFromISR
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:961    .text.xQueueCreateCountingSemaphore:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:967    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1039   .text.xQueueGenericSend:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1045   .text.xQueueGenericSend:00000000 xQueueGenericSend
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1368   .text.prvInitialiseMutex:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1373   .text.prvInitialiseMutex:00000000 prvInitialiseMutex
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1414   .text.xQueueCreateMutex:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1420   .text.xQueueCreateMutex:00000000 xQueueCreateMutex
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1457   .text.xQueueGiveMutexRecursive:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1463   .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1544   .text.xQueueGenericSendFromISR:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1550   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1765   .text.xQueueGiveFromISR:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1771   .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1993   .text.xQueueReceive:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:1999   .text.xQueueReceive:00000000 xQueueReceive
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:2310   .text.xQueueSemaphoreTake:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:2316   .text.xQueueSemaphoreTake:00000000 xQueueSemaphoreTake
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:2708   .text.xQueueTakeMutexRecursive:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:2714   .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:2798   .text.xQueuePeek:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:2804   .text.xQueuePeek:00000000 xQueuePeek
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3117   .text.xQueueReceiveFromISR:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3123   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3323   .text.xQueuePeekFromISR:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3329   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3457   .text.uxQueueMessagesWaiting:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3463   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3513   .text.uxQueueSpacesAvailable:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3519   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3576   .text.uxQueueMessagesWaitingFromISR:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3582   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3625   .text.uxQueueGetQueueNumber:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3631   .text.uxQueueGetQueueNumber:00000000 uxQueueGetQueueNumber
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3649   .text.vQueueSetQueueNumber:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3655   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3672   .text.ucQueueGetQueueType:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3678   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3696   .text.xQueueIsQueueEmptyFromISR:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3702   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3754   .text.xQueueIsQueueFullFromISR:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3760   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3814   .text.vQueueAddToRegistry:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3820   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
                            *COM*:00000040 xQueueRegistry
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3872   .text.pcQueueGetName:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3878   .text.pcQueueGetName:00000000 pcQueueGetName
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3934   .text.vQueueUnregisterQueue:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3940   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3993   .text.vQueueDelete:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:3999   .text.vQueueDelete:00000000 vQueueDelete
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:4045   .text.vQueueWaitForMessageRestricted:00000000 $a
C:\Users\ryota\AppData\Local\Temp\ccs1V5zs.s:4051   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                           .group:00000000 wm4.0.3d5c910ebb40df6df78b28e37cd67f3d
                           .group:00000000 wm4.ieeefp.h.77.3f06799abf5dd88bdddee084775a1223
                           .group:00000000 wm4._newlib_version.h.4.1ef4e12f167f8b69d7c30054be56050d
                           .group:00000000 wm4.newlib.h.18.1c9fedb6b3cd797cff253cc0fd593ef2
                           .group:00000000 wm4.features.h.22.fad1cec3bc7ff06488171438dbdcfd02
                           .group:00000000 wm4.config.h.224.c701144a7b0518c6ee9b9b5465b79f81
                           .group:00000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.181.13772e73e5434e8cc4fafaaddad2b5da
                           .group:00000000 wm4.stddef.h.39.cf3ebec0bc8c9e3d2f276a64e0fe5e7a
                           .group:00000000 wm4._types.h.20.dd0d04dca3800a0d2a6129b87f3adbb2
                           .group:00000000 wm4.stddef.h.155.3588ebfdd1e8c7ede80509bb9c3b8009
                           .group:00000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:00000000 wm4._types.h.127.34941de1b2539d59d5cac00e0dd27a45
                           .group:00000000 wm4.reent.h.17.e292bf8b0bec6c96e131a54347145a30
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4.reent.h.77.dcd6129ff07fe81bd5636db29abe53b2
                           .group:00000000 wm4.cdefs.h.49.6260d97adb8d27534cbdc0f868b8ea87
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.56.f4862cfbf4363a1db01842d5bdf72c18
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.155.ba788add86a0e365f264484f110c3c29
                           .group:00000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.r_task_priority.h.26.416bb98a222bf391200df359bd0318d1
                           .group:00000000 wm4.FreeRTOSConfig.h.79.b5458a5c31689ea246b5d3a5f655ce5b
                           .group:00000000 wm4.projdefs.h.28.d6a7c9061b707820f2fcf4c2ff5d9f24
                           .group:00000000 wm4.math.h.13.97100c05caf9f40dd9f5a3cda48ccc01
                           .group:00000000 wm4.r_typedefs.h.38.e90d9de5300d9ae020e5db8c5af88b3e
                           .group:00000000 wm4.portmacro.h.32.440d21c040186908c7273660706c6bca
                           .group:00000000 wm4.portable.h.63.e9cc508c3850f44ce542149380c67812
                           .group:00000000 wm4.mpu_wrappers.h.28.768974478c42e424045182d5a8740d87
                           .group:00000000 wm4.FreeRTOS.h.67.5b4462ac037a881bffd21a8fce4c91ce
                           .group:00000000 wm4.list.h.57.02ec67e07eacffe5ca7cfb7326896236
                           .group:00000000 wm4.task.h.47.5632d4e651ed85e40d7d5c5d13006d85
                           .group:00000000 wm4.queue.h.66.45d4a3cf5de24cde7e732f8dad25383c

UNDEFINED SYMBOLS
vPortEnterCritical
vPortExitCritical
xTaskPriorityDisinherit
memcpy
vTaskMissedYield
xTaskRemoveFromEventList
R_OS_AssertCalled
vListInitialise
__aeabi_uidiv
pvPortMalloc
xTaskGetSchedulerState
vTaskInternalSetTimeOutState
xTaskResumeAll
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskGetCurrentTaskHandle
vPortValidateInterruptPriority
ulPortSetInterruptMask
vPortClearInterruptMask
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
vPortFree
vTaskPlaceOnEventListRestricted
